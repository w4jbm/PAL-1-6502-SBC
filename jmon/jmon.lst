ca65 V2.18 - Ubuntu 2.18-1
Main file   : jmon.s
Current file: jmon.s

000000r 1               ; JMON - 6502 Monitor Program
000000r 1               ;
000000r 1               ; Copyright (C) 2012-2021 by Jeff Tranter <tranter@pobox.com>
000000r 1               ;
000000r 1               ; Licensed under the Apache License, Version 2.0 (the "License");
000000r 1               ; you may not use this file except in compliance with the License.
000000r 1               ; You may obtain a copy of the License at
000000r 1               ;
000000r 1               ;   http://www.apache.org/licenses/LICENSE-2.0
000000r 1               ;
000000r 1               ; Unless required by applicable law or agreed to in writing, software
000000r 1               ; distributed under the License is distributed on an "AS IS" BASIS,
000000r 1               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
000000r 1               ; See the License for the specific language governing permissions and
000000r 1               ; limitations under the License.
000000r 1               ;
000000r 1               ; Possible Future Enhancements:
000000r 1               ; - use CPU type option for disassembly/assembly/trace
000000r 1               ; - trace: support for 65C02 instructions (only need to implement BBR and BBS)
000000r 1               ; - trace: support for 65816 instructions, including variable length
000000r 1               ; - assembler: support for Rockwell 65C02 RMB, SMB, BBS, and BBR instructions
000000r 1               ; - assembler: support for 65816 addressing modes
000000r 1               ; - assembler: binary, character, decimal constants
000000r 1               ; - disassembler: comment out more 65816 and 65C02-specific code when support is not enabled
000000r 1               ; - refactor some common code to reduce size
000000r 1               ; - option to use other device for I/O, e.g. ACIA on Multi I/O card
000000r 1               ; - make some modules configurable to enable/disable to reduce code size
000000r 1               
000000r 1               ; Revision History
000000r 1               ; Version Date         Comments
000000r 1               ; 0.0     19-Feb-2012  First version started
000000r 1               ; 0.1     21-Feb-2012  Initial release
000000r 1               ; 0.2     10-Mar-2012  Added search command. Avoid endless loop in PrintString if string too long.
000000r 1               ; 0.3     28-Mar-2012  Added Unassemble command.
000000r 1               ; 0.4     30-Mar-2012  Added Test and Breakpoint commands.
000000r 1               ; 0.5     08-May-2012  Added write delay command for slow EEPROM access
000000r 1               ; 0.6     15-May-2012  Support overlapping addresses in copy command
000000r 1               ; 0.7     16-May-2012  Prompt whether to continue when Verify detects mismatch or Search finds match.
000000r 1               ; 0.8     17-May-2012  Search and Fill commands now use 16 bit patterns.
000000r 1               ; 0.9     22-May-2012  Added M command to call CFFA1 menu.
000000r 1               ; 0.91    23-May-2012  Now uses smarter "option picker" for commands.
000000r 1               ; 0.92    03-Jun-2012  Added ":" command
000000r 1               ; 0.93    06-Jun-2012  Added Register command. Former Run command is now Go.
000000r 1               ; 0.94    17-Jun-2012  Display error in break handler if interrupt occurred.
000000r 1               ;                      Fill command accepts variable length pattern.
000000r 1               ;                      Search command accepts variable length pattern.
000000r 1               ; 0.95    18-Jun-2012  Use constants for keyboard registers.
000000r 1               ;                      Removed reliance on Woz Mon routines.
000000r 1               ;                      Go command now does a JSR (or equivalent) so called program can return.
000000r 1               ;                      Added = command for simple hex math calculations (add/subtract).
000000r 1               ; 0.96    21-Jun-2012  Some refactoring to improve common code.
000000r 1               ;                      Improvements to comments.
000000r 1               ;                      Added new L command to clear screen.
000000r 1               ;                      Moved most variables out of page zero.
000000r 1               ;                      Added new E command for ACI cassette interface (untested).
000000r 1               ;                      Fill, Search, and ":" commands accept characters as well as hex values.
000000r 1               ;                      Type ' to enter a character.
000000r 1               ; 0.97   03-Jul-2012   Implemented new options command.
000000r 1               ;                      Added support for 65816 to disassembler.
000000r 1               ;                      Disassembler can be conditionally assembled for different CPU support.
000000r 1               ;        07-Jul-2012   Now adjusts disassembly of 65816 instructions for 8/16-bit modes.
000000r 1               ;                      Also fixed missing SEP opcode (error in WDC manual).
000000r 1               ; 0.98   08-Jul-2012   Added mini assembler (replaces call to Krusader)
000000r 1               ; 0.99   11-Jul-2012   Added trace feature (replaces call to Krusader mini monitor).
000000r 1               ;        16-Jul-2012   Add check that BASIC is present before jumping to it.
000000r 1               ;                      Restore stack pointer after returning from Go command so we don't
000000r 1               ;                      need to restart JMON.
000000r 1               ;                      Processor status bits are shown in lower case if supported.
000000r 1               ;                      Moved variables to allow program to run in ROM.
000000r 1               ;        18-Jul-2012   Added new iNfo command.
000000r 1               ; 1.0    20-Jul-2012   Bump version to 1.00.
000000r 1               ; 1.0.1  14-Oct-2012   Added new checKsum command.
000000r 1               ; 1.0.2  23-Mar-2014   Bug fixes from Dave Lyons:
000000r 1               ;                      Properly check for top of RAM in INFO command.
000000r 1               ;                      Fix extra code in tests for start and end addresses.
000000r 1               ;                      Factor out code for address range check into subroutine.
000000r 1               ;                      Check if RAM test spans two pages.
000000r 1               ;                      Optimize JSR / RTS to JMP
000000r 1               ; 1.1.0  30-Jan-2015   Added support for Superboard /// platform
000000r 1               ; 1.2.0  22-Mar-2015   Added support for KIM-1 computer platform
000000r 1               ; 1.2.1  25-Mar-2015   All features now working on KIM-1 platform
000000r 1               ; 1.3.0  12-Aug-2015   Added support for Apple II platform.
000000r 1               ; 1.3.1  19-Aug-2015   Breakpoints working. Added Computer type to info cmd.
000000r 1               ; 1.3.2  09-Sep-2015   Show Apple II peripheral cards in slots.
000000r 1               ;                      Add CPU speed test for Apple II.
000000r 1               ;                      Added Imprint routine and used it for unique strings.
000000r 1               ; 1.3.3  30-Nov-2016   Make miniassembler optional to reduce program size.
000000r 1               ; 1.3.4  26-Feb-2020   Fix bug in disassembler address incrementing.
000000r 1               ;                      Tested on real OSI Superboard II.
000000r 1               ; 1.3.5  13-Dec-2020   Added port to my Single Board Computer
000000r 1               ; 1.3.6  03-Mar-2021   Add J (S record loading) and W (S record writing) commands.
000000r 1               
000000r 1               ; Platform
000000r 1               ; Define either APPLE1 for Apple 1 Replica 1, Apple2 for Apple II series,
000000r 1               ; OSI for Ohio Scientific SuperBoard II or ///, or KIM1 for KIM-1 platform.
000000r 1               ; SBC for my Single Board Computer.
000000r 1               ; Normally this is set in the Makefile.
000000r 1               ; APPLE1  = 1
000000r 1               ; APPLE2  = 1
000000r 1               ; OSI     = 1
000000r 1               ; KIM1    = 1
000000r 1               ; SBC     = 1
000000r 1               
000000r 1               ; Define if you want the mini-assembler, comment out if not.
000000r 1               ; Should fit in 8K if this is disabled.
000000r 1               MINIASM = 1
000000r 1               
000000r 1               .if .defined(APPLE1)
000000r 1                   .out "Building for Apple 1/Replica 1"
000000r 1               .elseif .defined(APPLE2)
000000r 1                   .out "Building for Apple II"
000000r 1               .elseif .defined(OSI)
000000r 1                   .out "Building for Ohio Scientific Superboard"
000000r 1               .elseif .defined(KIM1)
000000r 1                   .out "Building for KIM-1"
000000r 1               .elseif .defined(SBC)
000000r 1                   .out "Building for SBC"
000000r 1               .else
000000r 1                   .error "Platform not defined"
000000r 1               .endif
000000r 1               
000000r 1               ; Constants
000000r 1                 CR      = $0D                 ; Carriage Return
000000r 1                 LF      = $0A                 ; Line Feed
000000r 1                 SP      = $20                 ; Space
000000r 1                 ESC     = $1B                 ; Escape
000000r 1                 NUL     = $00                 ; Null
000000r 1                 bytesPerLine = $20            ; S record file bytes per line
000000r 1               
000000r 1               ; Hardware addresses
000000r 1               .ifdef APPLE1
000000r 1                 KBD     = $D010               ; PIA.A keyboard input
000000r 1                 KBDCR   = $D011               ; PIA.A keyboard control register
000000r 1                 DSP     = $D012               ; PIA.B display output register
000000r 1               .endif
000000r 1               
000000r 1               ; Page Zero locations
000000r 1               ; Note: Woz Mon uses $24 through $2B and $0200 through $027F.
000000r 1               ; Krusader uses $F8, $F9, $FE, $FF.
000000r 1               ; Mini-monitor uses $0F, $10, $11, $E0-$E8, $F0-$F6.
000000r 1               ; OSI monitor uses $FB, $FC, $FE, $FF.
000000r 1               
000000r 1               .ifdef APPLE2
000000r 1               ; Below were chosen to avoid locations used by Applesoft, Integer
000000r 1               ; BASIC, DOS, or ProDOS.
000000r 1                 T1      = $06                 ; Temp variable 1 (2 bytes)
000000r 1                 SL      = $08                 ; Start address low byte
000000r 1                 SH      = $09                 ; Start address high byte
000000r 1                 EL      = $19                 ; End address low byte
000000r 1                 EH      = $1A                 ; End address high byte
000000r 1                 DL      = $1B                 ; Destination address low byte
000000r 1                 DH      = $1C                 ; Destination address high byte
000000r 1                 ADDR    = $1D                 ; Instruction address, 2 bytes (low/high)
000000r 1                 ADDRS   = $EB                 ; Memory test - 2 bytes - address of memory
000000r 1                 TEST_PATRN = $1F              ; Memory test - 1 byte - current test pattern
000000r 1                 PASSES  = $ED                 ; Memory test - number of passes
000000r 1                 VECTOR  = $EE                 ; Holds adddress of IRQ/BREAK entry point (2 bytes)
000000r 1                 BPA     = $F8                 ; Address of breakpoint (2 bytes * 4 breakpoints)
000000r 1               .else
000000r 1                 T1      = $30                 ; Temp variable 1 (2 bytes)
000000r 1                 SL      = $32                 ; Start address low byte
000000r 1                 SH      = $33                 ; Start address high byte
000000r 1                 EL      = $34                 ; End address low byte
000000r 1                 EH      = $35                 ; End address high byte
000000r 1                 DL      = $36                 ; Destination address low byte
000000r 1                 DH      = $37                 ; Destination address high byte
000000r 1                 ADDR    = $38                 ; Instruction address, 2 bytes (low/high)
000000r 1                 ADDRS   = $3A                 ; Memory test - 2 bytes - address of memory
000000r 1                 TEST_PATRN = $3C              ; Memory test - 1 byte - current test pattern
000000r 1                 PASSES  = $3D                 ; Memory test - number of passes
000000r 1                 VECTOR  = $3E                 ; Holds adddress of IRQ/BREAK entry point (2 bytes)
000000r 1                 BPA     = $40                 ; Address of breakpoint (2 bytes * 4 breakpoints)
000000r 1                 T3      = $48                 ; Temp variable 3 (1 byte)
000000r 1                 T4      = $49                 ; Temp variable 4 (2 bytes)
000000r 1               .endif
000000r 1               
000000r 1               ; Non page zero locations
000000r 1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
000000r 1                 IN      = $0200               ; Buffer from $0200 through $027F
000000r 1               .elseif .defined(OSI)
000000r 1                 IN      = $0300               ; Buffer from $0300 through $037F
000000r 1               .endif
000000r 1               
000000r 1               ; External Routines
000000r 1               .if .defined(APPLE1)
000000r 1                 BASIC   = $E000               ; BASIC
000000r 1                 WOZMON  = $FF00               ; Woz monitor entry point
000000r 1                 MENU    = $9006               ; CFFA1 menu entry point
000000r 1                 ACI     = $C100               ; ACI (Apple Cassette Interface) firmware entry point
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $FFFE             ; Break/interrupt vector (2 bytes)
000000r 1               .elseif .defined(APPLE2)
000000r 1                 BASIC   = $E000               ; BASIC (cold start)
000000r 1               ; BASIC   = $03D0               ; BASIC (cold start with DOS hooks)
000000r 1                 MONITOR = $FF69               ; Apple monitor entry point
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $03F0             ; Break/interrupt vector (2 bytes)
000000r 1                 BEEP    = $FBE4               ; Beep the speaker
000000r 1               .elseif .defined(OSI)
000000r 1                 BASIC   = $BD11               ; BASIC Cold Start
000000r 1                 OSIMON  = $FE00               ; OSI monitor entry point
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $FFFE             ; Break/interrupt vector (2 bytes)
000000r 1               .elseif .defined(KIM1)
000000r 1                 KIMMON  = $1C00               ; KIM monitor entry point
000000r 1                 BRKVECTOR = $17FE             ; Break/interrupt vector (2 bytes)
000000r 1               ; Note: ECHO not defined because KIM-1 always echoes characters back.
000000r 1               .elseif .defined(SBC)
000000r 1                 BASIC   = $DD05               ; BASIC Cold Start
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $FFFE             ; Break/interrupt vector (2 bytes)
000000r 1                 MONCOUT = $FF3B               ; Console out routine
000000r 1                 MONRDKEY = $FF4A              ; Console in routine
000000r 1               .endif
000000r 1               
000000r 1               ; Start address.
000000r 1               .if .defined(APPLE1)
000000r 1               ; $0280 works well for running out of RAM. Use start address of $A000 for Multi I/0 Board EEPROM
000000r 1               ; .org $A000
000000r 1                 .org $0280
000000r 1               .elseif .defined(APPLE2)
000000r 1               ; $0800 should work for DOS 3.3 but conflict with Applesoft.
000000r 1               ; $2000 should work but conflict with ProDOS.
000000r 1               ; $6000 should work with ProDOS, need to first do HIMEM:24575 from Applesoft.
000000r 1               ; .org $0800
000000r 1               ; .org $2000
000000r 1                 .org $6000
000000r 1               .elseif .defined(OSI)
000000r 1                 .org $0380
000000r 1               .elseif .defined(KIM1)
000000r 1                 .org $2000
002000  1               .elseif .defined(SBC)
002000  1               ; .org $2000                    ; For running out of RAM
002000  1                 .org $DF00                    ; For running from ROM
002000  1               .endif
002000  1               
002000  1               ; JMON Entry point
002000  1                 .export JMON
002000  1               JMON:
002000  1               
002000  1               ; Initialization
002000  1  D8                   CLD                     ; clear decimal mode
002001  1  58                   CLI                     ; clear interrupt disable
002002  1  A2 80                LDX #$80                ; initialize stack pointer to $0180
002004  1  9A                   TXS                     ; so we are less likely to clobber BRK vector at $0100 on OSI
002005  1  A9 00                LDA #0
002007  1  8D 25 10             STA OWDELAY             ; initialize write delay to zero
00200A  1  8D 01 10             STA RETOK               ; Don't accept <Return> by default
00200D  1  8D 23 10             STA CHAROK              ; Don't accept character input by default
002010  1  8D 24 10             STA CHARMODE            ; Not currently in char input mode
002013  1  8D 27 10             STA OHIGHASCII          ; Characters should not have high bit set
002016  1  A9 FF                LDA #$FF                ; Default to uppercase only mode
002018  1  8D 26 10             STA OUPPER
00201B  1  A9 01                LDA #1
00201D  1  8D 2A 10             STA XBIT                ; Default 65816 to 8-bit modes
002020  1  8D 29 10             STA MBIT
002023  1  A9 40                LDA #$40                ; Default stack pointer for running program
002025  1  8D 1C 10             STA SAVE_S              ; ($00 is bad choice since BRK vector is at $0100 on OSI)
002028  1  20 6C 24             JSR BPSETUP             ; initialization for breakpoints
00202B  1  20 16 2F             JSR ClearScreen
00202E  1               
00202E  1               ; Display Welcome message
00202E  1  A2 2F                LDX #<WelcomeMessage
002030  1  A0 2F                LDY #>WelcomeMessage
002032  1  20 86 2C             JSR PrintString
002035  1               
002035  1               MainLoop:
002035  1               ; Display prompt
002035  1  20 A8 2C             JSR Imprint
002038  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(SBC)
002038  1                       .asciiz "? "
002038  1               .elseif .defined(OSI)
002038  1                       .asciiz "?"     ; Smaller on OSI due to smaller screen
002038  1               .elseif .defined(KIM1)
002038  1  20 0D                .byte " ",CR
00203A  1  3F 20 00             .asciiz "? " ; The KIM always echos, if we did <ESC> at a prompt
00203D  1                                       ; the extra <CR> will fix things. *** JM
00203D  1               .endif
00203D  1               
00203D  1               ; Get first character of command
00203D  1  20 5B 2B             JSR GetKey
002040  1               
002040  1               ; Call option picker to run appropriate command
002040  1  20 E7 2D             JSR OPICK
002043  1  4C 35 20             JMP MainLoop
002046  1               
002046  1               ; Invalid command
002046  1               Invalid:
002046  1               .ifdef BEEP
002046  1                       JSR BEEP
002046  1               .endif
002046  1  20 A8 2C             JSR Imprint
002049  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
002049  1  49 6E 76 61          .byte "Invalid command. Type '?' for help", CR,LF, 0
00204D  1  6C 69 64 20  
002051  1  63 6F 6D 6D  
00206E  1               .elseif .defined(OSI)
00206E  1                       .byte "Invalid command.", CR,LF, "Type '?' for help", CR,LF, 0
00206E  1               .endif
00206E  1  60                   RTS
00206F  1               
00206F  1               ; Display help
00206F  1               Help:
00206F  1               .ifdef ECHO
00206F  1                       JSR PrintChar           ; echo command
00206F  1               .endif
00206F  1  A2 2F                LDX #<WelcomeMessage
002071  1  A0 2F                LDY #>WelcomeMessage
002073  1  20 86 2C             JSR PrintString
002076  1  A2 4C                LDX #<HelpString
002078  1  A0 2F                LDY #>HelpString
00207A  1  4C 86 2C             JMP PrintString         ; Return via caller
00207D  1               
00207D  1               ; Call CFFA1 flash interface menu
00207D  1               
00207D  1               .ifdef APPLE1
00207D  1               CFFA1:
00207D  1                       JSR CFFA1Present        ; Is the card present?
00207D  1                       BEQ @NoCFFA1
00207D  1                       JMP MENU                ; Jump to CFFA1 menu, will return when done.
00207D  1               
00207D  1               @NoCFFA1:
00207D  1               .ifdef BEEP
00207D  1                       JSR BEEP
00207D  1               .endif
00207D  1               ; Display error that no CFFA1 is present.
00207D  1                       JSR Imprint
00207D  1                       .byte "No CFFA1 card found!", CR,LF, 0
00207D  1                       RTS
00207D  1               .endif
00207D  1               
00207D  1               ; Call ACI (Apple Cassette Interface) firmware
00207D  1               ; First check for the presence of the card by looking for the first two byes of the ROM firmware.
00207D  1               
00207D  1               .ifdef APPLE1
00207D  1               ACIFW:
00207D  1                       JSR ACIPresent
00207D  1                       BEQ NoACI
00207D  1                       JMP ACI                 ; Jump to ACI firmware, unfortunately jumps to Woz Mon when done rather than returning here.
00207D  1               NoACI:
00207D  1               .ifdef BEEP
00207D  1                       JSR BEEP
00207D  1               .endif
00207D  1                                               ; Display error that no ACI is present.
00207D  1                       JSR Imprint
00207D  1                       .byte "No ACI card found!", CR,LF, 0
00207D  1                       RTS
00207D  1               .endif
00207D  1               
00207D  1               ; Go to Woz Monitor, OSI Monitor, or KIM-1 Monitor.
00207D  1               Monitor:
00207D  1               .if .defined(APPLE1)
00207D  1                       JSR WozMonPresent
00207D  1                       BEQ @NoWozMon
00207D  1                       JMP WOZMON
00207D  1               @NoWozMon:
00207D  1               .ifdef BEEP
00207D  1                       JSR BEEP
00207D  1               .endif
00207D  1                                               ; Display error that no Woz Monitor is present.
00207D  1                       JSR Imprint
00207D  1                       .byte "Woz Mon not found!", CR,LF, 0
00207D  1                       RTS
00207D  1               .elseif .defined(APPLE2)
00207D  1                       JMP MONITOR             ; Assume it is always present
00207D  1               .elseif .defined(OSI)
00207D  1                       JMP OSIMON              ; Jump into OSI Monitor
00207D  1               .elseif .defined(KIM1)
00207D  1  4C 00 1C             JMP KIMMON              ; Jump into KIM Monitor
002080  1               .endif
002080  1               
002080  1               ; Go to Mini Assembler
002080  1               .ifdef MINIASM
002080  1               Assemble:
002080  1               .ifdef ECHO
002080  1                       JSR PrintChar           ; echo command
002080  1               .endif
002080  1  20 7E 2C             JSR PrintSpace          ; print a space
002083  1  20 FB 2B             JSR GetAddress          ; Get start address
002086  1  86 38                STX ADDR                ; Save it
002088  1  84 39                STY ADDR+1              ; Save it
00208A  1  20 71 2C             JSR PrintCR             ; Start new line
00208D  1  4C FA 39             JMP AssembleLine        ; Call asssembler
002090  1               .endif
002090  1               
002090  1               ; Go to BASIC
002090  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(OSI) .or .defined(SBC)
002090  1               Basic:
002090  1                       JSR BASICPresent        ; Is BASIC ROM present?
002090  1                       BEQ NoBasic
002090  1                       JMP BASIC               ; Jump to BASIC (no facility to return).
002090  1               NoBasic:
002090  1               .ifdef BEEP
002090  1                       JSR BEEP
002090  1               .endif
002090  1                       JSR Imprint             ; Display error that no BASIC is present.
002090  1                       .byte "BASIC not found!", CR,LF, 0
002090  1                       RTS
002090  1               .endif
002090  1               
002090  1               ; Handle breakpoint
002090  1               ; B ?                    <- list status of all breakpoints
002090  1               ; B <n> <address>        <- set breakpoint number <n> at address <address>
002090  1               ; B <n> 0000             <- remove breakpoint <n>
002090  1               ; <n> is 0 through 3.
002090  1               Breakpoint:
002090  1               .ifdef ECHO
002090  1                       JSR PrintChar           ; echo command
002090  1               .endif
002090  1  20 7E 2C             JSR PrintSpace          ; print space
002093  1  20 5B 2B     IGN:    JSR GetKey              ; get breakpoint number
002096  1  C9 3F                CMP #'?'                ; ? lists breakpoints
002098  1  F0 23                BEQ LISTB
00209A  1  C9 1B                CMP #ESC                ; <Escape> cancels
00209C  1  D0 03                BNE Num
00209E  1  4C 71 2C             JMP PrintCR
0020A1  1               
0020A1  1  C9 30        Num:    CMP #'0'                ; is it 0 through 3?
0020A3  1  30 EE                BMI IGN                 ; Invalid, ignore and try again
0020A5  1  C9 34                CMP #'3'+1
0020A7  1  30 03                BMI VALIDBP
0020A9  1  4C 93 20             JMP IGN
0020AC  1               VALIDBP:
0020AC  1               .ifdef ECHO
0020AC  1                       JSR PrintChar           ; echo number
0020AC  1               .endif
0020AC  1  38                   SEC
0020AD  1  E9 30                SBC #'0'                ; convert to number
0020AF  1  48                   PHA                     ; save it
0020B0  1  20 7E 2C             JSR PrintSpace          ; print space
0020B3  1  20 FB 2B             JSR GetAddress          ; prompt for address
0020B6  1  20 71 2C             JSR PrintCR
0020B9  1  68                   PLA                     ; restore BP number
0020BA  1  4C 0C 25             JMP BPADD
0020BD  1               
0020BD  1  20 71 2C     LISTB:  JSR PrintCR
0020C0  1  4C CC 24             JMP BPLIST
0020C3  1               
0020C3  1               ; Hex to decimal conversion command
0020C3  1               Hex:
0020C3  1               .ifdef ECHO
0020C3  1                       JSR PrintChar           ; echo command
0020C3  1               .endif
0020C3  1  20 7E 2C             JSR PrintSpace          ; print space
0020C6  1  20 FB 2B             JSR GetAddress          ; prompt for address
0020C9  1  8E 02 10             STX BIN                 ; store address
0020CC  1  8C 03 10             STY BINH
0020CF  1  20 7E 2C             JSR PrintSpace
0020D2  1  A9 3D                LDA #'='
0020D4  1  20 EC 2C             JSR PrintChar
0020D7  1  20 7E 2C             JSR PrintSpace
0020DA  1               
0020DA  1               ; If value as 16-bit signed is negative (high bit set) display a minus
0020DA  1               ; signed and convert to 2's complement.
0020DA  1               
0020DA  1  AD 03 10             LDA BINH        ; MS byte
0020DD  1  10 20                BPL @plus       ; not negative
0020DF  1  49 FF                EOR #$FF        ; complement the bits
0020E1  1  8D 03 10             STA BINH
0020E4  1  AD 02 10             LDA BIN         ; LS byte
0020E7  1  49 FF                EOR #$FF        ; complement the bits
0020E9  1  8D 02 10             STA BIN
0020EC  1  18                   CLC
0020ED  1  69 01                ADC #1         ; add one with possible carry
0020EF  1  8D 02 10             STA BIN
0020F2  1  AD 03 10             LDA BINH
0020F5  1  69 00                ADC #0
0020F7  1  8D 03 10             STA BINH
0020FA  1  A9 2D                LDA #'-'
0020FC  1  20 EC 2C             JSR PrintChar
0020FF  1               @plus:
0020FF  1  20 BA 2E             JSR BINBCD16
002102  1  A9 00                LDA #0
002104  1  8D 07 10             STA LZ
002107  1  8D 08 10             STA LAST
00210A  1  AD 06 10             LDA BCD+2
00210D  1  20 18 2C             JSR PrintByteLZ
002110  1  AD 05 10             LDA BCD+1
002113  1  20 18 2C             JSR PrintByteLZ
002116  1  A9 01                LDA #1                  ; no leading zero suppression for last digit
002118  1  8D 08 10             STA LAST
00211B  1  AD 04 10             LDA BCD
00211E  1  20 18 2C             JSR PrintByteLZ
002121  1  4C 71 2C             JMP PrintCR
002124  1               
002124  1               ; Run at address
002124  1               Go:
002124  1               .ifdef ECHO
002124  1                       JSR PrintChar   ; echo command
002124  1               .endif
002124  1  20 7E 2C             JSR PrintSpace  ; print space
002127  1  A9 01                LDA #1
002129  1  8D 01 10             STA RETOK
00212C  1  20 FB 2B             JSR GetAddress  ; prompt for address
00212F  1  B0 06                BCS RetPressed  ; Branch if user pressed <Enter>
002131  1  8E 1E 10             STX SAVE_PC     ; store address
002134  1  8C 1F 10             STY SAVE_PC+1
002137  1               
002137  1               RetPressed:
002137  1  AD 1E 10             LDA SAVE_PC
00213A  1  85 32                STA SL
00213C  1  AD 1F 10             LDA SAVE_PC+1
00213F  1  85 33                STA SL+1
002141  1               
002141  1  A9 00                LDA #0
002143  1  8D 01 10             STA RETOK
002146  1               
002146  1               ; Save our current stack pointer value
002146  1               
002146  1  BA                   TSX
002147  1  8E 22 10             STX THIS_S
00214A  1               
00214A  1               ; Restore saved values of registers
00214A  1  AE 1C 10             LDX SAVE_S      ; Restore stack pointer
00214D  1  9A                   TXS
00214E  1  A9 21                LDA #>(@Return-1) ; Push return address-1 on the stack so an RTS in the called code will return here.
002150  1  48                   PHA
002151  1  A9 64                LDA #<(@Return-1)
002153  1  48                   PHA
002154  1  AD 1D 10             LDA SAVE_P
002157  1  48                   PHA             ; Push P
002158  1  AC 1B 10             LDY SAVE_Y      ; Restore Y
00215B  1  AE 1A 10             LDX SAVE_X      ; Restore X
00215E  1  AD 19 10             LDA SAVE_A      ; Restore A
002161  1  28                   PLP             ; Restore P
002162  1  6C 32 00             JMP (SL)        ; jump to address
002165  1               @Return:
002165  1               
002165  1               ; Restore our original stack pointer so that RTS will work. Hopefully
002165  1               ;  the called program did not corrupt the stack.
002165  1               
002165  1  AE 22 10             LDX THIS_S
002168  1  9A                   TXS
002169  1  60                   RTS
00216A  1               
00216A  1               ; Copy Memory
00216A  1               Copy:
00216A  1               .ifdef ECHO
00216A  1                       JSR PrintChar   ; echo command
00216A  1               .endif
00216A  1  20 7E 2C             JSR PrintSpace  ; print space
00216D  1  20 FB 2B             JSR GetAddress  ; prompt for start address
002170  1  86 32                STX SL          ; store address
002172  1  84 33                STY SH
002174  1  20 7E 2C             JSR PrintSpace  ; print space
002177  1  20 FB 2B             JSR GetAddress  ; prompt for end address
00217A  1  86 34                STX EL          ; store address
00217C  1  84 35                STY EH
00217E  1  20 7E 2C             JSR PrintSpace  ; print space
002181  1  20 FB 2B             JSR GetAddress  ; prompt for destination address
002184  1  86 36                STX DL          ; store address
002186  1  84 37                STY DH
002188  1  20 71 2C             JSR PrintCR
00218B  1  20 B2 2D             JSR RequireStartNotAfterEnd
00218E  1  90 01                BCC @okay1
002190  1  60                   RTS
002191  1               
002191  1               ; Separate copy up and down routines to handle avoid overlapping memory
002191  1               
002191  1               @okay1:
002191  1  A5 33                LDA SH
002193  1  C5 37                CMP DH
002195  1  90 0A                BCC @okayUp             ; copy up
002197  1  D0 37                BNE @okayDown           ; copy down
002199  1  A5 32                LDA SL
00219B  1  C5 36                CMP DL
00219D  1  90 02                BCC @okayUp
00219F  1  B0 2F                BCS @okayDown
0021A1  1               
0021A1  1               @okayUp:
0021A1  1  A0 00                LDY #0
0021A3  1               @copyUp:
0021A3  1  B1 32                LDA (SL),Y              ; copy from source
0021A5  1  91 36                STA (DL),Y              ; to destination
0021A7  1  20 A9 2D             JSR DELAY               ; delay after writing to EEPROM
0021AA  1  A5 33                LDA SH                  ; reached end yet?
0021AC  1  C5 35                CMP EH
0021AE  1  D0 07                BNE @NotDone1
0021B0  1  A5 32                LDA SL
0021B2  1  C5 34                CMP EL
0021B4  1  D0 4C                BNE @NotDone
0021B6  1  60                   RTS                     ; done
0021B7  1               @NotDone1:
0021B7  1  A5 32                LDA SL                  ; increment start address
0021B9  1  18                   CLC
0021BA  1  69 01                ADC #1
0021BC  1  85 32                STA SL
0021BE  1  90 02                BCC @NoCarry1
0021C0  1  E6 33                INC SH
0021C2  1               @NoCarry1:
0021C2  1  A5 36                LDA DL                  ; increment destination address
0021C4  1  18                   CLC
0021C5  1  69 01                ADC #1
0021C7  1  85 36                STA DL
0021C9  1  90 02                BCC @NoCarry2
0021CB  1  E6 37                INC DH
0021CD  1               @NoCarry2:
0021CD  1  4C A3 21             JMP @copyUp
0021D0  1               
0021D0  1               @okayDown:
0021D0  1  A5 34                LDA EL                 ; Calculate length = End - Start
0021D2  1  38                   SEC
0021D3  1  E5 32                SBC SL
0021D5  1  85 30                STA T1
0021D7  1  A5 35                LDA EH
0021D9  1  E5 33                SBC SH
0021DB  1  8D 00 10             STA T2
0021DE  1  A5 36                LDA DL                 ; add length to Destination
0021E0  1  18                   CLC
0021E1  1  65 30                ADC T1
0021E3  1  85 36                STA DL
0021E5  1  A5 37                LDA DH
0021E7  1  6D 00 10             ADC T2
0021EA  1  85 37                STA DH
0021EC  1  A0 00                LDY #0
0021EE  1               @copyDown:
0021EE  1  B1 34                LDA (EL),Y              ; copy from source
0021F0  1  91 36                STA (DL),Y              ; to destination
0021F2  1  20 A9 2D             JSR DELAY               ; delay after writing to EEPROM
0021F5  1  A5 35                LDA EH                  ; reached end yet?
0021F7  1  C5 33                CMP SH
0021F9  1  D0 07                BNE @NotDone
0021FB  1  A5 34                LDA EL
0021FD  1  C5 32                CMP SL
0021FF  1  D0 01                BNE @NotDone
002201  1  60                   RTS                     ; done
002202  1               @NotDone:
002202  1  A5 34                LDA EL                  ; decrement end address
002204  1  38                   SEC
002205  1  E9 01                SBC #1
002207  1  85 34                STA EL
002209  1  B0 02                BCS @NoBorrow1
00220B  1  C6 35                DEC EH
00220D  1               @NoBorrow1:
00220D  1  A5 36                LDA DL                  ; decrement destination address
00220F  1  38                   SEC
002210  1  E9 01                SBC #1
002212  1  85 36                STA DL
002214  1  B0 02                BCS @NoBorrow2
002216  1  C6 37                DEC DH
002218  1               @NoBorrow2:
002218  1  4C EE 21             JMP @copyDown
00221B  1               
00221B  1               ; Search Memory
00221B  1               Search:
00221B  1               .ifdef ECHO
00221B  1                       JSR PrintChar   ; echo command
00221B  1               .endif
00221B  1  20 7E 2C             JSR PrintSpace
00221E  1  20 FB 2B             JSR GetAddress  ; get start address
002221  1  86 32                STX SL
002223  1  84 33                STY SH
002225  1  20 7E 2C             JSR PrintSpace
002228  1  20 FB 2B             JSR GetAddress  ; get end address
00222B  1  86 34                STX EL
00222D  1  84 35                STY EH
00222F  1  20 7E 2C             JSR PrintSpace
002232  1  20 97 2E             JSR GetHexBytes         ; Get search pattern
002235  1  20 71 2C             JSR PrintCR
002238  1  AD 00 02             LDA IN                  ; If length of pattern is zero, return
00223B  1  D0 01                BNE @lenokay
00223D  1  60                   RTS
00223E  1               
00223E  1               @lenokay:
00223E  1  20 B2 2D             JSR RequireStartNotAfterEnd
002241  1  90 01                BCC @StartSearch
002243  1  60                   RTS
002244  1               
002244  1               @StartSearch:
002244  1  A2 00                LDX #0                  ; Index into fill pattern
002246  1               @search:
002246  1  A0 00                LDY #0
002248  1  BD 01 02             LDA IN+1,X              ; Get byte of pattern data
00224B  1  D1 32                CMP (SL),Y              ; compare with memory data
00224D  1  D0 08                BNE @NoMatch
00224F  1  E8                   INX
002250  1  EC 00 02             CPX IN                  ; End of pattern reached?
002253  1  F0 3D                BEQ @Match              ; If so, found match
002255  1  D0 11                BNE @PartialMatch
002257  1               @NoMatch:
002257  1  86 30                STX T1                  ; Subtract X from SL,SH
002259  1  38                   SEC
00225A  1  A5 32                LDA SL
00225C  1  E5 30                SBC T1
00225E  1  85 32                STA SL
002260  1  A5 33                LDA SH
002262  1  E9 00                SBC #0
002264  1  85 33                STA SH
002266  1               @Continue:
002266  1  A2 00                LDX #0                  ; Reset search to end of pattern
002268  1               @PartialMatch:
002268  1  A5 33                LDA SH                  ; reached end yet?
00226A  1  C5 35                CMP EH
00226C  1  D0 16                BNE @NotDone
00226E  1  A5 32                LDA SL
002270  1  C5 34                CMP EL
002272  1  D0 10                BNE @NotDone
002274  1  20 A8 2C             JSR Imprint
002277  1  4E 6F 74 20          .byte "Not found", CR,LF, 0
00227B  1  66 6F 75 6E  
00227F  1  64 0D 0A 00  
002283  1  60                   RTS
002284  1               @NotDone:
002284  1  A5 32                LDA SL                  ; increment address
002286  1  18                   CLC
002287  1  69 01                ADC #1
002289  1  85 32                STA SL
00228B  1  90 02                BCC @NoCarry
00228D  1  E6 33                INC SH
00228F  1               @NoCarry:
00228F  1  4C 46 22             JMP @search
002292  1               
002292  1               @Match:
002292  1  CE 00 02             DEC IN                  ; Calculate start address as SL,SH minus (IN - 1)
002295  1  A5 32                LDA SL
002297  1  38                   SEC
002298  1  ED 00 02             SBC IN
00229B  1  85 32                STA SL
00229D  1  A5 33                LDA SH
00229F  1  E9 00                SBC #0                  ; Includes possible carry
0022A1  1  85 33                STA SH
0022A3  1  EE 00 02             INC IN
0022A6  1  20 A8 2C             JSR Imprint
0022A9  1  46 6F 75 6E          .asciiz "Found at: "
0022AD  1  64 20 61 74  
0022B1  1  3A 20 00     
0022B4  1  A6 32                LDX SL
0022B6  1  A4 33                LDY SH
0022B8  1  20 0D 2C             JSR PrintAddress
0022BB  1  20 71 2C             JSR PrintCR
0022BE  1  20 64 2D             JSR PromptToContinue
0022C1  1  90 A3                BCC @Continue
0022C3  1  60                   RTS             ; done
0022C4  1               
0022C4  1               ; Verify Memory
0022C4  1               Verify:
0022C4  1               .ifdef ECHO
0022C4  1                       JSR PrintChar   ; echo command
0022C4  1               .endif
0022C4  1  20 7E 2C             JSR PrintSpace  ; print space
0022C7  1  20 FB 2B             JSR GetAddress  ; prompt for start address
0022CA  1  86 32                STX SL          ; store address
0022CC  1  84 33                STY SH
0022CE  1  20 7E 2C             JSR PrintSpace  ; print space
0022D1  1  20 FB 2B             JSR GetAddress  ; prompt for end address
0022D4  1  86 34                STX EL          ; store address
0022D6  1  84 35                STY EH
0022D8  1  20 7E 2C             JSR PrintSpace  ; print space
0022DB  1  20 FB 2B             JSR GetAddress  ; prompt for destination address
0022DE  1  86 36                STX DL          ; store address
0022E0  1  84 37                STY DH
0022E2  1  20 71 2C             JSR PrintCR
0022E5  1  20 B2 2D             JSR RequireStartNotAfterEnd
0022E8  1  90 01                BCC @verify
0022EA  1  60                   RTS
0022EB  1               
0022EB  1               @verify:
0022EB  1  A0 00                LDY #0
0022ED  1  B1 32                LDA (SL),Y              ; compare source
0022EF  1  D1 36                CMP (DL),Y              ; to destination
0022F1  1  F0 45                BEQ @match
0022F3  1  20 A8 2C             JSR Imprint             ; report mismatch
0022F6  1  4D 69 73 6D          .asciiz "Mismatch: "
0022FA  1  61 74 63 68  
0022FE  1  3A 20 00     
002301  1  A6 32                LDX SL
002303  1  A4 33                LDY SH
002305  1  20 0D 2C             JSR PrintAddress
002308  1  A9 3A                LDA #':'
00230A  1  20 EC 2C             JSR PrintChar
00230D  1  20 7E 2C             JSR PrintSpace
002310  1  A0 00                LDY #0
002312  1  B1 32                LDA (SL),Y
002314  1  20 D9 2C             JSR PrintByte
002317  1  20 7E 2C             JSR PrintSpace
00231A  1  A6 36                LDX DL
00231C  1  A4 37                LDY DH
00231E  1  20 0D 2C             JSR PrintAddress
002321  1  A9 3A                LDA #':'
002323  1  20 EC 2C             JSR PrintChar
002326  1  20 7E 2C             JSR PrintSpace
002329  1  A0 00                LDY #0
00232B  1  B1 36                LDA (DL),Y
00232D  1  20 D9 2C             JSR PrintByte
002330  1  20 71 2C             JSR PrintCR
002333  1  20 64 2D             JSR PromptToContinue
002336  1  B0 0C                BCS @Done               ; ESC pressed, return
002338  1  A5 33        @match: LDA SH                  ; reached end yet?
00233A  1  C5 35                CMP EH
00233C  1  D0 07                BNE @NotDone
00233E  1  A5 32                LDA SL
002340  1  C5 34                CMP EL
002342  1  D0 01                BNE @NotDone
002344  1               @Done:
002344  1  60                   RTS                     ; done
002345  1               @NotDone:
002345  1  A5 32                LDA SL                  ; increment start address
002347  1  18                   CLC
002348  1  69 01                ADC #1
00234A  1  85 32                STA SL
00234C  1  90 02                BCC @NoCarry1
00234E  1  E6 33                INC SH
002350  1               @NoCarry1:
002350  1  A5 36                LDA DL                  ; increment destination address
002352  1  18                   CLC
002353  1  69 01                ADC #1
002355  1  85 36                STA DL
002357  1  90 02                BCC @NoCarry2
002359  1  E6 37                INC DH
00235B  1               @NoCarry2:
00235B  1  4C EB 22             JMP @verify
00235E  1               
00235E  1               ; Dump Memory
00235E  1               
00235E  1               .if .defined(APPLE1)
00235E  1                       BYTESPERLINE = 8
00235E  1               .elseif .defined(APPLE2)
00235E  1                       BYTESPERLINE = 8
00235E  1               .elseif .defined(OSI)
00235E  1                       BYTESPERLINE = 4
00235E  1               .elseif .defined(KIM1)
00235E  1                       BYTESPERLINE = 16
00235E  1               .elseif .defined(SBC)
00235E  1                       BYTESPERLINE = 16
00235E  1               .endif
00235E  1               
00235E  1               Dump:
00235E  1               ; echo 'D' and space, wait for start address
00235E  1               .ifdef ECHO
00235E  1                       JSR PrintChar
00235E  1               .endif
00235E  1  20 7E 2C             JSR PrintSpace
002361  1  20 FB 2B             JSR GetAddress          ; Get start address
002364  1  86 32                STX SL
002366  1  84 33                STY SH
002368  1  20 71 2C     @line:  JSR PrintCR
00236B  1  A2 00                LDX #0
00236D  1  20 25 2B     @loop:  JSR DumpLine            ; display line of output
002370  1  A5 32                LDA SL                  ; add 8 (4 for OSI) to start address
002372  1  18                   CLC
002373  1  69 10                ADC #BYTESPERLINE
002375  1  85 32                STA SL
002377  1  90 02                BCC @NoCarry
002379  1  E6 33                INC SH
00237B  1               @NoCarry:
00237B  1  E8                   INX
00237C  1  E0 17                CPX #23                 ; display 23 lines
00237E  1  D0 ED                BNE @loop
002380  1  20 64 2D             JSR PromptToContinue
002383  1  90 E3                BCC @line
002385  1  60                   RTS
002386  1               
002386  1               ; Unassemble Memory
002386  1               Unassemble:
002386  1               ; echo 'U' and space, wait for start address
002386  1               .ifdef ECHO
002386  1                       JSR PrintChar
002386  1               .endif
002386  1  20 7E 2C             JSR PrintSpace
002389  1  20 FB 2B             JSR GetAddress          ; Get start address
00238C  1  86 38                STX ADDR
00238E  1  84 39                STY ADDR+1
002390  1  20 71 2C     @line:  JSR PrintCR
002393  1  A9 17                LDA #23
002395  1  48           @loop:  PHA
002396  1  20 04 32             JSR DISASM              ; display line of output
002399  1  68                   PLA
00239A  1  38                   SEC
00239B  1  E9 01                SBC #1
00239D  1  D0 F6                BNE @loop
00239F  1  20 64 2D             JSR PromptToContinue
0023A2  1  90 EC                BCC @line
0023A4  1  60                   RTS
0023A5  1               
0023A5  1               ; Test Memory
0023A5  1               Test:
0023A5  1               .ifdef ECHO
0023A5  1                       JSR PrintChar           ; echo command
0023A5  1               .endif
0023A5  1  20 7E 2C             JSR PrintSpace
0023A8  1  20 FB 2B             JSR GetAddress          ; get start address
0023AB  1  8E 11 10             STX START
0023AE  1  8C 12 10             STY START+1
0023B1  1  20 7E 2C             JSR PrintSpace
0023B4  1  20 FB 2B             JSR GetAddress          ; get end address
0023B7  1  8E 13 10             STX END
0023BA  1  8C 14 10             STY END+1
0023BD  1  20 71 2C             JSR PrintCR
0023C0  1  20 A8 2C             JSR Imprint
0023C3  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0023C3  1  54 65 73 74          .asciiz "Testing memory from $"
0023C7  1  69 6E 67 20  
0023CB  1  6D 65 6D 6F  
0023D9  1               .elseif .defined(OSI)
0023D9  1                       .byte "Testing memory from", CR,LF, "$", 0
0023D9  1               .endif
0023D9  1  AE 11 10             LDX START
0023DC  1  AC 12 10             LDY START+1
0023DF  1  20 0D 2C             JSR PrintAddress
0023E2  1  20 A8 2C             JSR Imprint
0023E5  1  20 74 6F 20          .asciiz " to $"
0023E9  1  24 00        
0023EB  1  AE 13 10             LDX END
0023EE  1  AC 14 10             LDY END+1
0023F1  1  20 0D 2C             JSR PrintAddress
0023F4  1  20 A8 2C             JSR Imprint
0023F7  1  0D 0A 50 72          .byte CR,LF,"Press any key to stop", CR,LF, 0
0023FB  1  65 73 73 20  
0023FF  1  61 6E 79 20  
002411  1  4C AD 43             JMP MEM_TEST
002414  1               
002414  1               ; Memory fill command
002414  1               Fill:
002414  1               .ifdef ECHO
002414  1                       JSR PrintChar           ; echo command
002414  1               .endif
002414  1  20 7E 2C             JSR PrintSpace
002417  1  20 FB 2B             JSR GetAddress          ; get start address
00241A  1  86 32                STX SL
00241C  1  84 33                STY SH
00241E  1  20 7E 2C             JSR PrintSpace
002421  1  20 FB 2B             JSR GetAddress          ; get end address
002424  1  86 34                STX EL
002426  1  84 35                STY EH
002428  1  20 7E 2C             JSR PrintSpace
00242B  1  20 97 2E             JSR GetHexBytes         ; Get fill pattern
00242E  1  20 71 2C             JSR PrintCR
002431  1  AD 00 02             LDA IN                  ; If length of pattern is zero, return
002434  1  D0 01                BNE @lenokay
002436  1  60                   RTS
002437  1               @lenokay:
002437  1  20 B2 2D             JSR RequireStartNotAfterEnd
00243A  1  90 01                BCC @fill
00243C  1  60                   RTS
00243D  1               
00243D  1               @fill:
00243D  1  A0 00                LDY #0
00243F  1  A2 00                LDX #0                  ; Index into fill pattern
002441  1               @dofill:
002441  1  BD 01 02             LDA IN+1,X              ; Get next byte of fill pattern
002444  1  91 32                STA (SL),Y              ; store data (first byte)
002446  1  20 A9 2D             JSR DELAY               ; delay after writing to EEPROM
002449  1  A5 33                LDA SH                  ; reached end yet?
00244B  1  C5 35                CMP EH
00244D  1  D0 07                BNE @NotDone
00244F  1  A5 32                LDA SL
002451  1  C5 34                CMP EL
002453  1  D0 01                BNE @NotDone
002455  1  60                   RTS                     ; done
002456  1               @NotDone:
002456  1  A5 32                LDA SL                  ; increment address
002458  1  18                   CLC
002459  1  69 01                ADC #1
00245B  1  85 32                STA SL
00245D  1  90 02                BCC @NoCarry
00245F  1  E6 33                INC SH
002461  1               @NoCarry:
002461  1  E8                   INX                     ; increment index into pattern
002462  1  EC 00 02             CPX IN                  ; end of pattern reached?
002465  1  D0 DA                BNE @dofill             ; if not, go back
002467  1  A2 00                LDX #0                  ; Otherwise go back to start of pattern
002469  1  4C 41 24             JMP @dofill
00246C  1               
00246C  1               ; Do setup so we can support breakpoints
00246C  1               BPSETUP:
00246C  1               .if .defined(APPLE1) .or .defined(OSI) .or .defined(SBC)
00246C  1               
00246C  1               ; On the Apple 1 and OSI platforms the BRK vector is in RAM and we
00246C  1               ; write a JMP instruction to our handler there.
00246C  1               
00246C  1                       LDA BRKVECTOR           ; get address of BRK vector
00246C  1                       STA VECTOR              ; and save in page zero
00246C  1                       LDA BRKVECTOR+1
00246C  1                       STA VECTOR+1
00246C  1                       LDA #$4C                ; JMP instruction
00246C  1                       LDY #0
00246C  1                       STA (VECTOR),Y          ; store at IRQ/BRK vector
00246C  1                       CMP (VECTOR),Y          ; if we don't read back what we wrote
00246C  1                       BNE VNOTINRAM           ; then vector address is not writable (user may have put it in ROM)
00246C  1                       LDA #<BRKHANDLER        ; handler address low byte
00246C  1                       INY
00246C  1                       STA (VECTOR),Y          ; write it after JMP
00246C  1                       LDA #>BRKHANDLER        ; handler address high byte
00246C  1                       INY
00246C  1                       STA (VECTOR),Y          ; write it after JMP
00246C  1               
00246C  1               .elseif .defined(KIM1) .or .defined(APPLE2) .or .defined(SBC)
00246C  1               
00246C  1               ; On the KIM-1 and Apple II, the BRK vector is in ROM but the handler
00246C  1               ; goes through a vector in RAM.
00246C  1               
00246C  1  A9 6E                LDA #<BRKHANDLER        ; handler address low byte
00246E  1  8D FE 17             STA BRKVECTOR
002471  1  CD FE 17             CMP BRKVECTOR           ; if we don't read back what we wrote
002474  1  D0 1C                BNE VNOTINRAM           ; ...then vector address is not writable (shouldn't happen, but...)
002476  1  A9 25                LDA #>BRKHANDLER        ; handler address high byte
002478  1  8D FF 17             STA BRKVECTOR+1
00247B  1               .endif
00247B  1  A9 00                LDA #0                  ; Mark all breakpoints as cleared (BPA and BPD set to 0)
00247D  1  A2 00                LDX #0
00247F  1  A0 00                LDY #0
002481  1               CLEAR:
002481  1  99 40 00             STA BPA,Y
002484  1  99 41 00             STA BPA+1,Y
002487  1  9D 15 10             STA BPD,X
00248A  1  C8                   INY
00248B  1  C8                   INY
00248C  1  E8                   INX
00248D  1  E0 04                CPX #4
00248F  1  D0 F0                BNE CLEAR
002491  1  60                   RTS
002492  1               VNOTINRAM:
002492  1  20 A8 2C             JSR Imprint
002495  1  42 52 4B 20          .byte "BRK vector not in RAM!", CR,LF, 0
002499  1  76 65 63 74  
00249D  1  6F 72 20 6E  
0024AE  1  60                   RTS
0024AF  1               BNOTINRAM:
0024AF  1  20 A8 2C             JSR Imprint
0024B2  1  42 72 65 61          .byte "Breakpoint not in RAM!", CR,LF, 0
0024B6  1  6B 70 6F 69  
0024BA  1  6E 74 20 6E  
0024CB  1  60                   RTS
0024CC  1               
0024CC  1               ; List breakpoints, e.g.
0024CC  1               ; "BREAKPOINT n AT $nnnn"
0024CC  1               BPLIST:
0024CC  1  A2 00                LDX #0
0024CE  1               LIST:
0024CE  1  8A                   TXA
0024CF  1  48                   PHA
0024D0  1  A2 9F                LDX #<KnownBPString1
0024D2  1  A0 31                LDY #>KnownBPString1
0024D4  1  20 86 2C             JSR PrintString
0024D7  1               
0024D7  1  68                   PLA
0024D8  1  48                   PHA
0024D9  1  4A                   LSR A                   ; divide by 2
0024DA  1  20 E2 2C             JSR PRHEX
0024DD  1  A2 AB                LDX #<KnownBPString2
0024DF  1  A0 31                LDY #>KnownBPString2
0024E1  1  20 86 2C             JSR PrintString
0024E4  1  68                   PLA
0024E5  1  48                   PHA
0024E6  1  AA                   TAX
0024E7  1  B5 40                LDA BPA,X
0024E9  1  E8                   INX
0024EA  1  B4 40                LDY BPA,X
0024EC  1  AA                   TAX
0024ED  1  20 0D 2C             JSR PrintAddress
0024F0  1  20 71 2C             JSR PrintCR
0024F3  1  68                   PLA
0024F4  1  AA                   TAX
0024F5  1  E8                   INX
0024F6  1  E8                   INX
0024F7  1  E0 08                CPX #8
0024F9  1  D0 D3                BNE LIST
0024FB  1  60                   RTS
0024FC  1               
0024FC  1               ; Return 1 in A if breakpoint number A exists, otherwise return 0.
0024FC  1               BPEXISTS:
0024FC  1  0A                   ASL A                   ; need to multiply by 2 to get offset in array
0024FD  1  AA                   TAX
0024FE  1  B5 40                LDA BPA,X
002500  1  D0 07                BNE EXISTS
002502  1  B5 41                LDA BPA+1,X
002504  1  D0 03                BNE EXISTS
002506  1  A9 00                LDA #0
002508  1  60                   RTS
002509  1               EXISTS:
002509  1  A9 01                LDA #1
00250B  1  60                   RTS
00250C  1               
00250C  1               ; Add breakpoint number A at address in X,Y
00250C  1               BPADD:
00250C  1  86 30                STX T1
00250E  1  8C 00 10             STY T2
002511  1  48                   PHA
002512  1  20 FC 24             JSR BPEXISTS            ; if breakpoint already exists, remove it first
002515  1  F0 05                BEQ ADDIT
002517  1  68                   PLA
002518  1  48                   PHA
002519  1  20 3A 25             JSR BPREMOVE            ; remove it
00251C  1               ADDIT:
00251C  1  68                   PLA
00251D  1  A8                   TAY
00251E  1  0A                   ASL A                   ; need to multiply by 2 to get offset in array
00251F  1  AA                   TAX
002520  1  A5 30                LDA T1
002522  1  95 40                STA BPA,X               ; save address of breakpoint
002524  1  AD 00 10             LDA T2
002527  1  95 41                STA BPA+1,X
002529  1  A1 40                LDA (BPA,X)             ; get instruction at breakpoint address
00252B  1  99 15 10             STA BPD,Y               ; save it
00252E  1  A9 00                LDA #0                  ; BRK instruction
002530  1  81 40                STA (BPA,X)             ; write breakpoint over code
002532  1  C1 40                CMP (BPA,X)             ; If we don't read back what we wrote
002534  1  F0 03                BEQ InRam
002536  1  4C AF 24             JMP BNOTINRAM           ; then address is not writable (user may have put it in ROM)
002539  1  60           InRam:  RTS
00253A  1               
00253A  1               ; Remove breakpoint number A
00253A  1               BPREMOVE:
00253A  1  48                   PHA
00253B  1  20 FC 24             JSR BPEXISTS
00253E  1  D0 1B                BNE OK
002540  1  20 A8 2C             JSR Imprint
002543  1  42 72 65 61          .byte "Breakpoint not set!", CR,LF, 0
002547  1  6B 70 6F 69  
00254B  1  6E 74 20 6E  
002559  1  68                   PLA
00255A  1  60                   RTS
00255B  1               OK:
00255B  1  68                   PLA
00255C  1  A8                   TAY
00255D  1  0A                   ASL A                   ; multiply by 2 because table entries are two bytes
00255E  1  AA                   TAX
00255F  1  B9 15 10             LDA BPD,Y               ; get original instruction
002562  1  81 40                STA (BPA,X)             ; restore instruction at breakpoint address
002564  1  A9 00                LDA #0                  ; set BPA to address$0000 to clear breakpoint
002566  1  95 40                STA BPA,X
002568  1  95 41                STA BPA+1,X
00256A  1  99 15 10             STA BPD,Y               ; and clear BPD
00256D  1  60                   RTS
00256E  1               
00256E  1               ; Breakpoint handler
00256E  1               BRKHANDLER:
00256E  1               .if .defined(APPLE2)
00256E  1               
00256E  1               ; On the Apple II platform the ROM interrupt handler has already
00256E  1               ; determined that a BRK intruction was executed and has saved the
00256E  1               ; register values in RAM.
00256E  1               
00256E  1                       SEC                     ; subtract 2 from return address to get actual instruction address
00256E  1                       LDA $3A
00256E  1                       SBC #2
00256E  1                       STA SAVE_PC             ; PC low
00256E  1                       LDA $3B
00256E  1                       SBC #0
00256E  1                       STA SAVE_PC+1           ; PC high
00256E  1                       LDA $45
00256E  1                       STA SAVE_A              ; A
00256E  1                       LDA $46
00256E  1                       STA SAVE_X              ; X
00256E  1                       LDA $47
00256E  1                       STA SAVE_Y              ; Y
00256E  1                       LDA $48
00256E  1                       STA SAVE_P              ; P
00256E  1                       JMP CHECKADDR
00256E  1               
00256E  1               .else
00256E  1               
00256E  1               ; On other platforms, save registers. Then look at processor status to
00256E  1               ; see if it was BRK or an IRQ. If IRQ, display a message and return
00256E  1               ; from interrupt. Otherwise handle as a BRK statement.
00256E  1               
00256E  1  8D 19 10             STA SAVE_A              ; save registers
002571  1  8E 1A 10             STX SAVE_X
002574  1  8C 1B 10             STY SAVE_Y
002577  1  68                   PLA                     ; P is on stack
002578  1  8D 1D 10             STA SAVE_P
00257B  1  48                   PHA                     ; put P back on stack
00257C  1  A9 10                LDA  #%00010000         ; position of B bit
00257E  1  2C 1D 10             BIT  SAVE_P             ; is B bit set, indicating BRK and not IRQ?
002581  1  D0 1E                BNE  BREAK              ; If so, got to break handler
002583  1  20 71 2C             JSR  PrintCR            ; Otherwise print message that we got an interrupt
002586  1  20 A8 2C             JSR  Imprint
002589  1  49 6E 74 65          .byte "Interrupt ?", CR,LF, 0
00258D  1  72 72 75 70  
002591  1  74 20 3F 0D  
002597  1  AC 1B 10             LDY  SAVE_Y
00259A  1  AE 1A 10             LDX  SAVE_X             ; Restore registers and return from interrupt
00259D  1  AD 19 10             LDA  SAVE_A
0025A0  1  40                   RTI
0025A1  1               BREAK:
0025A1  1  BA                   TSX                     ; get stack pointer
0025A2  1  38                   SEC                     ; subtract 2 from return address to get actual instruction address
0025A3  1  BD 02 01             LDA $0102,X
0025A6  1  E9 02                SBC #2
0025A8  1  9D 02 01             STA $0102,X             ; put original instruction address back on stack
0025AB  1  8D 1E 10             STA SAVE_PC             ; also save it for later reference
0025AE  1  BD 03 01             LDA $0103,X
0025B1  1  E9 00                SBC #0
0025B3  1  9D 03 01             STA $0103,X
0025B6  1  8D 1F 10             STA SAVE_PC+1
0025B9  1               .endif
0025B9  1  A2 00                LDX #0
0025BB  1               CHECKADDR:
0025BB  1  AD 1E 10             LDA SAVE_PC             ; see if PC matches address of a breakpoint
0025BE  1  D5 40                CMP BPA,X
0025C0  1  D0 07                BNE TRYNEXT
0025C2  1  AD 1F 10             LDA SAVE_PC+1
0025C5  1  D5 41                CMP BPA+1,X
0025C7  1  F0 2A                BEQ MATCHES
0025C9  1               TRYNEXT:
0025C9  1  E8                   INX
0025CA  1  E8                   INX
0025CB  1  E0 08                CPX #8                  ; last breakpoint reached
0025CD  1  D0 EC                BNE CHECKADDR
0025CF  1               UNKNOWN:
0025CF  1  20 71 2C             JSR PrintCR
0025D2  1  20 A8 2C             JSR Imprint
0025D5  1  42 72 65 61          .asciiz "Breakpoint ? at $"
0025D9  1  6B 70 6F 69  
0025DD  1  6E 74 20 3F  
0025E7  1  AE 1E 10             LDX SAVE_PC
0025EA  1  AC 1F 10             LDY SAVE_PC+1
0025ED  1  20 0D 2C             JSR PrintAddress
0025F0  1  4C 1A 26             JMP RESTORE
0025F3  1               MATCHES:
0025F3  1  8A                   TXA
0025F4  1  48                   PHA
0025F5  1  20 71 2C             JSR PrintCR
0025F8  1  A2 9F                LDX #<KnownBPString1
0025FA  1  A0 31                LDY #>KnownBPString1
0025FC  1  20 86 2C             JSR PrintString
0025FF  1  68                   PLA                      ; get BP # x2
002600  1  48                   PHA                      ; save it again
002601  1  4A                   LSR A                    ; divide by 2 to get BP number
002602  1  20 E2 2C             JSR PRHEX
002605  1  A2 AB                LDX #<KnownBPString2
002607  1  A0 31                LDY #>KnownBPString2
002609  1  20 86 2C             JSR PrintString
00260C  1  AE 1E 10             LDX SAVE_PC
00260F  1  AC 1F 10             LDY SAVE_PC+1
002612  1  20 0D 2C             JSR PrintAddress
002615  1  68                   PLA
002616  1  4A                   LSR A
002617  1  20 3A 25             JSR BPREMOVE
00261A  1               RESTORE:
00261A  1  20 71 2C             JSR PrintCR
00261D  1  20 6B 27             JSR PrintRegisters      ; Print current values
002620  1  AD 1E 10             LDA SAVE_PC             ; Disassemble current instruction
002623  1  85 38                STA ADDR
002625  1  AD 1F 10             LDA SAVE_PC+1
002628  1  85 39                STA ADDR+1
00262A  1  20 04 32             JSR DISASM
00262D  1  4C 35 20             JMP MainLoop           ; Continue with JMon main command loop
002630  1               
002630  1               ; Memory write command.
002630  1               ; Format:
002630  1               ; : <addr> <bb> <bb> ... <Enter> or <Esc> (up to 255 chars)
002630  1               ; eg:
002630  1               ; : A000 12 34 56 78
002630  1               Memory:
002630  1               .ifdef ECHO
002630  1                       JSR PrintChar           ; Echo command
002630  1               .endif
002630  1  20 71 2C             JSR PrintCR
002633  1  20 FB 2B             JSR GetAddress          ; Get start address (ESC will exit)
002636  1  86 32                STX SL
002638  1  84 33                STY SH
00263A  1  A9 01                LDA #1
00263C  1  8D 23 10             STA CHAROK              ; Set flag to accept character input
00263F  1               writeLoop:
00263F  1  20 7E 2C             JSR PrintSpace          ; Echo space
002642  1  20 C2 2B             JSR GetByte             ; Get data byte (ESC will exit)
002645  1  A0 00                LDY #0
002647  1  91 32                STA (SL),Y              ; write data to address
002649  1  D1 32                CMP (SL),Y
00264B  1  F0 15                BEQ Okay
00264D  1  20 A8 2C             JSR Imprint             ; Display message that same data not written back
002650  1  20 52 65 61          .byte " Read: ", 0
002654  1  64 3A 20 00  
002658  1  A0 00                LDY #0
00265A  1  B1 32                LDA (SL),Y
00265C  1  20 D9 2C             JSR PrintByte
00265F  1  20 7E 2C             JSR PrintSpace
002662  1               Okay:
002662  1  18                   CLC                     ; increment address
002663  1  A5 32                LDA SL
002665  1  69 01                ADC #1
002667  1  85 32                STA SL
002669  1  90 02                BCC nocarry
00266B  1  E6 33                INC SH
00266D  1               nocarry:
00266D  1  A9 0F                LDA #BYTESPERLINE-1     ; Is address a multiple of 8/4?
00266F  1  24 32                BIT SL
002671  1  D0 CC                BNE writeLoop           ; If not, keep getting data
002673  1  20 71 2C             JSR PrintCR             ; Otherwise start new line
002676  1  A6 32                LDX SL
002678  1  A4 33                LDY SH
00267A  1  20 0D 2C             JSR PrintAddress        ; Display current address
00267D  1  4C 3F 26             JMP writeLoop           ; Input more data
002680  1               
002680  1               ; Register change command.
002680  1               ; Displays and sets values of registers
002680  1               ; Values are set when JMON is entered.
002680  1               ; Uses values with Go command.
002680  1               ;
002680  1               ; R A-D2 X-00 Y-04 S-01FE P-FF NVBDIZC
002680  1               ; FF02   A0 7F       LDY   #$7F
002680  1               ;   A-00 X-00 Y-00 S-0180 P-01
002680  1               ; PC-FF02
002680  1               ;
002680  1               ; Displays saved value of registers
002680  1               ; Prompts for new value for each register.
002680  1               ; <Esc> cancels at any time.
002680  1               
002680  1               Registers:
002680  1               .ifdef ECHO
002680  1                       JSR PrintChar           ; Echo command
002680  1               .endif
002680  1  20 71 2C             JSR PrintCR
002683  1               
002683  1  20 6B 27             JSR PrintRegisters      ; Print current values
002686  1               
002686  1  AD 1E 10             LDA SAVE_PC             ; Disassemble current instruction
002689  1  85 38                STA ADDR
00268B  1  AD 1F 10             LDA SAVE_PC+1
00268E  1  85 39                STA ADDR+1
002690  1  20 04 32             JSR DISASM
002693  1               
002693  1  A9 01                LDA #1
002695  1  8D 01 10             STA RETOK
002698  1  A9 41                LDA #'A'                ; Now print and prompt for new values
00269A  1  20 EC 2C             JSR PrintChar
00269D  1  A9 2D                LDA #'-'
00269F  1  20 EC 2C             JSR PrintChar
0026A2  1  20 C2 2B             JSR GetByte
0026A5  1  B0 06                BCS RetPressed1
0026A7  1  8D 19 10             STA SAVE_A
0026AA  1  4C B3 26             JMP EnterX
0026AD  1               RetPressed1:
0026AD  1  AD 19 10             LDA SAVE_A
0026B0  1  20 D9 2C             JSR PrintByte
0026B3  1               EnterX:
0026B3  1  20 7E 2C             JSR PrintSpace
0026B6  1  A9 58                LDA #'X'
0026B8  1  20 EC 2C             JSR PrintChar
0026BB  1  A9 2D                LDA #'-'
0026BD  1  20 EC 2C             JSR PrintChar
0026C0  1  20 C2 2B             JSR GetByte
0026C3  1  B0 06                BCS RetPressed2
0026C5  1  8D 1A 10             STA SAVE_X
0026C8  1  4C D1 26             JMP EnterY
0026CB  1               RetPressed2:
0026CB  1  AD 1A 10             LDA SAVE_X
0026CE  1  20 D9 2C             JSR PrintByte
0026D1  1               EnterY:
0026D1  1  20 7E 2C             JSR PrintSpace
0026D4  1  A9 59                LDA #'Y'
0026D6  1  20 EC 2C             JSR PrintChar
0026D9  1  A9 2D                LDA #'-'
0026DB  1  20 EC 2C             JSR PrintChar
0026DE  1  20 C2 2B             JSR GetByte
0026E1  1  B0 06                BCS RetPressed3
0026E3  1  8D 1B 10             STA SAVE_Y
0026E6  1  4C EF 26             JMP EnterS
0026E9  1               RetPressed3:
0026E9  1  AD 1B 10             LDA SAVE_Y
0026EC  1  20 D9 2C             JSR PrintByte
0026EF  1               EnterS:
0026EF  1  8D 1B 10             STA SAVE_Y
0026F2  1  20 7E 2C             JSR PrintSpace
0026F5  1  A9 53                LDA #'S'
0026F7  1  20 EC 2C             JSR PrintChar
0026FA  1  A9 2D                LDA #'-'
0026FC  1  20 EC 2C             JSR PrintChar
0026FF  1  A9 01                LDA #$01
002701  1  20 D9 2C             JSR PrintByte
002704  1  20 C2 2B             JSR GetByte
002707  1  B0 06                BCS RetPressed4
002709  1  8D 1C 10             STA SAVE_S
00270C  1  4C 15 27             JMP EnterP
00270F  1               RetPressed4:
00270F  1  AD 1C 10             LDA SAVE_S
002712  1  20 D9 2C             JSR PrintByte
002715  1               EnterP:
002715  1  20 7E 2C             JSR PrintSpace
002718  1  A9 50                LDA #'P'
00271A  1  20 EC 2C             JSR PrintChar
00271D  1  A9 2D                LDA #'-'
00271F  1  20 EC 2C             JSR PrintChar
002722  1  20 C2 2B             JSR GetByte
002725  1  B0 06                BCS RetPressed5
002727  1  8D 1D 10             STA SAVE_P
00272A  1  4C 33 27             JMP PrintP
00272D  1               RetPressed5:
00272D  1  AD 1D 10             LDA SAVE_P
002730  1  20 D9 2C             JSR PrintByte
002733  1               PrintP:
002733  1  20 7E 2C             JSR PrintSpace
002736  1  20 EE 2E             JSR OUTP
002739  1  20 71 2C             JSR PrintCR
00273C  1  A9 50                LDA #'P'
00273E  1  20 EC 2C             JSR PrintChar
002741  1  A9 43                LDA #'C'
002743  1  20 EC 2C             JSR PrintChar
002746  1  A9 2D                LDA #'-'
002748  1  20 EC 2C             JSR PrintChar
00274B  1  20 FB 2B             JSR GetAddress
00274E  1  B0 09                BCS RetPressed6
002750  1  8E 1E 10             STX SAVE_PC
002753  1  8C 1F 10             STY SAVE_PC+1
002756  1  4C 62 27             JMP Eol
002759  1               RetPressed6:
002759  1  AE 1E 10             LDX SAVE_PC
00275C  1  AC 1F 10             LDY SAVE_PC+1
00275F  1  20 0D 2C             JSR PrintAddress
002762  1               Eol:
002762  1  20 71 2C             JSR PrintCR
002765  1  A9 00                LDA #0
002767  1  8D 01 10             STA RETOK
00276A  1  60                   RTS
00276B  1               
00276B  1               ; Print saved values of registers
00276B  1               PrintRegisters:
00276B  1  A9 41                LDA #'A'
00276D  1  20 EC 2C             JSR PrintChar
002770  1  A9 2D                LDA #'-'
002772  1  20 EC 2C             JSR PrintChar
002775  1  AD 19 10             LDA SAVE_A
002778  1  20 D9 2C             JSR PrintByte
00277B  1  20 7E 2C             JSR PrintSpace
00277E  1  A9 58                LDA #'X'
002780  1  20 EC 2C             JSR PrintChar
002783  1  A9 2D                LDA #'-'
002785  1  20 EC 2C             JSR PrintChar
002788  1  AD 1A 10             LDA SAVE_X
00278B  1  20 D9 2C             JSR PrintByte
00278E  1  20 7E 2C             JSR PrintSpace
002791  1  A9 59                LDA #'Y'
002793  1  20 EC 2C             JSR PrintChar
002796  1  A9 2D                LDA #'-'
002798  1  20 EC 2C             JSR PrintChar
00279B  1  AD 1B 10             LDA SAVE_Y
00279E  1  20 D9 2C             JSR PrintByte
0027A1  1  20 7E 2C             JSR PrintSpace
0027A4  1  A9 53                LDA #'S'
0027A6  1  20 EC 2C             JSR PrintChar
0027A9  1  A9 2D                LDA #'-'
0027AB  1  20 EC 2C             JSR PrintChar
0027AE  1  A9 01                LDA #01
0027B0  1  20 D9 2C             JSR PrintByte
0027B3  1  AD 1C 10             LDA SAVE_S
0027B6  1  20 D9 2C             JSR PrintByte
0027B9  1  20 7E 2C             JSR PrintSpace
0027BC  1  A9 50                LDA #'P'
0027BE  1  20 EC 2C             JSR PrintChar
0027C1  1  A9 2D                LDA #'-'
0027C3  1  20 EC 2C             JSR PrintChar
0027C6  1  AD 1D 10             LDA SAVE_P
0027C9  1  20 D9 2C             JSR PrintByte
0027CC  1  20 7E 2C             JSR PrintSpace
0027CF  1  20 EE 2E             JSR OUTP
0027D2  1  4C 71 2C             JMP PrintCR
0027D5  1               
0027D5  1               ; Prompt user to change program options
0027D5  1               Options:
0027D5  1  20 A8 2C             JSR Imprint
0027D8  1  4F 70 74 69          .byte "Options", CR,LF, 0
0027DC  1  6F 6E 73 0D  
0027E0  1  0A 00        
0027E2  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(SBC)
0027E2  1                       JSR Imprint
0027E2  1                      .byte "All uppercase output (Y/N)?", 0
0027E2  1               @Retry:
0027E2  1                       JSR GetKey
0027E2  1                       JSR ToUpper
0027E2  1                       CMP #ESC
0027E2  1                       BEQ @Return
0027E2  1                       CMP #'Y'
0027E2  1                       BEQ @Yes
0027E2  1                       CMP #'N'
0027E2  1                       BEQ @No
0027E2  1                       BNE @Retry
0027E2  1               @Return:
0027E2  1                       JMP PrintCR             ; new line
0027E2  1               
0027E2  1               @Yes:
0027E2  1               .ifdef ECHO
0027E2  1                       JSR PrintChar           ; echo command
0027E2  1               .endif
0027E2  1                       LDA #$FF
0027E2  1                       STA OUPPER
0027E2  1                       BNE @Next
0027E2  1               @No:
0027E2  1               .ifdef ECHO
0027E2  1                       JSR PrintChar           ; echo command
0027E2  1               .endif
0027E2  1                       LDA #0
0027E2  1                       STA OUPPER
0027E2  1               @Next:
0027E2  1                       JSR PrintCR             ; new line
0027E2  1               .endif
0027E2  1               
0027E2  1               ; Add a delay after all writes to accomodate slow EEPROMs.
0027E2  1               ; Applies to COPY, FILL, and TEST commands.
0027E2  1               ; Depending on the manufacturer, anywhere from 0.5ms to 10ms may be needed.
0027E2  1               ; Value of $20 works well for me (approx 1.5ms delay with 2MHz clock).
0027E2  1               ; See routine WAIT for details.
0027E2  1  20 A8 2C             JSR Imprint
0027E5  1  57 72 69 74         .byte "Write delay (00-FF)?", 0
0027E9  1  65 20 64 65  
0027ED  1  6C 61 79 20  
0027FA  1  20 C2 2B             JSR GetByte
0027FD  1  8D 25 10             STA OWDELAY
002800  1  20 71 2C             JSR PrintCR             ; new line
002803  1               
002803  1               .if .defined(APPLE1) .or .defined(APPLE2)
002803  1                       JSR Imprint
002803  1                      .byte "Set high bit in characters (Y/N)?", 0
002803  1               @Retry1:
002803  1                       JSR GetKey
002803  1                       JSR ToUpper
002803  1                       CMP #ESC
002803  1                       BEQ @Return
002803  1                       CMP #'Y'
002803  1                       BEQ @Yes1
002803  1                       CMP #'N'
002803  1                       BEQ @No1
002803  1                       BNE @Retry1
002803  1               @Yes1:
002803  1               .ifdef ECHO
002803  1                       JSR PrintChar           ; echo command
002803  1               .endif
002803  1                       LDA #$FF
002803  1                       STA OHIGHASCII
002803  1                       BNE @Next1
002803  1               @No1:
002803  1               .ifdef ECHO
002803  1                       JSR PrintChar           ; echo command
002803  1               .endif
002803  1                       LDA #0
002803  1                       STA OHIGHASCII
002803  1               @Next1:
002803  1                       JSR PrintCR             ; new line
002803  1               .endif
002803  1  20 A8 2C             JSR Imprint
002806  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
002806  1  43 50 55 20          .byte "CPU type (1-6502 2-65C02 3-65816)?", 0
00280A  1  74 79 70 65  
00280E  1  20 28 31 2D  
002829  1               .elseif .defined(OSI)
002829  1                       .byte "CPU type 1-6502 2-65C02", CR,LF, "3-65816?", 0
002829  1               .endif
002829  1               @Retry2:
002829  1  20 5B 2B             JSR GetKey
00282C  1  C9 1B                CMP #ESC
00282E  1  D0 03                BNE @NotEsc
002830  1  4C 46 28             JMP @Return
002833  1               @NotEsc:
002833  1  C9 31                CMP #'1'
002835  1  F0 0A                BEQ @Okay
002837  1  C9 32                CMP #'2'
002839  1  F0 06                BEQ @Okay
00283B  1  C9 33                CMP #'3'
00283D  1  F0 02                BEQ @Okay
00283F  1  D0 E8                BNE @Retry2
002841  1               @Okay:
002841  1               .ifdef ECHO
002841  1                       JSR PrintChar           ; echo command
002841  1               .endif
002841  1  29 03                AND #%00000011          ; Convert ASCII number to binary number
002843  1  8D 28 10             STA OCPU
002846  1               .if .defined(OSI) .or .defined(KIM1)
002846  1               @Return:
002846  1               .endif
002846  1  4C 71 2C             JMP PrintCR             ; new line
002849  1               
002849  1               ; Math command. Add or substract two 16-bit hex numbers.
002849  1               ; Format: = <ADDRESS> +/- <ADDRESS>
002849  1               ; e.g.
002849  1               ; = 1234 + 0077 = 12AB
002849  1               ; = FF00 - 0002 = FEFE
002849  1               Math:
002849  1               .ifdef ECHO
002849  1                       JSR PrintChar           ; Echo command
002849  1               .endif
002849  1  20 7E 2C             JSR PrintSpace
00284C  1  20 FB 2B             JSR GetAddress          ; Get first number
00284F  1  86 32                STX SL
002851  1  84 33                STY SH
002853  1  20 7E 2C             JSR PrintSpace
002856  1               @PlusOrMinus:
002856  1  20 5B 2B             JSR GetKey
002859  1  C9 2B                CMP #'+'                ; Is it plus?
00285B  1  F0 07                BEQ @Okay
00285D  1  C9 2D                CMP #'-'                ; Is it minus?
00285F  1  F0 03                BEQ @Okay
002861  1  4C 56 28             JMP @PlusOrMinus        ; If not, try again
002864  1               @Okay:
002864  1  8D 0A 10             STA OP
002867  1               .ifdef ECHO
002867  1                       JSR PrintChar
002867  1               .endif
002867  1  20 7E 2C             JSR PrintSpace
00286A  1  20 FB 2B             JSR GetAddress          ; Get second number
00286D  1  86 34                STX EL
00286F  1  84 35                STY EH
002871  1  20 7E 2C             JSR PrintSpace
002874  1  A9 3D                LDA #'='
002876  1  20 EC 2C             JSR PrintChar
002879  1  20 7E 2C             JSR PrintSpace
00287C  1  AD 0A 10             LDA OP
00287F  1  C9 2D                CMP #'-'
002881  1  F0 10                BEQ @Sub                ; Branch if operation is subtract
002883  1               
002883  1  18                   CLC                     ; Calculate DL,DH = SL,SH + EL,EH
002884  1  A5 32                LDA SL
002886  1  65 34                ADC EL
002888  1  85 36                STA DL
00288A  1  A5 33                LDA SH
00288C  1  65 35                ADC EH
00288E  1  85 37                STA DH
002890  1  4C A0 28             JMP @PrintResult
002893  1               
002893  1               @Sub:
002893  1  38                   SEC                     ; Calculate DL,DH = SL,SH - EL,EH
002894  1  A5 32                LDA SL
002896  1  E5 34                SBC EL
002898  1  85 36                STA DL
00289A  1  A5 33                LDA SH
00289C  1  E5 35                SBC EH
00289E  1  85 37                STA DH
0028A0  1               
0028A0  1               @PrintResult:
0028A0  1  A6 36                LDX DL                  ; Print the result
0028A2  1  A4 37                LDY DH
0028A4  1  20 0D 2C             JSR PrintAddress
0028A7  1  4C 71 2C             JMP PrintCR
0028AA  1               
0028AA  1               ; Checksum command. Sum memory bytes in a range and show 16-bit result.
0028AA  1               ; Format: K <start> <end>
0028AA  1               ; e.g.
0028AA  1               ; K C100 C1FF 1234
0028AA  1               Checksum:
0028AA  1               .ifdef ECHO
0028AA  1                       JSR PrintChar           ; echo command
0028AA  1               .endif
0028AA  1  20 7E 2C             JSR PrintSpace          ; print space
0028AD  1  20 FB 2B             JSR GetAddress          ; prompt for start address
0028B0  1  86 32                STX SL                  ; store address
0028B2  1  84 33                STY SH
0028B4  1  20 7E 2C             JSR PrintSpace          ; print space
0028B7  1  20 FB 2B             JSR GetAddress          ; prompt for end address
0028BA  1  86 34                STX EL                  ; store address
0028BC  1  84 35                STY EH
0028BE  1  20 71 2C             JSR PrintCR
0028C1  1               
0028C1  1  20 B2 2D             JSR RequireStartNotAfterEnd
0028C4  1  90 01                BCC @okay1
0028C6  1  60                   RTS
0028C7  1               
0028C7  1               @okay1:
0028C7  1  A9 00                LDA #0                  ; Initialize checkum to zero
0028C9  1  85 36                STA DL
0028CB  1  85 37                STA DH
0028CD  1  A0 00                LDY #0
0028CF  1               @CalcSum:
0028CF  1  B1 32                LDA (SL),Y              ; read a byte
0028D1  1  18                   CLC
0028D2  1  65 36                ADC DL                  ; add to sum
0028D4  1  85 36                STA DL
0028D6  1  90 02                BCC @NoCarry1
0028D8  1  E6 37                INC DH                  ; add carry to upper byte of sum
0028DA  1               @NoCarry1:
0028DA  1  A5 33                LDA SH                  ; reached end yet?
0028DC  1  C5 35                CMP EH
0028DE  1  D0 10                BNE @NotDone
0028E0  1  A5 32                LDA SL
0028E2  1  C5 34                CMP EL
0028E4  1  D0 0A                BNE @NotDone
0028E6  1               
0028E6  1  A6 36                LDX DL                  ; Get checksum value
0028E8  1  A4 37                LDY DH
0028EA  1  20 0D 2C             JSR PrintAddress        ; Print it
0028ED  1  4C 71 2C             JMP PrintCR
0028F0  1               
0028F0  1               @NotDone:
0028F0  1  A5 32                LDA SL                  ; increment start address
0028F2  1  18                   CLC
0028F3  1  69 01                ADC #1
0028F5  1  85 32                STA SL
0028F7  1  90 02                BCC @NoCarry2
0028F9  1  E6 33                INC SH
0028FB  1               @NoCarry2:
0028FB  1  4C CF 28             JMP @CalcSum
0028FE  1               
0028FE  1               ; S Record Loader
0028FE  1               ; Format: J
0028FE  1               ; Load a Motorola hex (RUN or S record) format file into memory. Exits
0028FE  1               ; if <ESC> is received at any time or after an S9 record is received.
0028FE  1               ; Executes the loaded code if the start address is non-zero.
0028FE  1               ;
0028FE  1               ; File record format:
0028FE  1               ; S <rec type> <byte count> <address> <data>... <checksum> <CR>/<LF>/<NUL>
0028FE  1               ;
0028FE  1               ; e.g.
0028FE  1               ; S00F000068656C6C6F202020202000003C
0028FE  1               ; S11F00007C0802A6900100049421FFF07C6C1B787C8C23783C6000003863000026
0028FE  1               ; S11F001C4BFFFFE5398000007D83637880010014382100107C0803A64E800020E9
0028FE  1               ; S111003848656C6C6F20776F726C642E0A0042
0028FE  1               ; S5030003F9
0028FE  1               ; S9030000FC
0028FE  1               ;
0028FE  1               ; Record types:
0028FE  1               ; S0 header - accepted but ignored
0028FE  1               ; S1 - 16-bit address record
0028FE  1               ; S2,S3,S4 - not supported
0028FE  1               ; S5,S6 - accepted but ignored
0028FE  1               ; S7,S8 - not supported
0028FE  1               ; S9 - start address. Executes if address is not zero.
0028FE  1               ;
0028FE  1               ; At any point, quit if <ESC> character received.
0028FE  1               
0028FE  1               Load:
0028FE  1  A2 E6                ldx     #<SLoading
002900  1  A0 31                ldy     #>SLoading
002902  1  20 71 2C             jsr     PrintCR
002905  1  20 86 2C             jsr     PrintString     ; Display "Loading"
002908  1  20 71 2C             jsr     PrintCR
00290B  1               
00290B  1               SRecord:
00290B  1  A9 00                lda     #0
00290D  1  8D 3D 10             sta     checksum        ; Checksum = 0
002910  1  8D 3E 10             sta     bytesRead       ; BytesRead = 0
002913  1  8D 40 10             sta     byteCount       ; ByteCount = 0
002916  1  85 38                sta     ADDR            ; Address = 0
002918  1  85 39                sta     ADDR+1
00291A  1               
00291A  1               sloop:
00291A  1  20 5B 2B             jsr     GetKey          ; Get character
00291D  1  C9 1B                cmp     #ESC
00291F  1  D0 01                bne     notesc
002921  1  60                   rts                     ; Return if <ESC>
002922  1               notesc:
002922  1               ;       jsr     PrintChar       ; Echo the character
002922  1  C9 0D                cmp     #CR             ; Ignore if <CR>
002924  1  F0 F4                beq     sloop
002926  1  C9 0A                cmp     #LF             ; Ignore if <LF>
002928  1  F0 F0                beq     sloop
00292A  1  C9 00                cmp     #NUL            ; Ignore if <NUL>
00292C  1  F0 EC                beq     sloop
00292E  1               
00292E  1  C9 53                cmp     #'S'            ; Should be 'S'
002930  1  D0 17                bne     invalidRecord   ; If not, error
002932  1               
002932  1  20 5B 2B             jsr     GetKey          ; Get record type character
002935  1               ;       jsr     PrintChar       ; Echo the character
002935  1               
002935  1  C9 30                cmp     #'0'            ; Should be '0', '1', '5', '6' or '9'
002937  1  F0 1B                beq     validType
002939  1  C9 31                cmp     #'1'
00293B  1  F0 17                beq     validType
00293D  1  C9 35                cmp     #'5'
00293F  1  F0 13                beq     validType
002941  1  C9 36                cmp     #'6'
002943  1  F0 0F                beq     validType
002945  1  C9 39                cmp     #'9'
002947  1  F0 0B                beq     validType
002949  1               
002949  1               invalidRecord:
002949  1  A2 C8                ldx     #<SInvalidRecord
00294B  1  A0 31                ldy     #>SInvalidRecord
00294D  1  20 86 2C             jsr     PrintString     ; Display "Invalid record"
002950  1  20 71 2C             jsr     PrintCR
002953  1  60                   rts                     ; Return
002954  1               
002954  1               validType:
002954  1  8D 3F 10             sta     recordType      ; Save char as record type '0'..'9'
002957  1               
002957  1  20 02 2B             jsr     getHexByte      ; Get byte count
00295A  1  B0 ED                bcs     invalidRecord
00295C  1  C9 03                cmp     #3              ; Invalid if byteCount  < 3
00295E  1  30 E9                bmi     invalidRecord
002960  1  8D 40 10             sta     byteCount       ; Save as byte count
002963  1               
002963  1  18                   clc
002964  1  6D 3D 10             adc     checksum        ; Add byte count to checksum
002967  1  8D 3D 10             sta     checksum
00296A  1               
00296A  1  AD 3F 10             lda     recordType      ; If record type is 5 or 9, byte count should be 3
00296D  1  C9 35                cmp     #'5'
00296F  1  F0 04                beq     checkcnt
002971  1  C9 39                cmp     #'9'
002973  1  D0 09                bne     getadd
002975  1               checkcnt:
002975  1  AD 40 10             lda     byteCount
002978  1  C9 03                cmp     #3
00297A  1  F0 02                beq     getadd
00297C  1  D0 CB                bne     invalidRecord
00297E  1               
00297E  1               getadd:
00297E  1  20 17 2B             jsr     getHexAddress   ; Get 16-bit start address
002981  1  B0 C6                bcs     invalidRecord
002983  1               
002983  1  86 38                stx     ADDR            ; Save as address
002985  1  84 39                sty     ADDR+1
002987  1               
002987  1  8A                   txa
002988  1  18                   clc
002989  1  6D 3D 10             adc     checksum        ; Add address bytes to checksum
00298C  1  8D 3D 10             sta     checksum
00298F  1  98                   tya
002990  1  18                   clc
002991  1  6D 3D 10             adc     checksum
002994  1  8D 3D 10             sta     checksum
002997  1               
002997  1  EE 3E 10             inc     bytesRead       ; Increment bytesRead by 2 for address field
00299A  1  EE 3E 10             inc     bytesRead
00299D  1               
00299D  1               readRecord:
00299D  1  AD 3E 10             lda     bytesRead       ; If bytesRead+1 = byteCount (have to allow for checksum byte)
0029A0  1  18                   clc
0029A1  1  69 01                adc     #1
0029A3  1  CD 40 10             cmp     byteCount
0029A6  1  F0 30                beq     dataend         ; ...break out of loop
0029A8  1               
0029A8  1  20 02 2B             jsr     getHexByte      ; Get two hex digits
0029AB  1  B0 9C                bcs     invalidRecord   ; Exit if invalid
0029AD  1               
0029AD  1  8D 3C 10             sta     temp1           ; Save data
0029B0  1               
0029B0  1  18                   clc
0029B1  1  6D 3D 10             adc     checksum        ; Add data read to checksum
0029B4  1  8D 3D 10             sta     checksum
0029B7  1               
0029B7  1  AD 3F 10             lda     recordType
0029BA  1  C9 31                cmp     #'1'            ; Is record type 1?
0029BC  1  D0 07                bne     nowrite
0029BE  1  AD 3C 10             lda     temp1           ; Get data back
0029C1  1  A0 00                ldy     #0
0029C3  1  91 38                sta     (ADDR),y        ; Write data to address
0029C5  1               
0029C5  1               ; TODO: Could verify data written, but not necessarily an error.
0029C5  1               
0029C5  1               nowrite:
0029C5  1  AD 3F 10             lda     recordType      ; Only increment address if this is an S1 record
0029C8  1  C9 31                cmp     #'1'
0029CA  1  D0 06                bne     @nocarry1
0029CC  1  E6 38                inc     ADDR            ; Increment address (low byte)
0029CE  1  D0 02                bne     @nocarry1
0029D0  1  E6 39                inc     ADDR+1          ; Increment address (high byte)
0029D2  1               @nocarry1:
0029D2  1  EE 3E 10             inc     bytesRead       ; Increment bytesRead
0029D5  1  4C 9D 29             jmp     readRecord      ; Go back and read more data
0029D8  1               
0029D8  1               dataend:
0029D8  1  20 02 2B             jsr     getHexByte      ; Get two hex digits (checksum)
0029DB  1  90 03                bcc     okay1
0029DD  1  4C 49 29             jmp     invalidRecord
0029E0  1               okay1:
0029E0  1  49 FF                eor     #$FF            ; Calculate 1's complement
0029E2  1  CD 3D 10             cmp     checksum        ; Compare to calculated checksum
0029E5  1  F0 0B                beq     sumokay         ; branch if matches
0029E7  1  A2 D7                ldx     #<SChecksumError
0029E9  1  A0 31                ldy     #>SChecksumError
0029EB  1  20 86 2C             jsr     PrintString     ; Display "Checksum error"
0029EE  1  20 71 2C             jsr     PrintCR
0029F1  1  60                   rts                     ; Return
0029F2  1               
0029F2  1               sumokay:
0029F2  1  AD 3F 10             lda     recordType      ; Get record type
0029F5  1  C9 39                cmp     #'9'            ; S9 (end of file)?
0029F7  1  F0 03                beq     s9
0029F9  1  4C 0B 29             jmp     SRecord         ; If not go back and read more records
0029FC  1               s9:
0029FC  1  A2 EE                ldx     #<SLoaded
0029FE  1  A0 31                ldy     #>SLoaded
002A00  1  20 71 2C             jsr     PrintCR
002A03  1  20 86 2C             jsr     PrintString     ; Display "Loaded"
002A06  1  20 71 2C             jsr     PrintCR
002A09  1  A5 38                lda     ADDR            ; Start execution if start address = 0
002A0B  1  F0 01                beq     lowz
002A0D  1               highz:
002A0D  1  60                   rts                     ; Otherwise just return
002A0E  1               lowz:
002A0E  1  A5 39                lda     ADDR+1
002A10  1  F0 FB                beq     highz
002A12  1  6C 38 00             jmp     (ADDR)          ; Start execution at start address
002A15  1               
002A15  1               ; Write S record file to output frome startAddress to endAddress with
002A15  1               ; execution start address goAddress.
002A15  1               
002A15  1               Writer:
002A15  1               .ifdef ECHO
002A15  1                       JSR     PrintChar       ; echo command
002A15  1               .endif
002A15  1  20 7E 2C             JSR     PrintSpace      ; print space
002A18  1  20 FB 2B             JSR     GetAddress      ; prompt for start address
002A1B  1  86 32                STX     SL              ; store address
002A1D  1  84 33                STY     SH
002A1F  1  20 7E 2C             JSR     PrintSpace      ; print space
002A22  1  20 FB 2B             JSR     GetAddress      ; prompt for end address
002A25  1  86 34                STX     EL              ; store address
002A27  1  84 35                STY     EH
002A29  1  20 7E 2C             JSR     PrintSpace      ; print space
002A2C  1  20 FB 2B             JSR     GetAddress      ; prompt for go address
002A2F  1  86 36                STX     DL              ; store address
002A31  1  84 37                STY     DH
002A33  1  20 71 2C             JSR     PrintCR
002A36  1               
002A36  1  20 B2 2D             JSR     RequireStartNotAfterEnd
002A39  1  90 01                BCC     @okay
002A3B  1  60                   RTS
002A3C  1               @okay:
002A3C  1  A5 32                lda     SL              ; address = startAddress
002A3E  1  85 38                sta     ADDR
002A40  1  A5 33                lda     SH
002A42  1  85 39                sta     ADDR+1
002A44  1               
002A44  1               ; Write S0 record, fixed as: <CR>S0030000FC<CR>
002A44  1               
002A44  1  A2 F5                ldx     #<S0String
002A46  1  A0 31                ldy     #>S0String
002A48  1  20 86 2C             jsr     PrintString
002A4B  1               
002A4B  1               writes1:                        ; Write S1 records
002A4B  1  A9 00                lda     #0
002A4D  1  8D 41 10             sta     bytesWritten    ; bytesWritten = 0
002A50  1               
002A50  1  A9 53                lda     #'S'            ; Write "S1"
002A52  1  20 EC 2C             jsr     PrintChar
002A55  1  A9 31                lda     #'1'
002A57  1  20 EC 2C             jsr     PrintChar
002A5A  1               
002A5A  1  A9 23                lda     #bytesPerLine+3 ; write bytesPerLine (+3 for size and address)
002A5C  1  8D 3D 10             sta     checksum        ; update checksum
002A5F  1  20 D9 2C             jsr     PrintByte
002A62  1               
002A62  1  A6 38                ldx      ADDR           ; write address
002A64  1  A4 39                ldy      ADDR+1
002A66  1  20 0D 2C             jsr      PrintAddress
002A69  1               
002A69  1  AD 3D 10             lda      checksum       ; checksum = checksum + address high
002A6C  1  18                   clc
002A6D  1  65 39                adc      ADDR+1
002A6F  1  18                   clc
002A70  1  65 38                adc      ADDR           ; checksum = checksum + address low
002A72  1  8D 3D 10             sta      checksum
002A75  1               
002A75  1               writeLoop1:
002A75  1  A0 00                ldy     #0
002A77  1  B1 38                lda     (ADDR),y
002A79  1  20 D9 2C             jsr     PrintByte       ; print byte at address
002A7C  1               
002A7C  1  B1 38                lda     (ADDR),y        ; Get back A (modified by PrintByte)
002A7E  1  18                   clc
002A7F  1  6D 3D 10             adc     checksum        ; checksum = checksum + byte at address
002A82  1  8D 3D 10             sta     checksum
002A85  1               
002A85  1  E6 38                inc     ADDR            ; Increment address (low byte)
002A87  1  D0 02                bne     nocarry1
002A89  1  E6 39                inc     ADDR+1          ; Increment address (high byte)
002A8B  1               nocarry1:
002A8B  1  EE 41 10             inc     bytesWritten    ; bytesWritten = bytesWritten + 1
002A8E  1               
002A8E  1  AD 41 10             lda     bytesWritten    ; if bytesWritten = bytesPerLine
002A91  1  C9 20                cmp     #bytesPerLine
002A93  1  D0 E0                bne     writeLoop1      ; ...go back and loop
002A95  1               
002A95  1  AD 3D 10             lda     checksum        ; Calculate checksum 1's complement
002A98  1  49 FF                eor     #$ff
002A9A  1  20 D9 2C             jsr     PrintByte       ; Output checksum
002A9D  1  20 71 2C             jsr     PrintCR         ; Output line terminator
002AA0  1               
002AA0  1  A5 39                lda     ADDR+1          ; if address < endAddress, go back and continue
002AA2  1  C5 35                cmp     EH
002AA4  1  30 A5                bmi     writes1
002AA6  1  A5 38                lda     ADDR
002AA8  1  C5 34                cmp     EL
002AAA  1  30 9F                bmi     writes1
002AAC  1               
002AAC  1               ; Write S9 record
002AAC  1               writes9:
002AAC  1  A9 53                lda     #'S'            ; Write S9
002AAE  1  20 EC 2C             jsr     PrintChar
002AB1  1  A9 39                lda     #'9'
002AB3  1  20 EC 2C             jsr     PrintChar
002AB6  1  A9 03                lda     #$03            ; Write 03
002AB8  1  20 D9 2C             jsr     PrintByte
002ABB  1  A9 03                lda     #$03            ; checksum = 03
002ABD  1  8D 3D 10             sta     checksum
002AC0  1               
002AC0  1  A6 36                ldx     DL              ; Send go address
002AC2  1  A4 37                ldy     DH
002AC4  1  20 0D 2C             jsr     PrintAddress
002AC7  1               
002AC7  1  AD 3D 10             lda     checksum        ; checksum = checksum + goAaddress high
002ACA  1  18                   clc
002ACB  1  65 37                adc     DH
002ACD  1  18                   clc
002ACE  1  65 36                adc     DL              ; checksum = checksum + goAddress low
002AD0  1  8D 3D 10             sta     checksum
002AD3  1               
002AD3  1  AD 3D 10             lda     checksum        ; Calculate checksum 1's complement
002AD6  1  49 FF                eor     #$ff
002AD8  1  20 D9 2C             jsr     PrintByte       ; Output checksum
002ADB  1  20 71 2C             jsr     PrintCR         ; Output line terminator
002ADE  1               
002ADE  1  60                   rts
002ADF  1               
002ADF  1               ; Read character corresponding to hex number ('0'-'9','A'-'F').
002ADF  1               ; If valid, return binary value in A and carry bit clear.
002ADF  1               ; If not valid, return with carry bit set.
002ADF  1               getHexChar:
002ADF  1  20 5B 2B             jsr     GetKey          ; Read character
002AE2  1               ;       jsr     PrintChar       ; Echo the character
002AE2  1  C9 30                cmp     #'0'            ; Error if < '0'
002AE4  1  30 18                bmi     error1
002AE6  1  C9 3A                cmp     #'9'+1          ; Valid if <= '9'
002AE8  1  30 0E                bmi     number1
002AEA  1  C9 47                cmp     #'F'+1          ; Error if > 'F'
002AEC  1  10 10                bpl     error1
002AEE  1  C9 41                cmp     #'A'            ; Error if < 'A'
002AF0  1  30 0C                bmi     error1
002AF2  1  38                   sec
002AF3  1  E9 37                sbc     #'A'-10         ; Value is character-('A'-10)
002AF5  1  4C 00 2B             jmp     good1
002AF8  1               number1:
002AF8  1  38                   sec
002AF9  1  E9 30                sbc     #'0'            ; Value is character-'0'
002AFB  1  4C 00 2B             jmp     good1
002AFE  1               error1:
002AFE  1  38                   sec                     ; Set carry to indicate error
002AFF  1  60                   rts                     ; Return
002B00  1               good1:
002B00  1  18                   clc                     ; Clear carry to indicate valid
002B01  1  60                   rts                     ; Return
002B02  1               
002B02  1               ; Read two characters corresponding to 8-bit hex number.
002B02  1               ; If valid, return binary value in A and carry bit clear.
002B02  1               ; If not valid, return with carry bit set.
002B02  1               getHexByte:
002B02  1  20 DF 2A             jsr     getHexChar      ; Get high nybble
002B05  1  B0 1D                bcs     bad1            ; Branch if invalid
002B07  1  0A                   asl                     ; Shift return value left to upper nybble
002B08  1  0A                   asl
002B09  1  0A                   asl
002B0A  1  0A                   asl
002B0B  1  8D 3C 10             sta     temp1           ; Save value
002B0E  1  20 DF 2A             jsr     getHexChar      ; Get low nybble
002B11  1  B0 11                bcs     bad1            ; Branch if invalid
002B13  1  0D 3C 10             ora     temp1           ; Add (OR) return value to previous value
002B16  1  60                   rts                     ; Return with carry clear
002B17  1               
002B17  1               ; Read four characters corresponding to 16-bit hex address.
002B17  1               ; If valid, return binary value in X (low) and Y (high) and carry bit clear.
002B17  1               ; If not valid, return with carry bit set.
002B17  1               getHexAddress:
002B17  1  20 02 2B             jsr     getHexByte      ; Get high order byte
002B1A  1  B0 08                bcs     bad1            ; Branch if invalid
002B1C  1  A8                   tay                     ; Save value in Y
002B1D  1  20 02 2B             jsr     getHexByte      ; Get low order byte
002B20  1  B0 02                bcs     bad1            ; Branch if invalid
002B22  1  AA                   tax                     ; Save value in X
002B23  1  60                   rts                     ; Return with carry clear
002B24  1               bad1:
002B24  1  60                   rts                     ; Return with carry set
002B25  1               
002B25  1               ; -------------------- Utility Functions --------------------
002B25  1               
002B25  1               ; Generate one line of output for the dump command.
002B25  1               ; Apple 1 format:         AAAA DD DD DD DD DD DD DD DD ........
002B25  1               ; Superboard /// format:  AAAA DD DD DD DD ....
002B25  1               ; Displays 8 (4 for OSI) bytes of memory
002B25  1               ; Starting address in SL,SH.
002B25  1               ; Registers changed: None
002B25  1               DumpLine:
002B25  1  48                   PHA                     ; save A
002B26  1  8A                   TXA
002B27  1  48                   PHA                     ; Save X
002B28  1  98                   TYA
002B29  1  48                   PHA                     ; Save Y
002B2A  1  A6 32                LDX SL                  ; Get start address
002B2C  1  A4 33                LDY SH
002B2E  1  20 0D 2C             JSR PrintAddress        ; Display address
002B31  1  20 7E 2C             JSR PrintSpace          ; and then a space
002B34  1  A0 00                LDY #0
002B36  1  B1 32        @loop1: LDA (SL),Y              ; Get byte of data from memory
002B38  1  20 D9 2C             JSR PrintByte           ; Display it in hex
002B3B  1  20 7E 2C             JSR PrintSpace          ; Followed by space
002B3E  1  C8                   INY
002B3F  1  C0 10                CPY #BYTESPERLINE       ; Print 8/4 bytes per line
002B41  1  D0 F3                BNE @loop1
002B43  1  20 7E 2C             JSR PrintSpace
002B46  1  A0 00                LDY #0
002B48  1  B1 32        @loop2: LDA (SL),Y              ; Now get the same data
002B4A  1  20 5E 2C             JSR PrintAscii          ; Display it in ASCII
002B4D  1  C8                   INY
002B4E  1  C0 10                CPY #BYTESPERLINE       ; 8/4 characters per line
002B50  1  D0 F6                BNE @loop2
002B52  1  20 71 2C             JSR PrintCR             ; new line
002B55  1  68                   PLA                     ; Restore Y
002B56  1  A8                   TAY
002B57  1  68                   PLA                     ; Restore X
002B58  1  AA                   TAX
002B59  1  68                   PLA                     ; Restore A
002B5A  1  60                   RTS
002B5B  1               
002B5B  1               ; Get character from keyboard
002B5B  1               ; Returns character in A
002B5B  1               ; Clears high bit to be valid ASCII
002B5B  1               ; Registers changed: A
002B5B  1               GetKey:
002B5B  1               .if .defined(APPLE1)
002B5B  1                       LDA KBDCR               ; Read keyboard control register
002B5B  1                       BPL GetKey              ; Loop until key pressed (bit 7 goes high)
002B5B  1                       LDA KBD                 ; Get keyboard data
002B5B  1                       AND #%01111111          ; Clear most significant bit to convert to standard ASCII
002B5B  1                       RTS
002B5B  1               .elseif .defined(APPLE2)
002B5B  1                       LDA $C000               ; Read keyboard register
002B5B  1                       BPL GetKey              ; Loop until key pressed (bit 7 goes high)
002B5B  1                       AND #%01111111          ; Clear most significant bit to convert to standard ASCII
002B5B  1                       PHA
002B5B  1                       LDA $C010               ; Clear keyboard strobe
002B5B  1                       PLA
002B5B  1                       RTS
002B5B  1               .elseif .defined(OSI)
002B5B  1                       JMP $FD00               ; Call OSI keyboard input routine
002B5B  1               ;       JMP $FE80               ; Call OSI serial input routine
002B5B  1               .elseif .defined(KIM1)
002B5B  1  98                   TYA                     ; Save Y on stack
002B5C  1  48                   PHA
002B5D  1  20 5A 1E             JSR $1E5A               ; Call KIM GETCH routine. Returns char in A. Changes Y.
002B60  1  85 48                STA T3                  ; Save A
002B62  1  68                   PLA                     ; Restore Y from stack
002B63  1  A8                   TAY
002B64  1  A5 48                LDA T3                  ; Restore A
002B66  1  60                   RTS
002B67  1               .elseif .defined(SBC)
002B67  1               WaitForKeypress:
002B67  1                       JSR MONRDKEY
002B67  1                       BCC WaitForKeypress
002B67  1                       RTS
002B67  1               .endif
002B67  1               
002B67  1               ; Gets a hex digit (0-9,A-F). Echoes character as typed.
002B67  1               ; ESC key cancels command and goes back to command loop.
002B67  1               ; If RETOK is zero, ignore Return key.
002B67  1               ; If RETOK is non-zero, pressing Return will cause it to return with A=0 and carry set.
002B67  1               ; If CHAROK is non-zero, pressing a single quote allows entering a character.
002B67  1               ; Ignores invalid characters. Returns binary value in A
002B67  1               ; Registers changed: A
002B67  1               GetHex:
002B67  1  20 5B 2B             JSR GetKey
002B6A  1  C9 1B                CMP #ESC                ; ESC key?
002B6C  1  D0 0D                BNE @checkRet
002B6E  1  20 71 2C             JSR PrintCR
002B71  1  68                   PLA                     ; pop return address on stack
002B72  1  68                   PLA
002B73  1  A9 00                LDA #0
002B75  1  8D 23 10             STA CHAROK              ; Clear flag to accept character input
002B78  1  4C 35 20             JMP MainLoop            ; Abort command
002B7B  1               @checkRet:
002B7B  1  C9 0D                CMP #CR                 ; Return key?
002B7D  1  D0 09                BNE @next
002B7F  1  AD 01 10             LDA RETOK               ; Flag set to check for return?
002B82  1  F0 E3                BEQ GetHex              ; If not, ignore Return key
002B84  1  A9 00                LDA #0
002B86  1  38                   SEC                     ; Carry set indicates Return pressed
002B87  1  60                   RTS
002B88  1               @next:
002B88  1  C9 27                CMP #'''                ; Single quote for character input?
002B8A  1  D0 16                BNE @next1
002B8C  1  AD 23 10             LDA CHAROK              ; Are we accepting character input?
002B8F  1  F0 D6                BEQ GetHex              ; If not, ignore character
002B91  1               .ifdef ECHO
002B91  1                       LDA #'''                ; Echo a quote
002B91  1                       JSR PrintChar
002B91  1               .endif
002B91  1  A9 01                LDA #1                  ; Set flag that we are in character input mode
002B93  1  8D 24 10             STA CHARMODE
002B96  1  20 5B 2B             JSR GetKey              ; Get a character
002B99  1               
002B99  1  2C 27 10             BIT OHIGHASCII          ; If OHIGHASCII option is on, set high bit of character
002B9C  1  10 02                BPL @NoConv
002B9E  1  09 80                ORA #%10000000
002BA0  1               @NoConv:
002BA0  1               .ifdef ECHO
002BA0  1                       JSR PrintChar           ; Echo it
002BA0  1               .endif
002BA0  1               .ifdef ECHO
002BA0  1                       PHA                     ; Save the character
002BA0  1                       LDA #'''                ; Echo a quote
002BA0  1                       JSR PrintChar
002BA0  1                       PLA                     ; Restore the character
002BA0  1               .endif
002BA0  1  18                   CLC                     ; Normal return
002BA1  1  60                   RTS
002BA2  1               @next1:
002BA2  1  20 24 2F             JSR ToUpper
002BA5  1  C9 30                CMP #'0'
002BA7  1  30 BE                BMI GetHex              ; Invalid, ignore and try again
002BA9  1  C9 3A                CMP #'9'+1
002BAB  1  30 0B                BMI @Digit
002BAD  1  C9 41                CMP #'A'
002BAF  1  30 B6                BMI GetHex              ; Invalid, ignore and try again
002BB1  1  C9 47                CMP #'F'+1
002BB3  1  30 08                BMI @Letter
002BB5  1  4C 67 2B             JMP GetHex              ; Invalid, ignore and try again
002BB8  1               @Digit:
002BB8  1               .ifdef ECHO
002BB8  1                       JSR PrintChar           ; echo
002BB8  1               .endif
002BB8  1  38                   SEC
002BB9  1  E9 30                SBC #'0'                ; convert to value
002BBB  1  18                   CLC
002BBC  1  60                   RTS
002BBD  1               @Letter:
002BBD  1               .ifdef ECHO
002BBD  1                       JSR PrintChar           ; echo
002BBD  1               .endif
002BBD  1  38                   SEC
002BBE  1  E9 37                SBC #'A'-10             ; convert to value
002BC0  1  18                   CLC
002BC1  1  60                   RTS
002BC2  1               
002BC2  1               ; Get Byte as 2 chars 0-9,A-F
002BC2  1               ; Echoes characters as typed.
002BC2  1               ; Ignores invalid characters
002BC2  1               ; Returns byte in A
002BC2  1               ; If RETOK is zero, ignore Return key.
002BC2  1               ; If RETOK is non-zero, pressing Return as first character will cause it to return with A=0 and carry set.
002BC2  1               ; If CHAROK is non-zero, pressing a single quote allows entering a character.
002BC2  1               ; Registers changed: A
002BC2  1               GetByte:
002BC2  1  20 67 2B             JSR GetHex
002BC5  1  90 01                BCC @NotRet
002BC7  1  60                   RTS                     ; <Return> was pressed, so return
002BC8  1               @NotRet:
002BC8  1  48                   PHA                     ; Save character
002BC9  1  AD 24 10             LDA CHARMODE            ; Are we in character input mode?
002BCC  1  F0 08                BEQ @Normal
002BCE  1  A9 00                LDA #0                  ; If so, we got our byte as a character. Clear charmode.
002BD0  1  8D 24 10             STA CHARMODE
002BD3  1  18                   CLC
002BD4  1  68                   PLA                     ; Restore character
002BD5  1  60                   RTS                     ; Normal return
002BD6  1               @Normal:
002BD6  1  68                   PLA
002BD7  1  0A                   ASL
002BD8  1  0A                   ASL
002BD9  1  0A                   ASL
002BDA  1  0A                   ASL
002BDB  1  85 30                STA T1                  ; Store first nybble
002BDD  1  AD 23 10             LDA CHAROK              ; Get value of CHAROK
002BE0  1  8D 00 10             STA T2                  ; Save it
002BE3  1  A9 00                LDA #0
002BE5  1  8D 23 10             STA CHAROK              ; Disable char input for second nybble of a byte
002BE8  1               @IgnoreRet:
002BE8  1  20 67 2B             JSR GetHex
002BEB  1  B0 FB                BCS @IgnoreRet          ; If <Return> pressed, ignore it and try again
002BED  1  18                   CLC
002BEE  1  65 30                ADC T1                  ; Add second nybble
002BF0  1  85 30                STA T1                  ; Save it
002BF2  1  AD 00 10             LDA T2                  ; Restore value of CHAROK
002BF5  1  8D 23 10             STA CHAROK
002BF8  1  A5 30                LDA T1                  ; Get value to return
002BFA  1  60                   RTS
002BFB  1               
002BFB  1               ; Get Address as 4 chars 0-9,A-F
002BFB  1               ; Echoes characters as typed.
002BFB  1               ; Ignores invalid characters
002BFB  1               ; Returns address in X (low), Y (high)
002BFB  1               ; Registers changed: X, Y
002BFB  1               GetAddress:
002BFB  1  48                   PHA                     ; Save A
002BFC  1  20 C2 2B             JSR GetByte             ; Get the first (most significant) hex byte
002BFF  1  B0 0A                BCS @RetPressed         ; Quit if Return pressed
002C01  1  A8                   TAY                     ; Save in Y
002C02  1  A9 00                LDA #0
002C04  1  8D 01 10             STA RETOK               ; One byte already entered so can't hit return now for default.
002C07  1  20 C2 2B             JSR GetByte             ; Get the second (least significant) hex byte
002C0A  1  AA                   TAX                     ; Save in X
002C0B  1               @RetPressed:
002C0B  1  68                   PLA                     ; Restore A
002C0C  1  60                   RTS
002C0D  1               
002C0D  1               ; Print 16-bit address in hex
002C0D  1               ; Pass byte in X (low) and Y (high)
002C0D  1               ; Registers changed: None
002C0D  1               PrintAddress:
002C0D  1  48                   PHA                     ; Save A
002C0E  1  98                   TYA                     ; Get low byte
002C0F  1  20 D9 2C             JSR PRBYTE              ; Print it
002C12  1  8A                   TXA                     ; Get high byte
002C13  1  20 D9 2C             JSR PRBYTE              ; Print it
002C16  1  68                   PLA                     ; Restore A
002C17  1  60                   RTS
002C18  1               
002C18  1               ; Print byte in BCD with leading zero suppression
002C18  1               ; Pass byte in A
002C18  1               ; Registers changed: None
002C18  1               ; Call first time with LZ cleared
002C18  1               PrintByteLZ:
002C18  1               ; Check for special case: number is $00, LZ is 0, LAST is 1
002C18  1               ; Last 0 should not be suppressed since it is the final one in $0000
002C18  1  C9 00                CMP #$00
002C1A  1  D0 13                BNE @normal
002C1C  1  48                   PHA
002C1D  1  AD 07 10             LDA LZ
002C20  1  D0 0C                BNE @pull
002C22  1  AD 08 10             LDA LAST
002C25  1  F0 07                BEQ @pull
002C27  1  A9 30                LDA #'0'
002C29  1  20 EC 2C             JSR PrintChar
002C2C  1  68                   PLA
002C2D  1  60                   RTS
002C2E  1  68           @pull: PLA
002C2F  1               @normal:
002C2F  1  48                   PHA                     ; save for lower nybble
002C30  1  29 F0                AND #$F0                ; mask out upper nybble
002C32  1  4A                   LSR                     ; shift into lower nybble
002C33  1  4A                   LSR
002C34  1  4A                   LSR
002C35  1  4A                   LSR
002C36  1  18                   CLC
002C37  1  69 30                ADC #'0'
002C39  1  20 45 2C             JSR PrintCharLZ
002C3C  1  68                   PLA                     ; restore value
002C3D  1  29 0F                AND #$0F                ; mask out lower nybble
002C3F  1  18                   CLC
002C40  1  69 30                ADC #'0'
002C42  1  4C 45 2C             JMP PrintCharLZ
002C45  1               
002C45  1               ; Print character but suppress 0 if LZ it not set.
002C45  1               ; Sets LZ when non-zero printed.
002C45  1               ; Pass char in A
002C45  1               PrintCharLZ:
002C45  1  C9 30                CMP #'0'                ; is it 0?
002C47  1  D0 0C                BNE @notzero            ; if not, print it normally
002C49  1  48                   PHA
002C4A  1  AD 07 10             LDA LZ                  ; is LZ zero?
002C4D  1  D0 02                BNE @print
002C4F  1  68                   PLA
002C50  1  60                   RTS                     ; suppress leading zero
002C51  1  68           @print: PLA
002C52  1  4C EC 2C             JMP PrintChar
002C55  1               
002C55  1               @notzero:
002C55  1  20 EC 2C             JSR PrintChar           ; print it
002C58  1  A9 01                LDA #1                  ; set LZ to 1
002C5A  1  8D 07 10             STA LZ
002C5D  1  60                   RTS
002C5E  1               
002C5E  1               ; Print byte as ASCII character or "."
002C5E  1               ; Pass character in A.
002C5E  1               ; Registers changed: None
002C5E  1               PrintAscii:
002C5E  1  C9 20                CMP #$20                ; first printable character (space)
002C60  1  30 07                BMI NotAscii
002C62  1  C9 7F                CMP #$7E+1              ; last printable character (~)
002C64  1  10 03                BPL NotAscii
002C66  1  4C EC 2C             JMP PrintChar
002C69  1               
002C69  1               NotAscii:
002C69  1  48                   PHA                     ; save A
002C6A  1  A9 2E                LDA #'.'
002C6C  1  20 EC 2C             JSR PrintChar
002C6F  1  68                   PLA                     ; restore A
002C70  1  60                   RTS
002C71  1               
002C71  1               ; Print a carriage return
002C71  1               ; Registers changed: None
002C71  1               PrintCR:
002C71  1  48                   PHA
002C72  1  A9 0D                LDA #CR
002C74  1  20 EC 2C             JSR PrintChar
002C77  1  A9 0A                LDA #LF
002C79  1  20 EC 2C             JSR PrintChar
002C7C  1  68                   PLA
002C7D  1  60                   RTS
002C7E  1               
002C7E  1               ; Print a space
002C7E  1               ; Registers changed: None
002C7E  1               PrintSpace:
002C7E  1  48                   PHA
002C7F  1  A9 20                LDA #SP
002C81  1  20 EC 2C             JSR PrintChar
002C84  1  68                   PLA
002C85  1  60                   RTS
002C86  1               
002C86  1               ; Print a string
002C86  1               ; Pass address of string in X (low) and Y (high).
002C86  1               ; String must be terminated in a null (zero).
002C86  1               ; Registers changed: None
002C86  1               ;
002C86  1               PrintString:
002C86  1  48                   PHA             ; Save A
002C87  1  98                   TYA
002C88  1  48                   PHA             ; Save Y
002C89  1  86 30                STX T1          ; Save in page zero so we can use indirect addressing
002C8B  1  84 31                STY T1+1
002C8D  1  A0 00                LDY #0          ; Set offset to zero
002C8F  1  B1 30        @loop:  LDA (T1),Y      ; Read a character
002C91  1  F0 11                BEQ done        ; Done if we get a null (zero)
002C93  1  20 EC 2C             JSR PrintChar   ; Print it
002C96  1  18                   CLC             ; Increment address
002C97  1  A5 30                LDA T1          ; Low byte
002C99  1  69 01                ADC #1
002C9B  1  85 30                STA T1
002C9D  1  90 02                BCC @nocarry
002C9F  1  E6 31                INC T1+1        ; High byte
002CA1  1               @nocarry:
002CA1  1  4C 8F 2C             JMP @loop       ; Go back and print next character
002CA4  1               done:
002CA4  1  68                   PLA
002CA5  1  A8                   TAY             ; Restore Y
002CA6  1  68                   PLA             ; Restore A
002CA7  1  60                   RTS
002CA8  1               
002CA8  1               ; Embedded string printer. Unpops the stack to find the embedded
002CA8  1               ; string. It outputs one character at a time until a $00 marker is
002CA8  1               ; found. Then it jumps back to the calling program just beyond the
002CA8  1               ; string. Based on code from "Assembly Cookbook for the Apple II/IIe
002CA8  1               ; by Don Lancaster.
002CA8  1               
002CA8  1               Imprint:
002CA8  1  8E 39 10             STX XSAV2       ; Save registers
002CAB  1  8C 3A 10             STY YSAV2
002CAE  1  8D 3B 10             STA ASAV2
002CB1  1  68                   PLA             ; Get pointer low and save
002CB2  1  85 49                STA T4
002CB4  1  68                   PLA             ; Get pointer high and save
002CB5  1  85 4A                STA T4+1
002CB7  1  A0 00                LDY #$00        ; No indexing
002CB9  1               NXTCHR2:
002CB9  1  E6 49                INC T4          ; Get next high address
002CBB  1  D0 02                BNE NOC2        ; Skip if no carry
002CBD  1  E6 4A                INC T4+1        ; Increment high address
002CBF  1  B1 49        NOC2:   LDA (T4),Y      ; Get character
002CC1  1  F0 06                BEQ END2        ; If zero marker
002CC3  1  20 EC 2C             JSR PrintChar   ; Print character
002CC6  1  4C B9 2C             JMP NXTCHR2     ; Branch back
002CC9  1  A5 4A        END2:   LDA T4+1        ; Restore PC low
002CCB  1  48                   PHA
002CCC  1  A5 49                LDA T4          ; Restore PC high
002CCE  1  48                   PHA
002CCF  1  AE 39 10             LDX XSAV2
002CD2  1  AC 3A 10             LDY YSAV2       ; Restore registers
002CD5  1  AD 3B 10             LDA ASAV2
002CD8  1  60                   RTS             ; And exit
002CD9  1               
002CD9  1               ; Print byte as two hex chars.
002CD9  1               ; Taken from Woz Monitor PRBYTE routine ($FFDC).
002CD9  1               ; Pass byte in A
002CD9  1               ; Registers changed: A
002CD9  1               PrintByte:
002CD9  1               PRBYTE:
002CD9  1  48                   PHA             ; Save A for LSD.
002CDA  1  4A                   LSR
002CDB  1  4A                   LSR
002CDC  1  4A                   LSR             ; MSD to LSD position.
002CDD  1  4A                   LSR
002CDE  1  20 E2 2C             JSR PRHEX       ; Output hex digit.
002CE1  1  68                   PLA             ; Restore A.
002CE2  1                                       ; Falls through into PRHEX routine
002CE2  1               
002CE2  1               ; Print nybble as one hex digit.
002CE2  1               ; Take from Woz Monitor PRHEX routine ($FFE5).
002CE2  1               ; Pass byte in A
002CE2  1               ; Registers changed: A
002CE2  1               PRHEX:
002CE2  1  29 0F                AND #$0F        ; Mask LSD for hex print.
002CE4  1               .if .defined(APPLE1) .or .defined(APPLE2)
002CE4  1                       ORA #'0'+$80    ; Add "0".
002CE4  1                       CMP #$BA        ; Digit?
002CE4  1               .else
002CE4  1  09 30                ORA #'0'        ; Add "0".
002CE6  1  C9 3A                CMP #$3A        ; Digit?
002CE8  1               .endif
002CE8  1  90 02                BCC PrintChar   ; Yes, output it.
002CEA  1  69 06                ADC #$06        ; Add offset for letter.
002CEC  1                                       ; Falls through into PrintChar routine
002CEC  1               
002CEC  1               ; Output a character
002CEC  1               ; Pass byte in A
002CEC  1               ; Registers changed: none
002CEC  1               PrintChar:
002CEC  1               .if .defined(APPLE1)
002CEC  1                                       ; Based on Woz Monitor ECHO routine ($FFEF).
002CEC  1                       PHP             ; Save status
002CEC  1                       PHA             ; Save A as it may be changed
002CEC  1               @Loop:
002CEC  1                       BIT DSP         ; bit (B7) cleared yet?
002CEC  1                       BMI @Loop       ; No, wait for display.
002CEC  1               
002CEC  1               ; If option is set, convert lower case character to upper case
002CEC  1               
002CEC  1                       BIT OUPPER      ; Check value of option
002CEC  1                       BPL @NotLower   ; Skip conversion if not set
002CEC  1                       JSR ToUpper
002CEC  1               @NotLower:
002CEC  1                       STA DSP         ; Output character. Sets DA.
002CEC  1                       PLA             ; Restore A
002CEC  1                       PLP             ; Restore status
002CEC  1                       RTS             ; Return.
002CEC  1               
002CEC  1               .elseif .defined(APPLE2)
002CEC  1                       PHP             ; Save status
002CEC  1                       PHA             ; Save A as it may be changed
002CEC  1                       ORA #%10000000  ; Make sure high bit is set
002CEC  1                       JSR $FDF0       ; Apple II COUT1
002CEC  1                       PLA             ; Restore A
002CEC  1                       PLP             ; Restore status
002CEC  1                       RTS             ; Return
002CEC  1               
002CEC  1               .elseif .defined(OSI)
002CEC  1                       PHP             ; Save status
002CEC  1                       PHA             ; Save A as it may be changed
002CEC  1                       JSR $BF2D       ; Call OSI screen character out routine
002CEC  1               ;       JSR $FCB1       ; Call OSI serial character out routine
002CEC  1                       CMP #CR         ; Is it Return?
002CEC  1                       BNE @ret        ; If not, return
002CEC  1                       LDA #LF
002CEC  1                       JSR $BF2D       ; Else print Linefeed too (screen)
002CEC  1               ;       JSR $FCB1       ; Else print Linefeed too (serial)
002CEC  1               @ret:
002CEC  1                       PLA             ; Restore A
002CEC  1                       PLP             ; Restore status
002CEC  1                       RTS             ; Return.
002CEC  1               
002CEC  1               .elseif .defined(KIM1)
002CEC  1               
002CEC  1  08                   PHP             ; Save status
002CED  1  85 48                STA     T3      ; Save A
002CEF  1  98                   TYA             ; Save Y
002CF0  1  48                   PHA
002CF1  1  A5 48                LDA     T3      ; Get A back
002CF3  1  20 A0 1E             JSR     $1EA0   ; Call monitor OUTCH character out routine. Changes A and Y.
002CF6  1  68                   PLA             ; Restore Y
002CF7  1  A8                   TAY
002CF8  1  A5 48                LDA     T3      ; Restore A
002CFA  1  28                   PLP             ; Restore status
002CFB  1  60                   RTS             ; Return.
002CFC  1               
002CFC  1               .elseif .defined(SBC)
002CFC  1               
002CFC  1                       PHP             ; Save status
002CFC  1                       PHA             ; Save A as it may be changed
002CFC  1                       JSR MONCOUT
002CFC  1                       CMP #CR         ; Is it Return?
002CFC  1                       BNE @ret1       ; If not, return
002CFC  1                       LDA #LF
002CFC  1                       JSR MONCOUT     ; Else print linefeed too
002CFC  1               @ret1:
002CFC  1                       PLA             ; Restore A
002CFC  1                       PLP             ; Restore status
002CFC  1                       RTS             ; Return.
002CFC  1               
002CFC  1               .endif
002CFC  1               
002CFC  1               ; Print a dollar sign
002CFC  1               ; Registers changed: None
002CFC  1               PrintDollar:
002CFC  1  48                   PHA
002CFD  1  A9 24                LDA #'$'
002CFF  1  20 EC 2C             JSR PrintChar
002D02  1  68                   PLA
002D03  1  60                   RTS
002D04  1               
002D04  1               ; Print ",X"
002D04  1               ; Registers changed: None
002D04  1               PrintCommaX:
002D04  1  48                   PHA
002D05  1  A9 2C                LDA #','
002D07  1  20 EC 2C             JSR PrintChar
002D0A  1  A9 58                LDA #'X'
002D0C  1  20 EC 2C             JSR PrintChar
002D0F  1  68                   PLA
002D10  1  60                   RTS
002D11  1               
002D11  1               ; Print ",Y"
002D11  1               ; Registers changed: None
002D11  1               PrintCommaY:
002D11  1  48                   PHA
002D12  1  A9 2C                LDA #','
002D14  1  20 EC 2C             JSR PrintChar
002D17  1  A9 59                LDA #'Y'
002D19  1  20 EC 2C             JSR PrintChar
002D1C  1  68                   PLA
002D1D  1  60                   RTS
002D1E  1               
002D1E  1               ; Print ",S"
002D1E  1               ; Registers changed: None
002D1E  1               PrintCommaS:
002D1E  1  48                   PHA
002D1F  1  A9 2C                LDA #','
002D21  1  20 EC 2C             JSR PrintChar
002D24  1  A9 53                LDA #'S'
002D26  1  20 EC 2C             JSR PrintChar
002D29  1  68                   PLA
002D2A  1  60                   RTS
002D2B  1               
002D2B  1               ; Print "($"
002D2B  1               ; Registers changed: None
002D2B  1               PrintLParenDollar:
002D2B  1  48                   PHA
002D2C  1  A9 28                LDA #'('
002D2E  1  20 EC 2C             JSR PrintChar
002D31  1  A9 24                LDA #'$'
002D33  1  20 EC 2C             JSR PrintChar
002D36  1  68                   PLA
002D37  1  60                   RTS
002D38  1               
002D38  1               ; Print "[$"
002D38  1               ; Registers changed: None
002D38  1               PrintLBraceDollar:
002D38  1  48                   PHA
002D39  1  A9 5B                LDA #'['
002D3B  1  20 EC 2C             JSR PrintChar
002D3E  1  A9 24                LDA #'$'
002D40  1  20 EC 2C             JSR PrintChar
002D43  1  68                   PLA
002D44  1  60                   RTS
002D45  1               
002D45  1               ; Print a right parenthesis
002D45  1               ; Registers changed: None
002D45  1               PrintRParen:
002D45  1  48                   PHA
002D46  1  A9 29                LDA #')'
002D48  1  20 EC 2C             JSR PrintChar
002D4B  1  68                   PLA
002D4C  1  60                   RTS
002D4D  1               
002D4D  1               ; Print a right brace
002D4D  1               ; Registers changed: None
002D4D  1               PrintRBrace:
002D4D  1  48                   PHA
002D4E  1  A9 5D                LDA #']'
002D50  1  20 EC 2C             JSR PrintChar
002D53  1  68                   PLA
002D54  1  60                   RTS
002D55  1               
002D55  1               ; Print several space characters.
002D55  1               ; X contains number of spaces to print.
002D55  1               ; Registers changed: X
002D55  1               PrintSpaces:
002D55  1  48                   PHA                     ; save A
002D56  1  A9 20                LDA #' '
002D58  1  20 5D 2D             JSR PrintChars
002D5B  1  68                   PLA                     ; restore A
002D5C  1  60                   RTS
002D5D  1               
002D5D  1               ; Output a character multiple times
002D5D  1               ; A contains character to print.
002D5D  1               ; X contains number of times to print.
002D5D  1               ; Registers changed: X
002D5D  1               PrintChars:
002D5D  1  20 EC 2C             JSR PrintChar
002D60  1  CA                   DEX
002D61  1  D0 FA                BNE PrintChars
002D63  1  60                   RTS
002D64  1               
002D64  1               ; Ask user whether to continue or not. Returns with carry clear if
002D64  1               ; user selected <space> to continue, carry set if user selected <ESC>
002D64  1               ; to stop.
002D64  1               ; Registers changed: none
002D64  1               
002D64  1               PromptToContinue:
002D64  1  48                   PHA                     ; save registers
002D65  1  8A                   TXA
002D66  1  48                   PHA
002D67  1  98                   TYA
002D68  1  48                   PHA
002D69  1  20 A8 2C             JSR Imprint
002D6C  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
002D6C  1  20 20 3C 53          .asciiz "  <Space> to continue, <ESC> to stop"
002D70  1  70 61 63 65  
002D74  1  3E 20 74 6F  
002D91  1               .elseif .defined(OSI)
002D91  1                       .asciiz " <SP> cont <ESC> stop"
002D91  1               .endif
002D91  1               @SpaceOrEscape:
002D91  1  20 5B 2B             JSR GetKey
002D94  1  C9 20                CMP #' '
002D96  1  F0 07                BEQ @Cont
002D98  1  C9 1B                CMP #ESC
002D9A  1  D0 F5                BNE @SpaceOrEscape
002D9C  1  38                   SEC                     ; carry set indicates ESC pressed
002D9D  1  B0 01                BCS @Ret
002D9F  1               @Cont:
002D9F  1  18                   CLC
002DA0  1               @Ret:
002DA0  1  20 71 2C             JSR PrintCR
002DA3  1  68                   PLA                     ; restore registers
002DA4  1  A8                   TAY
002DA5  1  68                   PLA
002DA6  1  AA                   TAX
002DA7  1  68                   PLA
002DA8  1  60                   RTS
002DA9  1               
002DA9  1               ; Delay. Calls routine WAIT using delay constant in OWDELAY.
002DA9  1               DELAY:
002DA9  1  AD 25 10             LDA OWDELAY
002DAC  1  F0 03                BEQ NODELAY
002DAE  1  4C CE 44             JMP WAIT
002DB1  1               NODELAY:
002DB1  1  60                   RTS
002DB2  1               
002DB2  1               ; Check if start address in SH/SL is less than or equal to end address
002DB2  1               ; in EH/EL. If so, return with carry clear. If not, print error
002DB2  1               ; message and return with carry set.
002DB2  1               RequireStartNotAfterEnd:
002DB2  1               ; Check that start address <= end address
002DB2  1  A5 33                LDA SH
002DB4  1  C5 35                CMP EH
002DB6  1  90 2D                BCC @rangeOkay
002DB8  1  D0 08                BNE @rangeInvalid
002DBA  1  A5 32                LDA SL
002DBC  1  C5 34                CMP EL
002DBE  1  90 25                BCC @rangeOkay
002DC0  1  F0 23                BEQ @rangeOkay
002DC2  1               @rangeInvalid:
002DC2  1               .ifdef BEEP
002DC2  1                       JSR BEEP
002DC2  1               .endif
002DC2  1  20 A8 2C             JSR Imprint
002DC5  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
002DC5  1  45 72 72 6F          .byte "Error: start must be <= end", CR,LF, 0
002DC9  1  72 3A 20 73  
002DCD  1  74 61 72 74  
002DE3  1               .elseif .defined(OSI)
002DE3  1                       .byte "Start must be <= end!", CR,LF, 0
002DE3  1               .endif
002DE3  1  38                   SEC
002DE4  1  60                   RTS
002DE5  1               @rangeOkay:
002DE5  1  18                   CLC
002DE6  1  60                   RTS
002DE7  1               
002DE7  1               ; Option picker. Adapted from "Assembly Cookbook for the Apple II/IIe" by Don Lancaster.
002DE7  1               ; Call with command letter in A.
002DE7  1               ; Registers affected: X
002DE7  1               OPICK:
002DE7  1  A8                   TAY                     ; save A
002DE8  1               ; Convert to upper case so that lowercase commands are accepted
002DE8  1  20 24 2F             JSR ToUpper
002DEB  1  A2 16                LDX #MATCHN             ; Get legal number of matches
002DED  1  DD 03 2E     SCAN:   CMP MATCHFL,X           ; Search for a match
002DF0  1  F0 03                BEQ GOTMCH              ; Found
002DF2  1  CA                   DEX                     ; Try next
002DF3  1  10 F8                BPL SCAN
002DF5  1               
002DF5  1  E8           GOTMCH: INX                     ; Makes zero a miss
002DF6  1  8A                   TXA                     ; Get jump vector
002DF7  1  0A                   ASL A                   ; Double pointer
002DF8  1  AA                   TAX
002DF9  1  BD 1B 2E             LDA JMPFL+1,X           ; Get page address first!
002DFC  1  48                   PHA                     ; and force on stack
002DFD  1  BD 1A 2E             LDA JMPFL,X             ; Get position address
002E00  1  48                   PHA                     ; and force on stack
002E01  1  98                   TYA                     ; restore A
002E02  1  60                   RTS                     ; Jump via forced subroutine return
002E03  1               
002E03  1               ; Matchn holds the number of matches less one.
002E03  1               ; Matchfl holds the legal characters.
002E03  1               ; JMPFL holds the jump vectors (minus 1).
002E03  1               
002E03  1                       MATCHN = JMPFL-MATCHFL-1
002E03  1               
002E03  1               MATCHFL:
002E03  1               .if .defined(APPLE1)
002E03  1                       .byte "$?"
002E03  1               .ifdef MINIASM
002E03  1                       .byte "A"
002E03  1               .endif
002E03  1                       .byte "BCDEFGHIJKLMNORSTUVW:=."
002E03  1               .elseif .defined(APPLE2)
002E03  1                       .byte "$?"
002E03  1               .ifdef MINIASM
002E03  1                       .byte "A"
002E03  1               .endif
002E03  1                       .byte "BCDFGHIJKLNORSTUVW:=."
002E03  1               .elseif .defined(OSI)
002E03  1                       .byte "$?"
002E03  1               .ifdef MINIASM
002E03  1                       .byte "A"
002E03  1               .endif
002E03  1                       .byte "BCDFGHIJKLNORSTUVW:=."
002E03  1               .elseif .defined(KIM1)
002E03  1  24 3F                .byte "$?"
002E05  1               .ifdef MINIASM
002E05  1  41                   .byte "A"
002E06  1               .endif
002E06  1  42 43 44 46          .byte "BCDFGHJKLNORSTUVW:=."
002E0A  1  47 48 4A 4B  
002E0E  1  4C 4E 4F 52  
002E1A  1               .elseif .defined(SBC)
002E1A  1                       .byte "$?"
002E1A  1               .ifdef MINIASM
002E1A  1                       .byte "A"
002E1A  1               .endif
002E1A  1                       .byte "BCDFGHIJKLNORSTUVW:=."
002E1A  1               .endif
002E1A  1               
002E1A  1               JMPFL:
002E1A  1  45 20                .word Invalid-1
002E1C  1  7C 20                .word Monitor-1
002E1E  1  6E 20                .word Help-1
002E20  1               .ifdef MINIASM
002E20  1  7F 20                 .word Assemble-1
002E22  1               .endif
002E22  1  8F 20                .word Breakpoint-1
002E24  1  69 21                .word Copy-1
002E26  1  5D 23                .word Dump-1
002E28  1               .ifdef APPLE1
002E28  1                       .word ACIFW-1
002E28  1               .endif
002E28  1  13 24                .word Fill-1
002E2A  1  23 21                .word Go-1
002E2C  1  C2 20                .word Hex-1
002E2E  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(OSI) .or .defined(SBC)
002E2E  1                       .word Basic-1
002E2E  1               .endif
002E2E  1  FD 28                .word Load-1
002E30  1  A9 28                .word Checksum-1
002E32  1  15 2F                .word ClearScreen-1
002E34  1               .ifdef APPLE1
002E34  1                       .word CFFA1-1
002E34  1               .endif
002E34  1  11 42                .word Info-1
002E36  1  D4 27                .word Options-1
002E38  1  7F 26                .word Registers-1
002E3A  1  1A 22                .word Search-1
002E3C  1  A4 23                .word Test-1
002E3E  1  85 23                .word Unassemble-1
002E40  1  C3 22                .word Verify-1
002E42  1  14 2A                .word Writer-1
002E44  1  2F 26                .word Memory-1
002E46  1  48 28                .word Math-1
002E48  1  DE 3F                .word Trace-1
002E4A  1               
002E4A  1               ; String input routine.
002E4A  1               ; Enter characters from the keyboard terminated in <Return> or <ESC>.
002E4A  1               ; Characters are echoed.
002E4A  1               ; Can be up to 127 characters.
002E4A  1               ; Returns:
002E4A  1               ;   Length stored at IN (doesn't include zero byte).
002E4A  1               ;   Characters stored starting at IN+1
002E4A  1               ;   String is terminated in a 0 byte.
002E4A  1               ;   Carry set if user hit <Esc>, clear if used <Enter> or max string length reached.
002E4A  1               ; Registers changed: A, X
002E4A  1               
002E4A  1               ; List of characters to accept. First byte is the length of the list.
002E4A  1               FilterChars:
002E4A  1  1E 30 31 32          .byte 30, "0123456789ABCDEFabcdef#(),XYxy"
002E4E  1  33 34 35 36  
002E52  1  37 38 39 41  
002E69  1               
002E69  1               GetLine:
002E69  1  A2 00                LDX #0                  ; Initialize index into buffer
002E6B  1               loop:
002E6B  1  20 5B 2B             JSR GetKey              ; Get character from keyboard
002E6E  1  C9 0D                CMP #CR                 ; <Enter> key pressed?
002E70  1  F0 1B                BEQ EnterPressed        ; If so, handle it
002E72  1  C9 1B                CMP #ESC                ; <Esc> key pressed?
002E74  1  F0 18                BEQ EscapePressed       ; If so, handle it
002E76  1               
002E76  1               ; Make sure character is included in the set of filter characters,
002E76  1               ; otherwise ignore it.
002E76  1               
002E76  1  AC 4A 2E             LDY FilterChars         ; Get length of filter chars list
002E79  1               Filter:
002E79  1  D9 4A 2E             CMP FilterChars,Y       ; Compare character from filter list with entered character
002E7C  1  F0 05                BEQ CharOkay            ; If it matched, accept character
002E7E  1  88                   DEY                     ; Move to next character in filter list
002E7F  1  D0 F8                BNE Filter              ; Try next filter char until done
002E81  1  F0 E8                BEQ loop                ; End reached, ignore the character
002E83  1               
002E83  1               CharOkay:
002E83  1               .ifdef ECHO
002E83  1                       JSR PrintChar           ; Echo the key pressed
002E83  1               .endif
002E83  1  9D 01 02             STA IN+1,X              ; Store character in buffer (skip first length byte)
002E86  1  E8                   INX                     ; Advance index into buffer
002E87  1  E0 7E                CPX #$7E                ; Buffer full?
002E89  1  F0 02                BEQ EnterPressed        ; If so, return as if <Enter> was pressed
002E8B  1  D0 DE                BNE loop                ; Always taken
002E8D  1               EnterPressed:
002E8D  1  18                   CLC                     ; Clear carry to indicate <Enter> pressed and fall through
002E8E  1               EscapePressed:
002E8E  1  A9 00                LDA #0
002E90  1  9D 01 02             STA IN+1,X              ; Store 0 at end of buffer
002E93  1  8E 00 02             STX IN                  ; Store length of string
002E96  1  60                   RTS                     ; Return
002E97  1               
002E97  1               ; Variable length hex number input routine.
002E97  1               ; Enter hex bytes from the keyboard terminated in <Return> or <ESC>.
002E97  1               ; Characters are echoed.
002E97  1               ; Can be up to 127 bytes.
002E97  1               ; Returns:
002E97  1               ;   Length stored at IN.
002E97  1               ;   Characters stored starting at IN+1
002E97  1               ; Registers changed: A, X
002E97  1               
002E97  1               GetHexBytes:
002E97  1  A9 01                LDA #1
002E99  1  8D 01 10             STA RETOK               ; Set flag to accept <Return> key
002E9C  1  8D 23 10             STA CHAROK              ; Set flag to accept character input
002E9F  1  A2 00                LDX #0                  ; Initialize index into buffer
002EA1  1               @loop:
002EA1  1  20 C2 2B             JSR GetByte             ; get hex number from keyboard (byte)
002EA4  1  B0 08                BCS @Return             ; Branch if key was <Return>
002EA6  1  9D 01 02             STA IN+1,X              ; Store character in buffer (skip first length byte)
002EA9  1  E8                   INX                     ; Advance index into buffer
002EAA  1  E0 7E                CPX #$7E                ; Buffer full?
002EAC  1  D0 F3                BNE @loop               ; If not, go back and get more input
002EAE  1               @Return:
002EAE  1  8E 00 02             STX IN                  ; Store length of string
002EB1  1  A9 00                LDA #0
002EB3  1  8D 01 10             STA RETOK               ; Clear flag to accept <Return> key
002EB6  1  8D 23 10             STA CHAROK              ; Clear flag to accept character input
002EB9  1  60                   RTS                     ; Return
002EBA  1               
002EBA  1               ; Below came from
002EBA  1               ; http://www.6502.org/source/integers/hex2dec-more.htm
002EBA  1               ; Convert a 16 bit binary value to BCD
002EBA  1               ;
002EBA  1               ; This function converts a 16 bit binary value into a 24 bit BCD. It
002EBA  1               ; works by transferring one bit a time from the source and adding it
002EBA  1               ; into a BCD value that is being doubled on each iteration. As all the
002EBA  1               ; arithmetic is being done in BCD the result is a binary to decimal
002EBA  1               ; conversion. All conversions take 915 clock cycles.
002EBA  1               ;
002EBA  1               ; See BINBCD8 for more details of its operation.
002EBA  1               ;
002EBA  1               ; Andrew Jacobs, 28-Feb-2004
002EBA  1  F8           BINBCD16:    SED                ; Switch to decimal mode
002EBB  1  A9 00                LDA #0                  ; Ensure the result is clear
002EBD  1  8D 04 10             STA BCD+0
002EC0  1  8D 05 10             STA BCD+1
002EC3  1  8D 06 10             STA BCD+2
002EC6  1  A2 10                LDX #16                 ; The number of source bits
002EC8  1  0E 02 10     CNVBIT: ASL BIN+0               ; Shift out one bit
002ECB  1  2E 03 10             ROL BIN+1
002ECE  1  AD 04 10             LDA BCD+0               ; And add into result
002ED1  1  6D 04 10             ADC BCD+0
002ED4  1  8D 04 10             STA BCD+0
002ED7  1  AD 05 10             LDA BCD+1               ; propagating any carry
002EDA  1  6D 05 10             ADC BCD+1
002EDD  1  8D 05 10             STA BCD+1
002EE0  1  AD 06 10             LDA BCD+2               ; ... thru whole result
002EE3  1  6D 06 10             ADC BCD+2
002EE6  1  8D 06 10             STA BCD+2
002EE9  1  CA                   DEX                     ; And repeat for next bit
002EEA  1  D0 DC                BNE CNVBIT
002EEC  1  D8                   CLD                     ; Back to binary
002EED  1  60                   RTS                     ; All Done.
002EEE  1               
002EEE  1               ; Display processor flags
002EEE  1               ; Based on code at http://6502org.wikidot.com/software-output-flags
002EEE  1               
002EEE  1               OUTP:
002EEE  1  AD 1D 10             LDA SAVE_P
002EF1  1  A2 07        P1:     LDX #7
002EF3  1  0A           @1:     ASL
002EF4  1  48                   PHA
002EF5  1  BD 0E 2F             LDA @3,X
002EF8  1  B0 0C                BCS @2
002EFA  1               
002EFA  1               ; Check if lowercase support is enabled or not. If enabled we show
002EFA  1               ; unset bits as lowercase. If no lowercase support, show as a dot.
002EFA  1               
002EFA  1  2C 26 10             BIT OUPPER
002EFD  1  30 05                BMI @Dot
002EFF  1  09 20                ORA #%00100000              ; Toggle letter case
002F01  1  4C 06 2F             JMP @2
002F04  1  A9 2E        @Dot:   LDA #'.'
002F06  1               
002F06  1  20 EC 2C     @2:     JSR PrintChar
002F09  1  68                   PLA
002F0A  1  CA                   DEX
002F0B  1  10 E6                BPL @1
002F0D  1  60                   RTS
002F0E  1  43 5A 49 44  @3: .byte "CZIDB-VN"
002F12  1  42 2D 56 4E  
002F16  1               
002F16  1               ; Clear screen (platform dependent).
002F16  1               ; Registers changed: none
002F16  1               ClearScreen:
002F16  1               .if .defined(APPLE1)
002F16  1               ; Clear screen by printing 24 carriage returns.
002F16  1                       PHA             ; save A
002F16  1                       TXA             ; save X
002F16  1                       PHA
002F16  1                       LDA #CR
002F16  1                       LDX #24
002F16  1                       JSR PrintChars
002F16  1                       PLA             ; restore X
002F16  1                       TAX
002F16  1                       PLA             ; restore A
002F16  1                       RTS
002F16  1               .elseif .defined(APPLE2)
002F16  1                       JMP $FC58       ; Apple II HOME
002F16  1               .elseif .defined(OSI)
002F16  1               ; Clear screen by writing spaces to all video memory.
002F16  1                       PHA             ; save A
002F16  1                       TXA             ; save X
002F16  1                       PHA
002F16  1                       LDX #$FF
002F16  1                       LDA #' '
002F16  1               CLR1:   STA $D000,X
002F16  1                       STA $D100,X
002F16  1                       STA $D200,X
002F16  1                       STA $D300,X
002F16  1                       DEX
002F16  1                       BNE CLR1
002F16  1                       LDA #$65        ; Set cursor position to home
002F16  1                       STA $0200
002F16  1                       PLA             ; restore X
002F16  1                       TAX
002F16  1                       PLA             ; restore A
002F16  1                       RTS
002F16  1               .elseif .defined(KIM1) .or .defined(SBC)
002F16  1               ; Clear screen by printing 40 carriage returns.
002F16  1  48                   PHA             ; save A
002F17  1  8A                   TXA             ; save X
002F18  1  48                   PHA
002F19  1  A9 0D                LDA #CR
002F1B  1  A2 28                LDX #40
002F1D  1  20 5D 2D             JSR PrintChars
002F20  1  68                   PLA             ; restore X
002F21  1  AA                   TAX
002F22  1  68                   PLA             ; restore A
002F23  1  60                   RTS
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if an ACI (Apple Cassette Interface) card is present.
002F24  1               ; Reads the first two bytes of the ROM.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               .ifdef APPLE1
002F24  1               ACIPresent:
002F24  1                       LDA ACI                 ; First firmware byte
002F24  1                       CMP #$A9                ; Should contain $A9
002F24  1                       BNE @NoACI
002F24  1                       LDA ACI+1               ; Second firmware byte
002F24  1                       CMP #$AA                ; Should contain $AA
002F24  1                       BNE @NoACI
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               @NoACI:
002F24  1                       LDA #0
002F24  1                       RTS
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if a CFFA1 (Compact Flash) card is present.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               ; The documented way to check for a CFFA1 is to check for two ID bytes.
002F24  1               ; The documentation says it is addresses $AFFC and $AFFD but the firmware
002F24  1               ; actually uses addresses $AFDC and $AFDD. Further, my CFFA1 board did
002F24  1               ; not have these locations programmed even though firmware on CD-ROM did.
002F24  1               ; I manually wrote these bytes to my EEPROM.
002F24  1               
002F24  1               .ifdef APPLE1
002F24  1               CFFA1Present:
002F24  1                       LDA $AFDC               ; First CFFA1 ID byte
002F24  1                       CMP #$CF                ; Should contain $CF
002F24  1                       BNE @NoCFFA1
002F24  1                       LDA $AFDD               ; First CFFA1 ID byte
002F24  1                       CMP #$FA                ; Should contain $FA
002F24  1                       BNE @NoCFFA1
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               @NoCFFA1:
002F24  1                       LDA #0
002F24  1                       RTS
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if a Replica 1 Multi I/O card is present.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               ; Method is to check the first few 6551 and 6522 registers.
002F24  1               ; This may need some tweaking to work reliably.
002F24  1               ; 6522 checks may only work after a hardware reset.
002F24  1               ;
002F24  1               ; To test for the 6551:
002F24  1               ; Write $00 to $C302, should read back
002F24  1               ; Write $FF to $C302, should read back
002F24  1               ; Write $00 to $C303, should read back
002F24  1               ; Write $FF to $C303, should read back
002F24  1               ; Write $XX to $C301 for programmed reset
002F24  1               ; $C301 should read XXXXX0XX
002F24  1               ; $C302 should read XXX00000
002F24  1               ; To test for the 6522:
002F24  1               ; Write $FF to $C202, should read back
002F24  1               ; Write $00 to $C202, should read back
002F24  1               ; Write $FF to $C203, should read back
002F24  1               ; Write $00 to $C203, should read back
002F24  1               ; Write $AA to $C201, should read back different
002F24  1               ; Write $AA to $C200, should read back different
002F24  1               ; Read $C204 (timer). Read again and data should be different.
002F24  1               
002F24  1               .ifdef APPLE1
002F24  1               MultiIOPresent:
002F24  1                       LDA #$00
002F24  1                       STA $C302
002F24  1                       CMP $C302
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$FF
002F24  1                       STA $C302
002F24  1                       CMP $C302
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$00
002F24  1                       STA $C303
002F24  1                       CMP $C303
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$FF
002F24  1                       STA $C303
002F24  1                       CMP $C303
002F24  1                       BNE @NoMultiIO
002F24  1                       STA $C301
002F24  1                       LDA $C301
002F24  1                       AND #%00000100
002F24  1                       CMP #$00
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA $C302
002F24  1                       AND #%00011111
002F24  1                       CMP #$00
002F24  1                       BNE @NoMultiIO
002F24  1               
002F24  1                       LDA #$FF
002F24  1                       STA $C202
002F24  1                       CMP $C202
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$00
002F24  1                       STA $C202
002F24  1                       CMP $C202
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$FF
002F24  1                       STA $C203
002F24  1                       CMP $C203
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$00
002F24  1                       STA $C203
002F24  1                       CMP $C203
002F24  1                       BNE @NoMultiIO
002F24  1                       LDA #$AA
002F24  1                       STA $C201
002F24  1                       CMP $C201
002F24  1                       BEQ @NoMultiIO
002F24  1                       LDA #$AA
002F24  1                       STA $C200
002F24  1                       CMP $C200
002F24  1                       BEQ @NoMultiIO
002F24  1                       LDA $C204
002F24  1                       CMP $C204
002F24  1                       BEQ @NoMultiIO
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               @NoMultiIO:
002F24  1                       LDA #0
002F24  1                       RTS
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if an Apple II serial port is is present.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               ; Method is to check the first few 6551 registers.
002F24  1               .ifdef APPLE2
002F24  1               SerialPresent:
002F24  1                       LDA #$00
002F24  1                       STA $C09A
002F24  1                       CMP $C09A
002F24  1                       BNE @NoSerial
002F24  1                       LDA #$FF
002F24  1                       STA $C09A
002F24  1                       CMP $C09A
002F24  1                       BNE @NoSerial
002F24  1                       LDA #$00
002F24  1                       STA $C09B
002F24  1                       CMP $C09B
002F24  1                       BNE @NoSerial
002F24  1                       LDA #$FF
002F24  1                       STA $C09B
002F24  1                       CMP $C09B
002F24  1                       BNE @NoSerial
002F24  1                       STA $C099
002F24  1                       LDA $C099
002F24  1                       AND #%00000100
002F24  1                       CMP #$00
002F24  1                       BNE @NoSerial
002F24  1                       LDA $C09A
002F24  1                       AND #%00011111
002F24  1                       CMP #$00
002F24  1                       BNE @NoSerial
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               @NoSerial:
002F24  1                       LDA #0
002F24  1                       RTS
002F24  1               
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if BASIC ROM is present.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               ; Looks for the first three bytes of ROM.
002F24  1               ; It is unlikely but it could possibly not be present (e.g. when running in an Emulator)
002F24  1               
002F24  1               .if .defined(APPLE1)
002F24  1                 BASIC0 = $4C
002F24  1                 BASIC1 = $B0
002F24  1                 BASIC2 = $E2
002F24  1               .elseif .defined(APPLE2)
002F24  1                 BASIC0 = $4C
002F24  1                 BASIC1 = $28
002F24  1                 BASIC2 = $F1
002F24  1               .elseif .defined(OSI) .or .defined(SBC)
002F24  1                 BASIC0 = $A2
002F24  1                 BASIC1 = $FF
002F24  1                 BASIC2 = $86
002F24  1               .endif
002F24  1               
002F24  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(OSI) .or .defined(SBC)
002F24  1               
002F24  1               BASICPresent:
002F24  1                       LDA BASIC               ; First firmware byte
002F24  1                       CMP #BASIC0
002F24  1                       BNE @NoBasic
002F24  1                       LDA BASIC+1             ; Second firmware byte
002F24  1                       CMP #BASIC1
002F24  1                       BNE @NoBasic
002F24  1                       LDA BASIC+2             ; Third firmware byte
002F24  1                       CMP #BASIC2
002F24  1                       BNE @NoBasic
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               @NoBasic:
002F24  1                       LDA #0
002F24  1                       RTS
002F24  1               
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if Krusader ROM present.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               ; Looks for the first thee bytes of ROM.
002F24  1               .ifdef APPLE1
002F24  1               KrusaderPresent:
002F24  1                       LDA $F000
002F24  1                       CMP #$A9
002F24  1                       BNE @NoKrusader
002F24  1                       LDA $F001
002F24  1                       CMP #$03
002F24  1                       BNE @NoKrusader
002F24  1                       LDA $F002
002F24  1                       CMP #$85
002F24  1                       BNE @NoKrusader
002F24  1                  LDA #1
002F24  1                       RTS
002F24  1               @NoKrusader:
002F24  1                       LDA #0
002F24  1                       RTS
002F24  1               .endif
002F24  1               
002F24  1               ; Determines if Woz Mon is present.
002F24  1               ; Returns in A 1 if present, 0 if not.
002F24  1               ; Looks for the first two bytes of ROM.
002F24  1               .ifdef APPLE1
002F24  1               WozMonPresent:
002F24  1                       LDA WOZMON
002F24  1                       CMP #$D8
002F24  1                       BNE @NoWozMon
002F24  1                       LDA WOZMON+1
002F24  1                       CMP #$58
002F24  1                       BNE @NoWozMon
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               @NoWozMon:
002F24  1                       LDA #1
002F24  1                       RTS
002F24  1               .endif
002F24  1               
002F24  1               ; Convert A to uppercase if it is a lowercase letter.
002F24  1               ToUpper:
002F24  1  C9 61                CMP #'a'                ; Is it 'a' or higher?
002F26  1  30 06                BMI @NotLower
002F28  1  C9 7B                CMP #'z'+1              ; Is it 'z' or lower?
002F2A  1  10 02                BPL @NotLower
002F2C  1  29 DF                AND #%11011111          ; Convert to upper case by clearing bit 5
002F2E  1               @NotLower:
002F2E  1  60                   RTS
002F2F  1               
002F2F  1               ; Strings
002F2F  1               
002F2F  1               WelcomeMessage:
002F2F  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(SBC)
002F2F  1                       .byte CR,"JMON Monitor 1.3.6 by Jeff Tranter", CR, 0
002F2F  1               .elseif .defined(OSI)
002F2F  1                       .byte CR,"JMON 1.3.6 by J. Tranter", CR, 0
002F2F  1               .elseif .defined(KIM1)
002F2F  1  0D 0A 4A 4D          .byte CR,LF,"JMON 1.3.6 by J. Tranter",CR,LF,0
002F33  1  4F 4E 20 31  
002F37  1  2E 33 2E 36  
002F4C  1               .endif
002F4C  1               
002F4C  1               ; Help string.
002F4C  1               HelpString:
002F4C  1               .if .defined(APPLE1)
002F4C  1               .ifdef MINIASM
002F4C  1                       .byte "Assemble    A <address>", CR,LF
002F4C  1               .endif
002F4C  1                       .byte "Breakpoint  B <n or ?> <address>", CR,LF
002F4C  1                       .byte "Copy        C <start> <end> <dest>", CR,LF
002F4C  1                       .byte "Dump        D <start>", CR,LF
002F4C  1                       .byte "ACI menu    E", CR,LF
002F4C  1                       .byte "Fill        F <start> <end> <data>...", CR,LF
002F4C  1                       .byte "Go          G <address>", CR,LF
002F4C  1                       .byte "Hex to dec  H <address>", CR,LF
002F4C  1                       .byte "BASIC       I", CR,LF
002F4C  1                       .byte "Load S rec  J", CR,LF
002F4C  1                       .byte "Checksum    K <start> <end>",CR,LF
002F4C  1                       .byte "Clr sCR,LFeen  L", CR,LF
002F4C  1                       .byte "CFFA1 menu  M", CR,LF
002F4C  1                       .byte "Info        N", CR,LF
002F4C  1                       .byte "Options     O", CR,LF
002F4C  1                       .byte "Registers   R", CR,LF
002F4C  1                       .byte "Search      S <start> <end> <data>...", CR,LF
002F4C  1                       .byte "Test        T <start> <end>", CR,LF
002F4C  1                       .byte "Unassemble  U <start>", CR,LF
002F4C  1                       .byte "Verify      V <start> <end> <dest>", CR,LF
002F4C  1                       .byte "Write S rec W <start> <end> <go>",CR,LF
002F4C  1                       .byte "Woz mon     $", CR,LF
002F4C  1                       .byte "Write       : <address> <data>...", CR,LF
002F4C  1                       .byte "Math        = <address> +/- <address>", CR,LF
002F4C  1                       .byte "Trace       .", CR,LF
002F4C  1                       .byte "Help        ?", CR,LF
002F4C  1                       .byte 0
002F4C  1               .elseif .defined(APPLE2)
002F4C  1               .ifdef MINIASM
002F4C  1                       .byte "Assemble    A <address>", CR,LF
002F4C  1               .endif
002F4C  1                       .byte "Breakpoint  B <n or ?> <address>", CR,LF
002F4C  1                       .byte "Copy        C <start> <end> <dest>", CR,LF
002F4C  1                       .byte "Dump        D <start>", CR,LF
002F4C  1                       .byte "Fill        F <start> <end> <data>...", CR,LF
002F4C  1                       .byte "Go          G <address>", CR,LF
002F4C  1                       .byte "Hex to dec  H <address>", CR,LF
002F4C  1                       .byte "BASIC       I", CR,LF
002F4C  1                       .byte "Load S rec  J", CR,LF
002F4C  1                       .byte "Checksum    K <start> <end>",CR,LF
002F4C  1                       .byte "Clr sCR,LFeen  L", CR,LF
002F4C  1                       .byte "Info        N", CR,LF
002F4C  1                       .byte "Options     O", CR,LF
002F4C  1                       .byte "Registers   R", CR,LF
002F4C  1                       .byte "Search      S <start> <end> <data>...", CR,LF
002F4C  1                       .byte "Test        T <start> <end>", CR,LF
002F4C  1                       .byte "Unassemble  U <start>", CR,LF
002F4C  1                       .byte "Verify      V <start> <end> <dest>", CR,LF
002F4C  1                       .byte "Write S rec W <start> <end> <go>",CR,LF
002F4C  1                       .byte "Monitor     $", CR,LF
002F4C  1                       .byte "Write       : <address> <data>...", CR,LF
002F4C  1                       .byte "Math        = <address> +/- <address>", CR,LF
002F4C  1                       .byte "Trace       .", CR,LF
002F4C  1                       .byte "Help        ?", CR,LF
002F4C  1                       .byte 0
002F4C  1               
002F4C  1               .elseif .defined(OSI)
002F4C  1               .ifdef MINIASM
002F4C  1                       .byte "Assemble   A <a>", CR,LF
002F4C  1               .endif
002F4C  1                       .byte "Breakpoint B <n><a>", CR,LF
002F4C  1                       .byte "Copy       C <s><e><d>", CR,LF
002F4C  1                       .byte "Dump       D <s>", CR,LF
002F4C  1                       .byte "Fill       F <s><e><d>.", CR,LF
002F4C  1                       .byte "Go         G <a>", CR,LF
002F4C  1                       .byte "Hex to dec H <a>", CR,LF
002F4C  1                       .byte "BASIC      I", CR,LF
002F4C  1                       .byte "Load Srec  J", CR,LF
002F4C  1                       .byte "Checksum   K <s><e>",CR,LF
002F4C  1                       .byte "Clr sCR,LFeen L", CR,LF
002F4C  1                       .byte "Info       N", CR,LF
002F4C  1                       .byte "Options    O", CR,LF
002F4C  1                       .byte "Registers  R", CR,LF
002F4C  1                       .byte "Search     S <s><e><d>.", CR,LF
002F4C  1                       .byte "Test       T <s><e>", CR,LF
002F4C  1                       .byte "Unassemble U <s>", CR,LF
002F4C  1                       .byte "Verify     V <s><e><d>", CR,LF
002F4C  1                       .byte "Write Srec W <st> <e> <g>",CR,LF
002F4C  1                       .byte "Monitor    $", CR,LF
002F4C  1                       .byte "Write      : <a><d>...", CR,LF
002F4C  1                       .byte "Math       = <a>+/-<a>", CR,LF
002F4C  1                       .byte "Trace      .", CR,LF
002F4C  1                       .byte "Help       ?", CR,LF
002F4C  1                       .byte 0
002F4C  1               
002F4C  1               .elseif .defined(KIM1)
002F4C  1               .ifdef MINIASM
002F4C  1  41 73 73 65          .byte "Assemble    A <address>", CR,LF
002F50  1  6D 62 6C 65  
002F54  1  20 20 20 20  
002F65  1               .endif
002F65  1  42 72 65 61          .byte "Breakpoint  B <n or ?> <address>", CR,LF
002F69  1  6B 70 6F 69  
002F6D  1  6E 74 20 20  
002F87  1  43 6F 70 79          .byte "Copy        C <start> <end> <dest>", CR,LF
002F8B  1  20 20 20 20  
002F8F  1  20 20 20 20  
002FAB  1  44 75 6D 70          .byte "Dump        D <start>", CR,LF
002FAF  1  20 20 20 20  
002FB3  1  20 20 20 20  
002FC2  1  46 69 6C 6C          .byte "Fill        F <start> <end> <data>...", CR,LF
002FC6  1  20 20 20 20  
002FCA  1  20 20 20 20  
002FE9  1  47 6F 20 20          .byte "Go          G <address>", CR,LF
002FED  1  20 20 20 20  
002FF1  1  20 20 20 20  
003002  1  48 65 78 20          .byte "Hex to dec  H <address>", CR,LF
003006  1  74 6F 20 64  
00300A  1  65 63 20 20  
00301B  1  4C 6F 61 64          .byte "Load S rec  J", CR,LF
00301F  1  20 53 20 72  
003023  1  65 63 20 20  
00302A  1  43 68 65 63          .byte "Checksum    K <start> <end>",CR,LF
00302E  1  6B 73 75 6D  
003032  1  20 20 20 20  
003047  1  43 6C 72 20          .byte "Clr sCR,LFeen  L", CR,LF
00304B  1  73 43 52 2C  
00304F  1  4C 46 65 65  
003059  1  49 6E 66 6F          .byte "Info        N", CR,LF
00305D  1  20 20 20 20  
003061  1  20 20 20 20  
003068  1  4F 70 74 69          .byte "Options     O", CR,LF
00306C  1  6F 6E 73 20  
003070  1  20 20 20 20  
003077  1  52 65 67 69          .byte "Registers   R", CR,LF
00307B  1  73 74 65 72  
00307F  1  73 20 20 20  
003086  1  53 65 61 72          .byte "Search      S <start> <end> <data>...", CR,LF
00308A  1  63 68 20 20  
00308E  1  20 20 20 20  
0030AD  1  54 65 73 74          .byte "Test        T <start> <end>", CR,LF
0030B1  1  20 20 20 20  
0030B5  1  20 20 20 20  
0030CA  1  55 6E 61 73          .byte "Unassemble  U <start>", CR,LF
0030CE  1  73 65 6D 62  
0030D2  1  6C 65 20 20  
0030E1  1  56 65 72 69          .byte "Verify      V <start> <end> <dest>", CR,LF
0030E5  1  66 79 20 20  
0030E9  1  20 20 20 20  
003105  1  57 72 69 74          .byte "Write S rec W <start> <end> <go>",CR,LF
003109  1  65 20 53 20  
00310D  1  72 65 63 20  
003127  1  4D 6F 6E 69          .byte "Monitor     $", CR,LF
00312B  1  74 6F 72 20  
00312F  1  20 20 20 20  
003136  1  57 72 69 74          .byte "Write       : <address> <data>...", CR,LF
00313A  1  65 20 20 20  
00313E  1  20 20 20 20  
003159  1  4D 61 74 68          .byte "Math        = <address> +/- <address>", CR,LF
00315D  1  20 20 20 20  
003161  1  20 20 20 20  
003180  1  54 72 61 63          .byte "Trace       .", CR,LF
003184  1  65 20 20 20  
003188  1  20 20 20 20  
00318F  1  48 65 6C 70          .byte "Help        ?", CR,LF
003193  1  20 20 20 20  
003197  1  20 20 20 20  
00319E  1  00                   .byte 0
00319F  1               
00319F  1               .elseif .defined(SBC)
00319F  1               .ifdef MINIASM
00319F  1                       .byte "Assemble    A <address>", CR,LF
00319F  1               .endif
00319F  1                       .byte "Breakpoint  B <n or ?> <address>", CR,LF
00319F  1                       .byte "Copy        C <start> <end> <dest>", CR,LF
00319F  1                       .byte "Dump        D <start>", CR,LF
00319F  1                       .byte "Fill        F <start> <end> <data>...", CR,LF
00319F  1                       .byte "Go          G <address>", CR,LF
00319F  1                       .byte "Hex to dec  H <address>", CR,LF
00319F  1                       .byte "BASIC       I", CR,LF
00319F  1                       .byte "Load S rec  J", CR,LF
00319F  1                       .byte "Checksum    K <start> <end>",CR,LF
00319F  1                       .byte "Clr sCR,LFeen  L", CR,LF
00319F  1                       .byte "Info        N", CR,LF
00319F  1                       .byte "Options     O", CR,LF
00319F  1                       .byte "Registers   R", CR,LF
00319F  1                       .byte "Search      S <start> <end> <data>...", CR,LF
00319F  1                       .byte "Test        T <start> <end>", CR,LF
00319F  1                       .byte "Unassemble  U <start>", CR,LF
00319F  1                       .byte "Verify      V <start> <end> <dest>", CR,LF
00319F  1                       .byte "Write S rec W <start> <end> <go>",CR,LF
00319F  1                       .byte "Write       : <address> <data>...", CR,LF
00319F  1                       .byte "Math        = <address> +/- <address>", CR,LF
00319F  1                       .byte "Trace       .", CR,LF
00319F  1                       .byte "Help        ?", CR,LF
00319F  1                       .byte 0
00319F  1               .endif
00319F  1               
00319F  1               KnownBPString1:
00319F  1  42 72 65 61    .asciiz "Breakpoint "
0031A3  1  6B 70 6F 69  
0031A7  1  6E 74 20 00  
0031AB  1               
0031AB  1               KnownBPString2:
0031AB  1  20 61 74 20    .asciiz " at $"
0031AF  1  24 00        
0031B1  1               
0031B1  1               Type6502String:
0031B1  1  36 35 30 32          .asciiz "6502"
0031B5  1  00           
0031B6  1               
0031B6  1               Type65C02String:
0031B6  1  36 35 43 30          .asciiz "65C02"
0031BA  1  32 00        
0031BC  1               
0031BC  1               Type65816String:
0031BC  1  36 35 38 31          .asciiz "65816"
0031C0  1  36 00        
0031C2  1               
0031C2  1               .if .defined(APPLE1)
0031C2  1               TypeApple1String:
0031C2  1               .elseif .defined(APPLE2)
0031C2  1               TypeAppleIIString:
0031C2  1                       .asciiz "Apple II"
0031C2  1               TypeAppleIIplusString:
0031C2  1                       .asciiz "Apple II+"
0031C2  1               TypeAppleIIeString:
0031C2  1                       .asciiz "Apple //e"
0031C2  1               TypeAppleIIcString:
0031C2  1                       .asciiz "Apple //c"
0031C2  1               TypeAppleUnknown:
0031C2  1                       .asciiz "Unknown"
0031C2  1               .elseif .defined(KIM1)
0031C2  1               TypeKim1String:
0031C2  1  4B 49 4D 2D          .asciiz "KIM-1"
0031C6  1  31 00        
0031C8  1               .elseif .defined(OSI)
0031C8  1               TypeOSIString:
0031C8  1                       .asciiz "OSI"
0031C8  1               .elseif .defined(SBC)
0031C8  1               TypeSBCString:
0031C8  1                       .asciiz "SBC"
0031C8  1               .endif
0031C8  1               
0031C8  1               SInvalidRecord:
0031C8  1  49 6E 76 61          .asciiz "Invalid record"
0031CC  1  6C 69 64 20  
0031D0  1  72 65 63 6F  
0031D7  1               SChecksumError:
0031D7  1  43 68 65 63          .asciiz "Checksum error"
0031DB  1  6B 73 75 6D  
0031DF  1  20 65 72 72  
0031E6  1               SLoading:
0031E6  1  4C 6F 61 64          .asciiz "Loading"
0031EA  1  69 6E 67 00  
0031EE  1               SLoaded:
0031EE  1  4C 6F 61 64          .asciiz "Loaded"
0031F2  1  65 64 00     
0031F5  1               S0String:
0031F5  1  0D 0A 53 30          .byte   CR,LF, "S0030000FC", CR,LF, 0
0031F9  1  30 33 30 30  
0031FD  1  30 30 46 43  
003204  1               
003204  1                 .include "disasm.s"
003204  2               ;
003204  2               ; 6502/65C02/65816 Disassembler
003204  2               ;
003204  2               ; Copyright (C) 2012-2020 by Jeff Tranter <tranter@pobox.com>
003204  2               ;
003204  2               ; Licensed under the Apache License, Version 2.0 (the "License");
003204  2               ; you may not use this file except in compliance with the License.
003204  2               ; You may obtain a copy of the License at
003204  2               ;
003204  2               ;   http://www.apache.org/licenses/LICENSE-2.0
003204  2               ;
003204  2               ; Unless required by applicable law or agreed to in writing, software
003204  2               ; distributed under the License is distributed on an "AS IS" BASIS,
003204  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
003204  2               ; See the License for the specific language governing permissions and
003204  2               ; limitations under the License.
003204  2               ;
003204  2               ; Revision History
003204  2               ; Version Date         Comments
003204  2               ; 0.0     25-Mar-2012  First version started
003204  2               ; 0.9     28-Mar-2012  First public beta version
003204  2               ; 1.0     03-Jul-2012  Added 65816 support
003204  2               
003204  2               ; *** ASSEMBLY TIME OPTIONS ***
003204  2               
003204  2               ; Uncomment this if you don't want instructions that operate on the
003204  2               ; accumulator like ASL to be shown as "ASL A" but instead just "ASL".
003204  2               ; NOACCUMULATOR = 1
003204  2               
003204  2               ; Uncomment this if you want the output to include source code only
003204  2               ; and not the data bytes in memory. This allows the output to be fed
003204  2               ; back to an assembler.
003204  2               ; SOURCEONLY = 1
003204  2               
003204  2               ; Define this if you want 65816 instructions to be disassembled.
003204  2               ; D65816 = 1
003204  2               
003204  2               ; Define this if you want 65C02 instructions to be disassembled.
003204  2               D65C02 = 1
003204  2               
003204  2               ; Define this if you want the WDC and Rockwell-specific bit instructions
003204  2               ; to be disassembled (BBR, BBS, RMB, SMB). This is mutually exclusive
003204  2               ; with the 65816 option.
003204  2               ; ROCKWELL = 1
003204  2               
003204  2               ; Uncomment next line to link with start address of $A000 for Multi I/0 Board EEPROM.
003204  2               ; .org $A000
003204  2               
003204  2               .if .defined(ROCKWELL) .and .defined(D65816)
003204  2               .error "The 65816 and ROCKWELL options are mutually exclusive."
003204  2               .endif
003204  2               
003204  2               ; Instructions. Match indexes into entries in table MNEMONICS1/MENMONICS2.
003204  2                OP_INV = $00
003204  2                OP_ADC = $01
003204  2                OP_AND = $02
003204  2                OP_ASL = $03
003204  2                OP_BCC = $04
003204  2                OP_BCS = $05
003204  2                OP_BEQ = $06
003204  2                OP_BIT = $07
003204  2                OP_BMI = $08
003204  2                OP_BNE = $09
003204  2                OP_BPL = $0A
003204  2                OP_BRK = $0B
003204  2                OP_BVC = $0C
003204  2                OP_BVS = $0D
003204  2                OP_CLC = $0E
003204  2                OP_CLD = $0F
003204  2                OP_CLI = $10
003204  2                OP_CLV = $11
003204  2                OP_CMP = $12
003204  2                OP_CPX = $13
003204  2                OP_CPY = $14
003204  2                OP_DEC = $15
003204  2                OP_DEX = $16
003204  2                OP_DEY = $17
003204  2                OP_EOR = $18
003204  2                OP_INC = $19
003204  2                OP_INX = $1A
003204  2                OP_INY = $1B
003204  2                OP_JMP = $1C
003204  2                OP_JSR = $1D
003204  2                OP_LDA = $1E
003204  2                OP_LDX = $1F
003204  2                OP_LDY = $20
003204  2                OP_LSR = $21
003204  2                OP_NOP = $22
003204  2                OP_ORA = $23
003204  2                OP_PHA = $24
003204  2                OP_PHP = $25
003204  2                OP_PLA = $26
003204  2                OP_PLP = $27
003204  2                OP_ROL = $28
003204  2                OP_ROR = $29
003204  2                OP_RTI = $2A
003204  2                OP_RTS = $2B
003204  2                OP_SBC = $2C
003204  2                OP_SEC = $2D
003204  2                OP_SED = $2E
003204  2                OP_SEI = $2F
003204  2                OP_STA = $30
003204  2                OP_STX = $31
003204  2                OP_STY = $32
003204  2                OP_TAX = $33
003204  2                OP_TAY = $34
003204  2                OP_TSX = $35
003204  2                OP_TXA = $36
003204  2                OP_TXS = $37
003204  2                OP_TYA = $38
003204  2                OP_BBR = $39 ; [65C02 only]
003204  2                OP_BBS = $3A ; [65C02 only]
003204  2                OP_BRA = $3B ; [65C02 only]
003204  2                OP_PHX = $3C ; [65C02 only]
003204  2                OP_PHY = $3D ; [65C02 only]
003204  2                OP_PLX = $3E ; [65C02 only]
003204  2                OP_PLY = $3F ; [65C02 only]
003204  2                OP_RMB = $40 ; [65C02 only]
003204  2                OP_SMB = $41 ; [65C02 only]
003204  2                OP_STZ = $42 ; [65C02 only]
003204  2                OP_TRB = $43 ; [65C02 only]
003204  2                OP_TSB = $44 ; [65C02 only]
003204  2                OP_STP = $45 ; [WDC 65C02 and 65816 only]
003204  2                OP_WAI = $46 ; [WDC 65C02 and 65816 only]
003204  2                OP_BRL = $47 ; [WDC 65816 only]
003204  2                OP_COP = $48 ; [WDC 65816 only]
003204  2                OP_JML = $49 ; [WDC 65816 only]
003204  2                OP_JSL = $4A ; [WDC 65816 only]
003204  2                OP_MVN = $4B ; [WDC 65816 only]
003204  2                OP_MVP = $4C ; [WDC 65816 only]
003204  2                OP_PEA = $4D ; [WDC 65816 only]
003204  2                OP_PEI = $4E ; [WDC 65816 only]
003204  2                OP_PER = $4F ; [WDC 65816 only]
003204  2                OP_PHB = $50 ; [WDC 65816 only]
003204  2                OP_PHD = $51 ; [WDC 65816 only]
003204  2                OP_PHK = $52 ; [WDC 65816 only]
003204  2                OP_PLB = $53 ; [WDC 65816 only]
003204  2                OP_PLD = $54 ; [WDC 65816 only]
003204  2                OP_REP = $56 ; [WDC 65816 only]
003204  2                OP_RTL = $57 ; [WDC 65816 only]
003204  2                OP_SEP = $58 ; [WDC 65816 only]
003204  2                OP_TCD = $59 ; [WDC 65816 only]
003204  2                OP_TCS = $5A ; [WDC 65816 only]
003204  2                OP_TDC = $5B ; [WDC 65816 only]
003204  2                OP_TSC = $5C ; [WDC 65816 only]
003204  2                OP_TXY = $5D ; [WDC 65816 only]
003204  2                OP_TYX = $5E ; [WDC 65816 only]
003204  2                OP_WDM = $5F ; [WDC 65816 only]
003204  2                OP_XBA = $60 ; [WDC 65816 only]
003204  2                OP_XCE = $61 ; [WDC 65816 only]
003204  2               
003204  2               ; Addressing Modes. OPCODES1/OPCODES2 tables list these for each instruction. LENGTHS lists the instruction length for each addressing mode.
003204  2                AM_INVALID = 0                    ; example:
003204  2                AM_IMPLICIT = 1                   ; RTS
003204  2                AM_ACCUMULATOR = 2                ; ASL A
003204  2                AM_IMMEDIATE = 3                  ; LDA #$12
003204  2                AM_ZEROPAGE = 4                   ; LDA $12
003204  2                AM_ZEROPAGE_X = 5                 ; LDA $12,X
003204  2                AM_ZEROPAGE_Y = 6                 ; LDA $12,Y
003204  2                AM_RELATIVE = 7                   ; BNE $FD
003204  2                AM_ABSOLUTE = 8                   ; JSR $1234
003204  2                AM_ABSOLUTE_X = 9                 ; STA $1234,X
003204  2                AM_ABSOLUTE_Y = 10                ; STA $1234,Y
003204  2                AM_INDIRECT = 11                  ; JMP ($1234)
003204  2                AM_INDEXED_INDIRECT = 12          ; LDA ($12,X)
003204  2                AM_INDIRECT_INDEXED = 13          ; LDA ($12),Y
003204  2                AM_INDIRECT_ZEROPAGE = 14         ; LDA ($12) [65C02 only]
003204  2                AM_ABSOLUTE_INDEXED_INDIRECT = 15 ; JMP ($1234,X) [65C02 only]
003204  2                AM_STACK_RELATIVE = 16            ; LDA 3,S [65816 only]
003204  2                AM_DIRECT_PAGE_INDIRECT_LONG = 17 ; LDA [$55] [65816 only]
003204  2                AM_ABSOLUTE_LONG = 18             ; LDA $02F000 [65816 only]
003204  2                AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y = 19 ; LDA (5,S),Y [65816 only]
003204  2                AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y = 20 ; LDA [$55],Y [65816 only]
003204  2                AM_ABSOLUTE_LONG_INDEXED_WITH_X = 21 ; LDA $12D080,X [65816 only]
003204  2                AM_BLOCK_MOVE = 22                ; MVP 0,0 [65816 only]
003204  2                AM_PROGRAM_COUNTER_RELATIVE_LONG = 23 ; BRL JMPLABEL [65816 only]
003204  2                AM_ABSOLUTE_INDIRECT_LONG = 24    ; JMP [$2000] [65816 only]
003204  2               
003204  2               ; *** CODE ***
003204  2               
003204  2               ; Disassemble instruction at address ADDR (low) / ADDR+1 (high). On
003204  2               ; return ADDR/ADDR+1 points to next instruction so it can be called
003204  2               ; again.
003204  2               DISASM:
003204  2  A2 00          LDX #0
003206  2  A1 38          LDA (ADDR,X)          ; get instruction op code
003208  2  8D 09 10       STA OPCODE
00320B  2  30 12          BMI UPPER             ; if bit 7 set, in upper half of table
00320D  2  0A             ASL A                 ; double it since table is two bytes per entry
00320E  2  AA             TAX
00320F  2  BD FA 37       LDA OPCODES1,X        ; get the instruction type (e.g. OP_LDA)
003212  2  8D 0A 10       STA OP                ; store it
003215  2  E8             INX
003216  2  BD FA 37       LDA OPCODES1,X        ; get addressing mode
003219  2  8D 0B 10       STA AM                ; store it
00321C  2  4C 2E 32       JMP AROUND
00321F  2               UPPER:
00321F  2  0A             ASL A                 ; double it since table is two bytes per entry
003220  2  AA             TAX
003221  2  BD FA 38       LDA OPCODES2,X        ; get the instruction type (e.g. OP_LDA)
003224  2  8D 0A 10       STA OP                ; store it
003227  2  E8             INX
003228  2  BD FA 38       LDA OPCODES2,X        ; get addressing mode
00322B  2  8D 0B 10       STA AM                ; store it
00322E  2               AROUND:
00322E  2  AA             TAX                   ; put addressing mode in X
00322F  2  BD E1 37       LDA LENGTHS,X         ; get instruction length given addressing mode
003232  2  8D 0C 10       STA LEN               ; store it
003235  2               
003235  2               ; Handle 16-bit modes of 65816
003235  2               ; When M=0 (16-bit accumulator) the following instructions take an extra byte:
003235  2               ; 09 29 49 69 89 A9 C9 E9
003235  2               ; When X=0 (16-bit index) the following instructions take an extra byte:
003235  2               ; A0 A2 C0 E0
003235  2               
003235  2  AD 29 10       LDA MBIT              ; Is M bit zero?
003238  2  D0 2B          BNE TRYX              ; If not, skip adjustment.
00323A  2  AD 09 10       LDA OPCODE            ; See if the opcode is one that needs to be adjusted
00323D  2  C9 09          CMP #$09
00323F  2  F0 1E          BEQ ADJUST
003241  2  C9 29          CMP #$29
003243  2  F0 1A          BEQ ADJUST
003245  2  C9 49          CMP #$49
003247  2  F0 16          BEQ ADJUST
003249  2  C9 69          CMP #$69
00324B  2  F0 12          BEQ ADJUST
00324D  2  C9 89          CMP #$89
00324F  2  F0 0E          BEQ ADJUST
003251  2  C9 A9          CMP #$A9
003253  2  F0 0A          BEQ ADJUST
003255  2  C9 C9          CMP #$C9
003257  2  F0 06          BEQ ADJUST
003259  2  C9 E9          CMP #$E9
00325B  2  F0 02          BEQ ADJUST
00325D  2  D0 06          BNE TRYX
00325F  2               ADJUST:
00325F  2  EE 0C 10       INC LEN               ; Increment length by one
003262  2  4C 7D 32       JMP REPSEP
003265  2               
003265  2               TRYX:
003265  2  AD 2A 10       LDA XBIT              ; Is X bit zero?
003268  2  D0 13          BNE REPSEP            ; If not, skip adjustment.
00326A  2  AD 09 10       LDA OPCODE            ; See if the opcode is one that needs to be adjusted
00326D  2  C9 A0          CMP #$A0
00326F  2  F0 EE          BEQ ADJUST
003271  2  C9 A2          CMP #$A2
003273  2  F0 EA          BEQ ADJUST
003275  2  C9 C0          CMP #$C0
003277  2  F0 E6          BEQ ADJUST
003279  2  C9 E0          CMP #$E0
00327B  2  F0 E2          BEQ ADJUST
00327D  2               
00327D  2               ; Special check for REP and SEP instructions.
00327D  2               ; These set or clear the M and X bits which change the length of some instructions.
00327D  2               
00327D  2               REPSEP:
00327D  2  AD 09 10       LDA OPCODE
003280  2  C9 C2          CMP #$C2              ; Is it REP?
003282  2  D0 20          BNE TRYSEP
003284  2  A0 01          LDY #1
003286  2  B1 38          LDA (ADDR),Y          ; get operand
003288  2  49 FF          EOR #$FF              ; Complement the bits
00328A  2  29 20          AND #%00100000        ; Mask out M bit
00328C  2  4A             LSR                   ; Shift into bit 0
00328D  2  4A             LSR
00328E  2  4A             LSR
00328F  2  4A             LSR
003290  2  4A             LSR
003291  2  8D 29 10       STA MBIT              ; Store it
003294  2  B1 38          LDA (ADDR),Y          ; get operand again
003296  2  49 FF          EOR #$FF              ; Complement the bits
003298  2  29 10          AND #%00010000        ; Mask out X bit
00329A  2  4A             LSR                   ; Shift into bit 0
00329B  2  4A             LSR
00329C  2  4A             LSR
00329D  2  4A             LSR
00329E  2  8D 2A 10       STA XBIT              ; Store it
0032A1  2  4C C1 32       JMP PRADDR
0032A4  2               
0032A4  2               TRYSEP:
0032A4  2  C9 E2          CMP #$E2              ; Is it SEP?
0032A6  2  D0 19          BNE PRADDR
0032A8  2  A0 01          LDY #1
0032AA  2  B1 38          LDA (ADDR),Y          ; get operand
0032AC  2  29 20          AND #%00100000        ; Mask out M bit
0032AE  2  4A             LSR                   ; Shift into bit 0
0032AF  2  4A             LSR
0032B0  2  4A             LSR
0032B1  2  4A             LSR
0032B2  2  4A             LSR
0032B3  2  8D 29 10       STA MBIT              ; Store it
0032B6  2  B1 38          LDA (ADDR),Y          ; get operand again
0032B8  2  29 10          AND #%00010000        ; Mask out X bit
0032BA  2  4A             LSR                   ; Shift into bit 0
0032BB  2  4A             LSR
0032BC  2  4A             LSR
0032BD  2  4A             LSR
0032BE  2  8D 2A 10       STA XBIT              ; Store it
0032C1  2               
0032C1  2               PRADDR:
0032C1  2  A6 38          LDX ADDR
0032C3  2  A4 39          LDY ADDR+1
0032C5  2                 .ifndef SOURCEONLY
0032C5  2  20 0D 2C       JSR PrintAddress      ; print address
0032C8  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0032C8  2  A2 03          LDX #3
0032CA  2  20 55 2D       JSR PrintSpaces       ; then three spaces
0032CD  2               .elseif .defined(OSI)
0032CD  2                 JSR PrintSpace
0032CD  2               .endif
0032CD  2  AD 09 10       LDA OPCODE            ; get instruction op code
0032D0  2  20 D9 2C       JSR PrintByte         ; display the opcode byte
0032D3  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0032D3  2  20 7E 2C       JSR PrintSpace
0032D6  2               .endif
0032D6  2  AD 0C 10       LDA LEN               ; how many bytes in the instruction?
0032D9  2  C9 04          CMP #4
0032DB  2  F0 33          BEQ FOUR
0032DD  2  C9 03          CMP #3
0032DF  2  F0 1B          BEQ THREE
0032E1  2  C9 02          CMP #2
0032E3  2  F0 08          BEQ TWO
0032E5  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0032E5  2  A2 05          LDX #5
0032E7  2               .elseif .defined(OSI)
0032E7  2                 LDX #4
0032E7  2               .endif
0032E7  2  20 55 2D       JSR PrintSpaces
0032EA  2  4C 2F 33       JMP ONE
0032ED  2               TWO:
0032ED  2  A0 01          LDY #1
0032EF  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
0032F1  2  20 D9 2C       JSR PrintByte         ; display it
0032F4  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0032F4  2  A2 03          LDX #3
0032F6  2               .elseif .defined(OSI)
0032F6  2                 LDX #2
0032F6  2               .endif
0032F6  2  20 55 2D       JSR PrintSpaces
0032F9  2  4C 2F 33       JMP ONE
0032FC  2               THREE:
0032FC  2  A0 01          LDY #1
0032FE  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
003300  2  20 D9 2C       JSR PrintByte         ; display it
003303  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
003303  2  20 7E 2C       JSR PrintSpace
003306  2               .endif
003306  2  A0 02          LDY #2
003308  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00330A  2  20 D9 2C       JSR PrintByte         ; display it
00330D  2  4C 2F 33       JMP ONE
003310  2               FOUR:
003310  2  A0 01          LDY #1
003312  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
003314  2  20 D9 2C       JSR PrintByte         ; display it
003317  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
003317  2  20 7E 2C       JSR PrintSpace
00331A  2               .endif
00331A  2  A0 02          LDY #2
00331C  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00331E  2  20 D9 2C       JSR PrintByte         ; display it
003321  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
003321  2  20 7E 2C       JSR PrintSpace
003324  2               .endif
003324  2  A0 03          LDY #3
003326  2  B1 38          LDA (ADDR),Y          ; get 3nd operand byte
003328  2  20 D9 2C       JSR PrintByte         ; display it
00332B  2  A2 01          LDX #1
00332D  2  D0 02          BNE SPC
00332F  2               ONE:
00332F  2                 .endif                ; .ifndef SOURCEONLY
00332F  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00332F  2  A2 04          LDX #4
003331  2               .elseif .defined(OSI)
003331  2                 LDX #1
003331  2               .endif
003331  2               SPC:
003331  2  20 55 2D       JSR PrintSpaces
003334  2  AD 0A 10       LDA OP                ; get the op code
003337  2  C9 55          CMP #$55              ; Is it in the first half of the table?
003339  2  30 14          BMI LOWERM
00333B  2               
00333B  2  0A             ASL A                 ; multiply by 2
00333C  2  18             CLC
00333D  2  6D 0A 10       ADC OP                ; add one more to multiply by 3 since table is three bytes per entry
003340  2  A0 03          LDY #3                ; going to loop 3 times
003342  2  AA             TAX                   ; save index into table
003343  2               MNEM2:
003343  2  BD BB 37       LDA MNEMONICS2+1,X    ; print three chars of mnemonic
003346  2  20 EC 2C       JSR PrintChar
003349  2  E8             INX
00334A  2  88             DEY
00334B  2  D0 F6          BNE MNEM2
00334D  2  F0 12          BEQ AMODE
00334F  2               
00334F  2               LOWERM:
00334F  2  0A             ASL A                 ; multiply by 2
003350  2  18             CLC
003351  2  6D 0A 10       ADC OP                ; add one more to multiply by 3 since table is three bytes per entry
003354  2  A0 03          LDY #3                ; going to loop 3 times
003356  2  AA             TAX                   ; save index into table
003357  2               MNEM1:
003357  2  BD BB 36       LDA MNEMONICS1,X      ; print three chars of mnemonic
00335A  2  20 EC 2C       JSR PrintChar
00335D  2  E8             INX
00335E  2  88             DEY
00335F  2  D0 F6          BNE MNEM1
003361  2               
003361  2               ; Display any operands based on addressing mode
003361  2               AMODE:
003361  2  AD 0A 10       LDA OP                ; is it RMB or SMB?
003364  2  C9 40          CMP #OP_RMB
003366  2  F0 04          BEQ DOMB
003368  2  C9 41          CMP #OP_SMB
00336A  2  D0 1E          BNE TRYBB
00336C  2               DOMB:
00336C  2  AD 09 10       LDA OPCODE            ; get the op code
00336F  2  29 70          AND #$70              ; Upper 3 bits is the bit number
003371  2  4A             LSR
003372  2  4A             LSR
003373  2  4A             LSR
003374  2  4A             LSR
003375  2  20 E2 2C       JSR PRHEX
003378  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
003378  2  A2 02          LDX #2
00337A  2               .elseif .defined(OSI)
00337A  2                 LDX #1
00337A  2               .endif
00337A  2  20 55 2D       JSR PrintSpaces
00337D  2  20 FC 2C       JSR PrintDollar
003380  2  A0 01          LDY #1
003382  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003384  2  20 D9 2C       JSR PrintByte         ; display it
003387  2  4C A9 36       JMP DONEOPS
00338A  2               TRYBB:
00338A  2  AD 0A 10       LDA OP                ; is it BBR or BBS?
00338D  2  C9 39          CMP #OP_BBR
00338F  2  F0 04          BEQ DOBB
003391  2  C9 3A          CMP #OP_BBS
003393  2  D0 63          BNE TRYIMP
003395  2               DOBB:                   ; handle special BBRn and BBSn instructions
003395  2  AD 09 10       LDA OPCODE            ; get the op code
003398  2  29 70          AND #$70              ; Upper 3 bits is the bit number
00339A  2  4A             LSR
00339B  2  4A             LSR
00339C  2  4A             LSR
00339D  2  4A             LSR
00339E  2  20 E2 2C       JSR PRHEX
0033A1  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0033A1  2  A2 02          LDX #2
0033A3  2               .elseif .defined(OSI)
0033A3  2                 LDX #1
0033A3  2               .endif
0033A3  2  20 55 2D       JSR PrintSpaces
0033A6  2  20 FC 2C       JSR PrintDollar
0033A9  2  A0 01          LDY #1
0033AB  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
0033AD  2  20 D9 2C       JSR PrintByte         ; display it
0033B0  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0033B0  2  A9 2C          LDA #','
0033B2  2  20 EC 2C       JSR PrintChar
0033B5  2  20 FC 2C       JSR PrintDollar
0033B8  2               .endif
0033B8  2               ; Handle relative addressing
0033B8  2               ; Destination address is Current address + relative (sign extended so upper byte is $00 or $FF) + 3
0033B8  2  A0 02          LDY #2
0033BA  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (relative branch offset)
0033BC  2  8D 0D 10       STA REL               ; save low byte of offset
0033BF  2  30 04          BMI @NEG              ; if negative, need to sign extend
0033C1  2  A9 00          LDA #0                ; high byte is zero
0033C3  2  F0 02          BEQ @ADD
0033C5  2               @NEG:
0033C5  2  A9 FF          LDA #$FF              ; negative offset, high byte if $FF
0033C7  2               @ADD:
0033C7  2  8D 0E 10       STA REL+1             ; save offset high byte
0033CA  2  A5 38          LDA ADDR              ; take adresss
0033CC  2  18             CLC
0033CD  2  6D 0D 10       ADC REL               ; add offset
0033D0  2  8D 0F 10       STA DEZT              ; and store
0033D3  2  A5 39          LDA ADDR+1            ; also high byte (including carry)
0033D5  2  6D 0E 10       ADC REL+1
0033D8  2  8D 10 10       STA DEZT+1
0033DB  2  AD 0F 10       LDA DEZT              ; now need to add 3 more to the address
0033DE  2  18             CLC
0033DF  2  69 03          ADC #3
0033E1  2  8D 0F 10       STA DEZT
0033E4  2  AD 10 10       LDA DEZT+1
0033E7  2  69 00          ADC #0                ; add any carry
0033E9  2  8D 10 10       STA DEZT+1
0033EC  2  20 D9 2C       JSR PrintByte         ; display high byte
0033EF  2  AD 0F 10       LDA DEZT
0033F2  2  20 D9 2C       JSR PrintByte         ; display low byte
0033F5  2  4C A9 36       JMP DONEOPS
0033F8  2               TRYIMP:
0033F8  2  AD 0B 10       LDA AM
0033FB  2  C9 01          CMP #AM_IMPLICIT
0033FD  2  D0 03          BNE TRYINV
0033FF  2  4C A9 36       JMP DONEOPS           ; no operands
003402  2               TRYINV:
003402  2  C9 00          CMP #AM_INVALID
003404  2  D0 03          BNE TRYACC
003406  2  4C A9 36       JMP DONEOPS           ; no operands
003409  2               TRYACC:
003409  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
003409  2  A2 03          LDX #3
00340B  2               .elseif .defined(OSI)
00340B  2                 LDX #1
00340B  2               .endif
00340B  2  20 55 2D       JSR PrintSpaces
00340E  2  C9 02          CMP #AM_ACCUMULATOR
003410  2  D0 08          BNE TRYIMM
003412  2                .ifndef NOACCUMULATOR
003412  2  A9 41          LDA #'A'
003414  2  20 EC 2C       JSR PrintChar
003417  2                .endif                 ; .ifndef NOACCUMULATOR
003417  2  4C A9 36       JMP DONEOPS
00341A  2               TRYIMM:
00341A  2  C9 03          CMP #AM_IMMEDIATE
00341C  2  D0 2A          BNE TRYZP
00341E  2  A9 23          LDA #'#'
003420  2  20 EC 2C       JSR PrintChar
003423  2  20 FC 2C       JSR PrintDollar
003426  2  AD 0C 10       LDA LEN               ; Operand could be 8 or 16-bits
003429  2  C9 03          CMP #3                ; 16-bit?
00342B  2  F0 0A          BEQ IM16              ; Branch if so, otherwise it is 8-bit
00342D  2  A0 01          LDY #1
00342F  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003431  2  20 D9 2C       JSR PrintByte         ; display it
003434  2  4C A9 36       JMP DONEOPS
003437  2               IM16:
003437  2  A0 02          LDY #2
003439  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00343B  2  20 D9 2C       JSR PrintByte         ; display it
00343E  2  A0 01          LDY #1
003440  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003442  2  20 D9 2C       JSR PrintByte         ; display it
003445  2  4C A9 36       JMP DONEOPS
003448  2               
003448  2               TRYZP:
003448  2  C9 04          CMP #AM_ZEROPAGE
00344A  2  D0 0D          BNE TRYZPX
00344C  2  20 FC 2C       JSR PrintDollar
00344F  2  A0 01          LDY #1
003451  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003453  2  20 D9 2C       JSR PrintByte         ; display it
003456  2  4C A9 36       JMP DONEOPS
003459  2               TRYZPX:
003459  2  C9 05          CMP #AM_ZEROPAGE_X
00345B  2  D0 10          BNE TRYZPY
00345D  2  A0 01          LDY #1
00345F  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
003461  2  20 FC 2C       JSR PrintDollar
003464  2  20 D9 2C       JSR PrintByte         ; display it
003467  2  20 04 2D       JSR PrintCommaX
00346A  2  4C A9 36       JMP DONEOPS
00346D  2               TRYZPY:
00346D  2  C9 06          CMP #AM_ZEROPAGE_Y
00346F  2  D0 10          BNE TRYREL
003471  2  A0 01          LDY #1
003473  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
003475  2  20 FC 2C       JSR PrintDollar
003478  2  20 D9 2C       JSR PrintByte         ; display it
00347B  2  20 11 2D       JSR PrintCommaY
00347E  2  4C A9 36       JMP DONEOPS
003481  2               TRYREL:
003481  2  C9 07          CMP #AM_RELATIVE
003483  2  D0 43          BNE TRYABS
003485  2  20 FC 2C       JSR PrintDollar
003488  2               ; Handle relative addressing
003488  2               ; Destination address is Current address + relative (sign extended so upper byte is $00 or $FF) + 2
003488  2  A0 01          LDY #1
00348A  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (relative branch offset)
00348C  2  8D 0D 10       STA REL               ; save low byte of offset
00348F  2  30 04          BMI NEG               ; if negative, need to sign extend
003491  2  A9 00          LDA #0                ; high byte is zero
003493  2  F0 02          BEQ ADD
003495  2               NEG:
003495  2  A9 FF          LDA #$FF              ; negative offset, high byte if $FF
003497  2               ADD:
003497  2  8D 0E 10       STA REL+1             ; save offset high byte
00349A  2  A5 38          LDA ADDR              ; take adresss
00349C  2  18             CLC
00349D  2  6D 0D 10       ADC REL               ; add offset
0034A0  2  8D 0F 10       STA DEZT              ; and store
0034A3  2  A5 39          LDA ADDR+1            ; also high byte (including carry)
0034A5  2  6D 0E 10       ADC REL+1
0034A8  2  8D 10 10       STA DEZT+1
0034AB  2  AD 0F 10       LDA DEZT              ; now need to add 2 more to the address
0034AE  2  18             CLC
0034AF  2  69 02          ADC #2
0034B1  2  8D 0F 10       STA DEZT
0034B4  2  AD 10 10       LDA DEZT+1
0034B7  2  69 00          ADC #0                ; add any carry
0034B9  2  8D 10 10       STA DEZT+1
0034BC  2  20 D9 2C       JSR PrintByte         ; display high byte
0034BF  2  AD 0F 10       LDA DEZT
0034C2  2  20 D9 2C       JSR PrintByte         ; display low byte
0034C5  2  4C A9 36       JMP DONEOPS
0034C8  2               TRYABS:
0034C8  2  C9 08          CMP #AM_ABSOLUTE
0034CA  2  D0 14          BNE TRYABSX
0034CC  2  20 FC 2C       JSR PrintDollar
0034CF  2  A0 02          LDY #2
0034D1  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
0034D3  2  20 D9 2C       JSR PrintByte         ; display it
0034D6  2  A0 01          LDY #1
0034D8  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0034DA  2  20 D9 2C       JSR PrintByte         ; display it
0034DD  2  4C A9 36       JMP DONEOPS
0034E0  2               TRYABSX:
0034E0  2  C9 09          CMP #AM_ABSOLUTE_X
0034E2  2  D0 17          BNE TRYABSY
0034E4  2  20 FC 2C       JSR PrintDollar
0034E7  2  A0 02          LDY #2
0034E9  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
0034EB  2  20 D9 2C       JSR PrintByte         ; display it
0034EE  2  A0 01          LDY #1
0034F0  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0034F2  2  20 D9 2C       JSR PrintByte         ; display it
0034F5  2  20 04 2D       JSR PrintCommaX
0034F8  2  4C A9 36       JMP DONEOPS
0034FB  2               TRYABSY:
0034FB  2  C9 0A          CMP #AM_ABSOLUTE_Y
0034FD  2  D0 17          BNE TRYIND
0034FF  2  20 FC 2C       JSR PrintDollar
003502  2  A0 02          LDY #2
003504  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
003506  2  20 D9 2C       JSR PrintByte         ; display it
003509  2  A0 01          LDY #1
00350B  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00350D  2  20 D9 2C       JSR PrintByte         ; display it
003510  2  20 11 2D       JSR PrintCommaY
003513  2  4C A9 36       JMP DONEOPS
003516  2               TRYIND:
003516  2  C9 0B          CMP #AM_INDIRECT
003518  2  D0 17          BNE TRYINDXIND
00351A  2  20 2B 2D       JSR PrintLParenDollar
00351D  2  A0 02          LDY #2
00351F  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
003521  2  20 D9 2C       JSR PrintByte         ; display it
003524  2  A0 01          LDY #1
003526  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003528  2  20 D9 2C       JSR PrintByte         ; display it
00352B  2  20 45 2D       JSR PrintRParen
00352E  2  4C A9 36       JMP DONEOPS
003531  2               
003531  2               TRYINDXIND:
003531  2  C9 0C          CMP #AM_INDEXED_INDIRECT
003533  2  D0 13          BNE TRYINDINDX
003535  2  20 2B 2D       JSR PrintLParenDollar
003538  2  A0 01          LDY #1
00353A  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00353C  2  20 D9 2C       JSR PrintByte         ; display it
00353F  2  20 04 2D       JSR PrintCommaX
003542  2  20 45 2D       JSR PrintRParen
003545  2  4C A9 36       JMP DONEOPS
003548  2               TRYINDINDX:
003548  2  C9 0D          CMP #AM_INDIRECT_INDEXED
00354A  2  D0 13          BNE TRYINDZ
00354C  2  20 2B 2D       JSR PrintLParenDollar
00354F  2  A0 01          LDY #1
003551  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003553  2  20 D9 2C       JSR PrintByte         ; display it
003556  2  20 45 2D       JSR PrintRParen
003559  2  20 11 2D       JSR PrintCommaY
00355C  2  4C A9 36       JMP DONEOPS
00355F  2               TRYINDZ:
00355F  2  C9 0E          CMP #AM_INDIRECT_ZEROPAGE ; [65C02 only]
003561  2  D0 10          BNE TRYABINDIND
003563  2  20 2B 2D       JSR PrintLParenDollar
003566  2  A0 01          LDY #1
003568  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00356A  2  20 D9 2C       JSR PrintByte         ; display it
00356D  2  20 45 2D       JSR PrintRParen
003570  2  4C A9 36       JMP DONEOPS
003573  2               TRYABINDIND:
003573  2  C9 0F          CMP #AM_ABSOLUTE_INDEXED_INDIRECT ; [65C02 only]
003575  2  D0 1A          BNE TRYSTACKREL
003577  2  20 2B 2D       JSR PrintLParenDollar
00357A  2  A0 02          LDY #2
00357C  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00357E  2  20 D9 2C       JSR PrintByte         ; display it
003581  2  A0 01          LDY #1
003583  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003585  2  20 D9 2C       JSR PrintByte         ; display it
003588  2  20 04 2D       JSR PrintCommaX
00358B  2  20 45 2D       JSR PrintRParen
00358E  2  4C A9 36       JMP DONEOPS
003591  2               
003591  2               TRYSTACKREL:
003591  2  C9 10          CMP #AM_STACK_RELATIVE ; [WDC 65816 only]
003593  2  D0 10          BNE TRYDPIL
003595  2  A0 01          LDY #1
003597  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
003599  2  20 FC 2C       JSR PrintDollar
00359C  2  20 D9 2C       JSR PrintByte         ; display it
00359F  2  20 1E 2D       JSR PrintCommaS
0035A2  2  4C A9 36       JMP DONEOPS
0035A5  2               
0035A5  2               TRYDPIL:
0035A5  2  C9 11          CMP #AM_DIRECT_PAGE_INDIRECT_LONG ; [WDC 65816 only]
0035A7  2  D0 10          BNE TRYABSLONG
0035A9  2  20 38 2D       JSR PrintLBraceDollar
0035AC  2  A0 01          LDY #1
0035AE  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0035B0  2  20 D9 2C       JSR PrintByte         ; display it
0035B3  2  20 4D 2D       JSR PrintRBrace
0035B6  2  4C A9 36       JMP DONEOPS
0035B9  2               
0035B9  2               TRYABSLONG:
0035B9  2  C9 12          CMP #AM_ABSOLUTE_LONG ; [WDC 65816 only]
0035BB  2  D0 1B          BNE SRIIY
0035BD  2  20 FC 2C       JSR PrintDollar
0035C0  2  A0 03          LDY #3
0035C2  2  B1 38          LDA (ADDR),Y          ; get 3nd operand byte (bank address)
0035C4  2  20 D9 2C       JSR PrintByte         ; display it
0035C7  2  A0 02          LDY #2
0035C9  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
0035CB  2  20 D9 2C       JSR PrintByte         ; display it
0035CE  2  A0 01          LDY #1
0035D0  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0035D2  2  20 D9 2C       JSR PrintByte         ; display it
0035D5  2  4C A9 36       JMP DONEOPS
0035D8  2               
0035D8  2               SRIIY:
0035D8  2  C9 13          CMP #AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; [WDC 65816 only]
0035DA  2  D0 16          BNE DPILIY
0035DC  2  20 2B 2D       JSR PrintLParenDollar
0035DF  2  A0 01          LDY #1
0035E1  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0035E3  2  20 D9 2C       JSR PrintByte         ; display it
0035E6  2  20 1E 2D       JSR PrintCommaS
0035E9  2  20 45 2D       JSR PrintRParen
0035EC  2  20 11 2D       JSR PrintCommaY
0035EF  2  4C A9 36       JMP DONEOPS
0035F2  2               
0035F2  2               DPILIY:
0035F2  2  C9 14          CMP #AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; [WDC 65816 only]
0035F4  2  D0 13          BNE ALIX
0035F6  2  20 38 2D       JSR PrintLBraceDollar
0035F9  2  A0 01          LDY #1
0035FB  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0035FD  2  20 D9 2C       JSR PrintByte         ; display it
003600  2  20 4D 2D       JSR PrintRBrace
003603  2  20 11 2D       JSR PrintCommaY
003606  2  4C A9 36       JMP DONEOPS
003609  2               
003609  2               ALIX:
003609  2  C9 15          CMP #AM_ABSOLUTE_LONG_INDEXED_WITH_X ; [WDC 65816 only]
00360B  2  D0 1E          BNE BLOCKMOVE
00360D  2  20 FC 2C       JSR PrintDollar
003610  2  A0 03          LDY #3
003612  2  B1 38          LDA (ADDR),Y          ; get 3nd operand byte (bank address)
003614  2  20 D9 2C       JSR PrintByte         ; display it
003617  2  A0 02          LDY #2
003619  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00361B  2  20 D9 2C       JSR PrintByte         ; display it
00361E  2  A0 01          LDY #1
003620  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
003622  2  20 D9 2C       JSR PrintByte         ; display it
003625  2  20 04 2D       JSR PrintCommaX
003628  2  4C A9 36       JMP DONEOPS
00362B  2               
00362B  2               BLOCKMOVE:
00362B  2  C9 16          CMP #AM_BLOCK_MOVE ; [WDC 65816 only]
00362D  2  D0 1C          BNE PCRL
00362F  2  20 FC 2C       JSR PrintDollar
003632  2  A0 01          LDY #1
003634  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
003636  2  20 D9 2C       JSR PrintByte         ; display it
003639  2  A9 2C          LDA #','
00363B  2  20 EC 2C       JSR PrintChar
00363E  2  20 FC 2C       JSR PrintDollar
003641  2  A0 02          LDY #2
003643  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
003645  2  20 D9 2C       JSR PrintByte         ; display it
003648  2  4C A9 36       JMP DONEOPS
00364B  2               
00364B  2               PCRL:
00364B  2  C9 17          CMP #AM_PROGRAM_COUNTER_RELATIVE_LONG ; [WDC 65816 only]
00364D  2  D0 3F          BNE AIL
00364F  2  20 FC 2C       JSR PrintDollar
003652  2               ; Handle relative addressing
003652  2               ; Destination address is current address + relative + 3
003652  2  A0 01          LDY #1
003654  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
003656  2  8D 0D 10       STA REL               ; save low byte of offset
003659  2  A0 02          LDY #2
00365B  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00365D  2  8D 0E 10       STA REL+1             ; save offset high byte
003660  2  A5 38          LDA ADDR              ; take adresss
003662  2  18             CLC
003663  2  6D 0D 10       ADC REL               ; add offset
003666  2  8D 0F 10       STA DEZT              ; and store
003669  2  A5 39          LDA ADDR+1            ; also high byte (including carry)
00366B  2  6D 0E 10       ADC REL+1
00366E  2  8D 10 10       STA DEZT+1
003671  2  AD 0F 10       LDA DEZT              ; now need to add 3 more to the address
003674  2  18             CLC
003675  2  69 03          ADC #3
003677  2  8D 0F 10       STA DEZT
00367A  2  AD 10 10       LDA DEZT+1
00367D  2  69 00          ADC #0                ; add any carry
00367F  2  8D 10 10       STA DEZT+1
003682  2  20 D9 2C       JSR PrintByte         ; display high byte
003685  2  AD 0F 10       LDA DEZT
003688  2  20 D9 2C       JSR PrintByte         ; display low byte
00368B  2  4C A9 36       JMP DONEOPS
00368E  2               
00368E  2               AIL:
00368E  2  C9 18          CMP #AM_ABSOLUTE_INDIRECT_LONG ; [WDC 65816 only]
003690  2  D0 17          BNE DONEOPS
003692  2  20 38 2D       JSR PrintLBraceDollar
003695  2  A0 02          LDY #2
003697  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
003699  2  20 D9 2C       JSR PrintByte         ; display it
00369C  2  A0 01          LDY #1
00369E  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
0036A0  2  20 D9 2C       JSR PrintByte         ; display it
0036A3  2  20 4D 2D       JSR PrintRBrace
0036A6  2  4C A9 36       JMP DONEOPS
0036A9  2               
0036A9  2               DONEOPS:
0036A9  2  20 71 2C       JSR PrintCR           ; print a final CR
0036AC  2  A5 38          LDA ADDR              ; update address to next instruction
0036AE  2  18             CLC
0036AF  2  6D 0C 10       ADC LEN
0036B2  2  85 38          STA ADDR
0036B4  2  A5 39          LDA ADDR+1
0036B6  2  69 00          ADC #0                ; to add carry
0036B8  2  85 39          STA ADDR+1
0036BA  2  60             RTS
0036BB  2               
0036BB  2               ; DATA
0036BB  2               
0036BB  2               ; Table of instruction strings. 3 bytes per table entry
0036BB  2                .export MNEMONICS1
0036BB  2               MNEMONICS:
0036BB  2               MNEMONICS1:
0036BB  2  3F 3F 3F      .byte "???" ; $00
0036BE  2  41 44 43      .byte "ADC" ; $01
0036C1  2  41 4E 44      .byte "AND" ; $02
0036C4  2  41 53 4C      .byte "ASL" ; $03
0036C7  2  42 43 43      .byte "BCC" ; $04
0036CA  2  42 43 53      .byte "BCS" ; $05
0036CD  2  42 45 51      .byte "BEQ" ; $06
0036D0  2  42 49 54      .byte "BIT" ; $07
0036D3  2  42 4D 49      .byte "BMI" ; $08
0036D6  2  42 4E 45      .byte "BNE" ; $09
0036D9  2  42 50 4C      .byte "BPL" ; $0A
0036DC  2  42 52 4B      .byte "BRK" ; $0B
0036DF  2  42 56 43      .byte "BVC" ; $0C
0036E2  2  42 56 53      .byte "BVS" ; $0D
0036E5  2  43 4C 43      .byte "CLC" ; $0E
0036E8  2  43 4C 44      .byte "CLD" ; $0F
0036EB  2  43 4C 49      .byte "CLI" ; $10
0036EE  2  43 4C 56      .byte "CLV" ; $11
0036F1  2  43 4D 50      .byte "CMP" ; $12
0036F4  2  43 50 58      .byte "CPX" ; $13
0036F7  2  43 50 59      .byte "CPY" ; $14
0036FA  2  44 45 43      .byte "DEC" ; $15
0036FD  2  44 45 58      .byte "DEX" ; $16
003700  2  44 45 59      .byte "DEY" ; $17
003703  2  45 4F 52      .byte "EOR" ; $18
003706  2  49 4E 43      .byte "INC" ; $19
003709  2  49 4E 58      .byte "INX" ; $1A
00370C  2  49 4E 59      .byte "INY" ; $1B
00370F  2  4A 4D 50      .byte "JMP" ; $1C
003712  2  4A 53 52      .byte "JSR" ; $1D
003715  2  4C 44 41      .byte "LDA" ; $1E
003718  2  4C 44 58      .byte "LDX" ; $1F
00371B  2  4C 44 59      .byte "LDY" ; $20
00371E  2  4C 53 52      .byte "LSR" ; $21
003721  2  4E 4F 50      .byte "NOP" ; $22
003724  2  4F 52 41      .byte "ORA" ; $23
003727  2  50 48 41      .byte "PHA" ; $24
00372A  2  50 48 50      .byte "PHP" ; $25
00372D  2  50 4C 41      .byte "PLA" ; $26
003730  2  50 4C 50      .byte "PLP" ; $27
003733  2  52 4F 4C      .byte "ROL" ; $28
003736  2  52 4F 52      .byte "ROR" ; $29
003739  2  52 54 49      .byte "RTI" ; $2A
00373C  2  52 54 53      .byte "RTS" ; $2B
00373F  2  53 42 43      .byte "SBC" ; $2C
003742  2  53 45 43      .byte "SEC" ; $2D
003745  2  53 45 44      .byte "SED" ; $2E
003748  2  53 45 49      .byte "SEI" ; $2F
00374B  2  53 54 41      .byte "STA" ; $30
00374E  2  53 54 58      .byte "STX" ; $31
003751  2  53 54 59      .byte "STY" ; $32
003754  2  54 41 58      .byte "TAX" ; $33
003757  2  54 41 59      .byte "TAY" ; $34
00375A  2  54 53 58      .byte "TSX" ; $35
00375D  2  54 58 41      .byte "TXA" ; $36
003760  2  54 58 53      .byte "TXS" ; $37
003763  2  54 59 41      .byte "TYA" ; $38
003766  2  42 42 52      .byte "BBR" ; $39 [65C02 only]
003769  2  42 42 53      .byte "BBS" ; $3A [65C02 only]
00376C  2  42 52 41      .byte "BRA" ; $3B [65C02 only]
00376F  2  50 48 58      .byte "PHX" ; $3C [65C02 only]
003772  2  50 48 59      .byte "PHY" ; $3D [65C02 only]
003775  2  50 4C 58      .byte "PLX" ; $3E [65C02 only]
003778  2  50 4C 59      .byte "PLY" ; $3F [65C02 only]
00377B  2  52 4D 42      .byte "RMB" ; $40 [65C02 only]
00377E  2  53 4D 42      .byte "SMB" ; $41 [65C02 only]
003781  2  53 54 5A      .byte "STZ" ; $42 [65C02 only]
003784  2  54 52 42      .byte "TRB" ; $43 [65C02 only]
003787  2  54 53 42      .byte "TSB" ; $44 [65C02 only]
00378A  2  53 54 50      .byte "STP" ; $45 [WDC 65C02 and 65816 only]
00378D  2  57 41 49      .byte "WAI" ; $46 [WDC 65C02 and 65816 only]
003790  2  42 52 4C      .byte "BRL" ; $47 [WDC 65816 only]
003793  2  43 4F 50      .byte "COP" ; $48 [WDC 65816 only]
003796  2  4A 4D 50      .byte "JMP" ; $49 [WDC 65816 only]
003799  2  4A 53 4C      .byte "JSL" ; $4A [WDC 65816 only]
00379C  2  4D 56 4E      .byte "MVN" ; $4B [WDC 65816 only]
00379F  2  4D 56 50      .byte "MVP" ; $4C [WDC 65816 only]
0037A2  2  50 45 41      .byte "PEA" ; $4D [WDC 65816 only]
0037A5  2  50 45 49      .byte "PEI" ; $4E [WDC 65816 only]
0037A8  2  50 45 52      .byte "PER" ; $4F [WDC 65816 only]
0037AB  2  50 48 42      .byte "PHB" ; $50 [WDC 65816 only]
0037AE  2  50 48 44      .byte "PHD" ; $51 [WDC 65816 only]
0037B1  2  50 48 4B      .byte "PHK" ; $52 [WDC 65816 only]
0037B4  2  50 4C 42      .byte "PLB" ; $53 [WDC 65816 only]
0037B7  2  50 4C 44      .byte "PLD" ; $54 [WDC 65816 only]
0037BA  2               MNEMONICS2:
0037BA  2  3F 3F 3F      .byte "???" ; $55 Unused because index is $FF
0037BD  2  52 45 50      .byte "REP" ; $56 [WDC 65816 only]
0037C0  2  52 54 4C      .byte "RTL" ; $57 [WDC 65816 only]
0037C3  2  53 45 50      .byte "SEP" ; $58 [WDC 65816 only]
0037C6  2  54 43 44      .byte "TCD" ; $59 [WDC 65816 only]
0037C9  2  54 43 53      .byte "TCS" ; $5A [WDC 65816 only]
0037CC  2  54 44 43      .byte "TDC" ; $5B [WDC 65816 only]
0037CF  2  54 53 43      .byte "TSC" ; $5C [WDC 65816 only]
0037D2  2  54 58 59      .byte "TXY" ; $5D [WDC 65816 only]
0037D5  2  54 59 58      .byte "TYX" ; $5E [WDC 65816 only]
0037D8  2  57 44 4D      .byte "WDM" ; $5F [WDC 65816 only]
0037DB  2  58 42 41      .byte "XBA" ; $60 [WDC 65816 only]
0037DE  2  58 43 45      .byte "XCE" ; $61 [WDC 65816 only]
0037E1  2               MNEMONICSEND: ; address of the end of the table
0037E1  2               
0037E1  2               ; Lengths of instructions given an addressing mode. Matches values of AM_*
0037E1  2               ; Assumes 65816 is in 8-bit mode.
0037E1  2               LENGTHS:
0037E1  2  01 01 01 02   .byte 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 4, 2, 2, 4, 3, 3, 3
0037E5  2  02 02 02 02  
0037E9  2  03 03 03 03  
0037FA  2               
0037FA  2               ; Opcodes. Listed in order. Defines the mnemonic and addressing mode.
0037FA  2               ; 2 bytes per table entry
0037FA  2                .export OPCODES1
0037FA  2               OPCODES:
0037FA  2               OPCODES1:
0037FA  2  0B 01         .byte OP_BRK, AM_IMPLICIT           ; $00
0037FC  2               
0037FC  2  23 0C         .byte OP_ORA, AM_INDEXED_INDIRECT   ; $01
0037FE  2               
0037FE  2               .ifdef D65816
0037FE  2                .byte OP_COP, AM_ZEROPAGE           ; $02 [WDC 65816 only]
0037FE  2               .else
0037FE  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $02
003800  2               .endif
003800  2               
003800  2               .ifdef D65816
003800  2                .byte OP_ORA, AM_STACK_RELATIVE     ; $03 [WDC 65816 only]
003800  2               .else
003800  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $03
003802  2               .endif
003802  2               
003802  2               .ifdef D65C02
003802  2  44 04         .byte OP_TSB, AM_ZEROPAGE           ; $04 [65C02 only]
003804  2               .else
003804  2                .byte OP_INV, AM_IMPLICIT           ; $04
003804  2               .endif
003804  2               
003804  2  23 04         .byte OP_ORA, AM_ZEROPAGE           ; $05
003806  2               
003806  2  03 04         .byte OP_ASL, AM_ZEROPAGE           ; $06
003808  2               
003808  2               .ifdef ROCKWELL
003808  2                .byte OP_RMB, AM_ZEROPAGE           ; $07 [65C02 only]
003808  2               .elseif .defined(D65816)
003808  2                .byte OP_ORA, AM_DIRECT_PAGE_INDIRECT_LONG ; $07 [WDC 65816 only]
003808  2               .else
003808  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $07
00380A  2               .endif
00380A  2               
00380A  2  25 01         .byte OP_PHP, AM_IMPLICIT           ; $08
00380C  2               
00380C  2  23 03         .byte OP_ORA, AM_IMMEDIATE          ; $09
00380E  2               
00380E  2  03 02         .byte OP_ASL, AM_ACCUMULATOR        ; $0A
003810  2               
003810  2               .ifdef D65816
003810  2                .byte OP_PHD, AM_IMPLICIT           ; $0B [WDC 65816 only]
003810  2               .else
003810  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $0B
003812  2               .endif
003812  2               
003812  2               .ifdef D65C02
003812  2  44 08         .byte OP_TSB, AM_ABSOLUTE           ; $0C [65C02 only]
003814  2               .else
003814  2                .byte OP_INV, AM_IMPLICIT           ; $0C
003814  2               .endif
003814  2               
003814  2  23 08         .byte OP_ORA, AM_ABSOLUTE           ; $0D
003816  2               
003816  2  03 08         .byte OP_ASL, AM_ABSOLUTE           ; $0E
003818  2               
003818  2               .ifdef ROCKWELL
003818  2                .byte OP_BBR, AM_ABSOLUTE           ; $0F [65C02 only]
003818  2               .elseif .defined(D65816)
003818  2                .byte OP_ORA, AM_ABSOLUTE_LONG      ; $0F [WDC 65816 only]
003818  2               .else
003818  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $0F
00381A  2               .endif
00381A  2               
00381A  2  0A 07         .byte OP_BPL, AM_RELATIVE           ; $10
00381C  2               
00381C  2  23 0D         .byte OP_ORA, AM_INDIRECT_INDEXED   ; $11
00381E  2               
00381E  2               .ifdef D65C02
00381E  2  23 0E         .byte OP_ORA, AM_INDIRECT_ZEROPAGE  ; $12 [65C02 only]
003820  2               .else
003820  2                .byte OP_INV, AM_IMPLICIT           ; $12
003820  2               .endif
003820  2               
003820  2               .ifdef D65816
003820  2                .byte OP_ORA, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $13 [WDC 65816 only]
003820  2               .else
003820  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $12
003822  2               .endif
003822  2               
003822  2               .ifdef D65C02
003822  2  43 04         .byte OP_TRB, AM_ZEROPAGE           ; $14 [65C02 only]
003824  2               .else
003824  2                .byte OP_INV, AM_IMPLICIT           ; $12
003824  2               .endif
003824  2               
003824  2  23 05         .byte OP_ORA, AM_ZEROPAGE_X         ; $15
003826  2               
003826  2  03 05         .byte OP_ASL, AM_ZEROPAGE_X         ; $16
003828  2               
003828  2               .ifdef ROCKWELL
003828  2                .byte OP_RMB, AM_ZEROPAGE           ; $17 [65C02 only]
003828  2               .elseif .defined(D65816)
003828  2                .byte OP_ORA, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $17 [WDC 65816 only]
003828  2               .else
003828  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $17
00382A  2               .endif
00382A  2               
00382A  2  0E 01         .byte OP_CLC, AM_IMPLICIT           ; $18
00382C  2               
00382C  2  23 0A         .byte OP_ORA, AM_ABSOLUTE_Y         ; $19
00382E  2               
00382E  2               .ifdef D65C02
00382E  2  19 02         .byte OP_INC, AM_ACCUMULATOR        ; $1A [65C02 only]
003830  2               .else
003830  2                .byte OP_INV, AM_IMPLICIT           ; $1A
003830  2               .endif
003830  2               
003830  2               .ifdef D65816
003830  2                .byte OP_TCS, AM_IMPLICIT           ; $1B [WDC 65816 only]
003830  2               .else
003830  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $1B
003832  2               .endif
003832  2               
003832  2               .ifdef D65C02
003832  2  43 08         .byte OP_TRB, AM_ABSOLUTE           ; $1C [65C02 only]
003834  2               .else
003834  2                .byte OP_INV, AM_IMPLICIT           ; $1C
003834  2               .endif
003834  2               
003834  2  23 09         .byte OP_ORA, AM_ABSOLUTE_X         ; $1D
003836  2               
003836  2  03 09         .byte OP_ASL, AM_ABSOLUTE_X         ; $1E
003838  2               
003838  2               .ifdef ROCKWELL
003838  2                .byte OP_BBR, AM_ABSOLUTE           ; $1F [65C02 only]
003838  2               .elseif .defined(D65816)
003838  2                .byte OP_ORA, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $1F [WDC 65816 only]
003838  2               .else
003838  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $1F
00383A  2               .endif
00383A  2               
00383A  2  1D 08         .byte OP_JSR, AM_ABSOLUTE           ; $20
00383C  2               
00383C  2  02 0C         .byte OP_AND, AM_INDEXED_INDIRECT   ; $21
00383E  2               
00383E  2  1D 12         .byte OP_JSR, AM_ABSOLUTE_LONG      ; $22
003840  2               
003840  2  02 10         .byte OP_AND, AM_STACK_RELATIVE     ; $23
003842  2               
003842  2  07 04         .byte OP_BIT, AM_ZEROPAGE           ; $24
003844  2               
003844  2  02 04         .byte OP_AND, AM_ZEROPAGE           ; $25
003846  2               
003846  2  28 04         .byte OP_ROL, AM_ZEROPAGE           ; $26
003848  2               
003848  2               .ifdef ROCKWELL
003848  2                .byte OP_RMB, AM_ZEROPAGE           ; $27 [65C02 only]
003848  2               .elseif .defined (D65816)
003848  2                .byte OP_AND, AM_DIRECT_PAGE_INDIRECT_LONG ; $27 [WDC 65816 only]
003848  2               .else
003848  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $27
00384A  2               .endif
00384A  2               
00384A  2  27 01         .byte OP_PLP, AM_IMPLICIT           ; $28
00384C  2               
00384C  2  02 03         .byte OP_AND, AM_IMMEDIATE          ; $29
00384E  2               
00384E  2  28 02         .byte OP_ROL, AM_ACCUMULATOR        ; $2A
003850  2               
003850  2               .ifdef D65816
003850  2                .byte OP_PLD, AM_IMPLICIT           ; $2B [WDC 65816 only]
003850  2               .else
003850  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $2B
003852  2               .endif
003852  2               
003852  2  07 08         .byte OP_BIT, AM_ABSOLUTE           ; $2C
003854  2               
003854  2  02 08         .byte OP_AND, AM_ABSOLUTE           ; $2D
003856  2               
003856  2  28 08         .byte OP_ROL, AM_ABSOLUTE           ; $2E
003858  2               
003858  2               .ifdef ROCKWELL
003858  2                .byte OP_BBR, AM_ABSOLUTE           ; $2F [65C02 only]
003858  2               .elseif .defined (D65816)
003858  2                .byte OP_AND, AM_ABSOLUTE_LONG      ; $2F [WDC 65816 only]
003858  2               .else
003858  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $2F
00385A  2               .endif
00385A  2               
00385A  2  08 07         .byte OP_BMI, AM_RELATIVE           ; $30
00385C  2               
00385C  2               .ifdef D65C02
00385C  2  02 0D         .byte OP_AND, AM_INDIRECT_INDEXED   ; $31 [65C02 only]
00385E  2               .else
00385E  2                .byte OP_INV, AM_IMPLICIT           ; $31
00385E  2               .endif
00385E  2               
00385E  2               .ifdef D65C02
00385E  2  02 0E         .byte OP_AND, AM_INDIRECT_ZEROPAGE  ; $32 [65C02 only]
003860  2               .else
003860  2                .byte OP_INV, AM_IMPLICIT           ; $32
003860  2               .endif
003860  2               
003860  2               .ifdef D65816
003860  2                .byte OP_AND, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $33 [WDC 65816 only]
003860  2               .else
003860  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $33
003862  2               .endif
003862  2               
003862  2               .ifdef D65C02
003862  2  07 05         .byte OP_BIT, AM_ZEROPAGE_X         ; $34 [65C02 only]
003864  2               .else
003864  2                .byte OP_INV, AM_IMPLICIT           ; $34
003864  2               .endif
003864  2               
003864  2  02 05         .byte OP_AND, AM_ZEROPAGE_X         ; $35
003866  2               
003866  2  28 05         .byte OP_ROL, AM_ZEROPAGE_X         ; $36
003868  2               
003868  2               .ifdef ROCKWELL
003868  2                .byte OP_RMB, AM_ZEROPAGE           ; $37 [65C02 only]
003868  2               .elseif .defined(D65816)
003868  2                .byte OP_AND, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $37 [WDC 65816 only]
003868  2               .else
003868  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $37
00386A  2               .endif
00386A  2               
00386A  2  2D 01         .byte OP_SEC, AM_IMPLICIT           ; $38
00386C  2               
00386C  2  02 0A         .byte OP_AND, AM_ABSOLUTE_Y         ; $39
00386E  2               
00386E  2               .ifdef D65C02
00386E  2  15 02         .byte OP_DEC, AM_ACCUMULATOR        ; $3A [65C02 only]
003870  2               .else
003870  2                .byte OP_INV, AM_IMPLICIT           ; $3A
003870  2               .endif
003870  2               
003870  2               .ifdef D65816
003870  2                .byte OP_TSC, AM_IMPLICIT           ; $3B [WDC 65816 only]
003870  2               .else
003870  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $3B
003872  2               .endif
003872  2               
003872  2               .ifdef D65C02
003872  2  07 09         .byte OP_BIT, AM_ABSOLUTE_X         ; $3C [65C02 only]
003874  2               .else
003874  2                .byte OP_INV, AM_IMPLICIT           ; $3C
003874  2               .endif
003874  2               
003874  2  02 09         .byte OP_AND, AM_ABSOLUTE_X         ; $3D
003876  2               
003876  2  28 09         .byte OP_ROL, AM_ABSOLUTE_X         ; $3E
003878  2               
003878  2               .ifdef ROCKWELL
003878  2                .byte OP_BBR, AM_ABSOLUTE           ; $3F [65C02 only]
003878  2               .elseif .defined(D65816)
003878  2                .byte OP_AND, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $3F [WDC 65816 only]
003878  2               .else
003878  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $3F
00387A  2               .endif
00387A  2               
00387A  2  2A 01         .byte OP_RTI, AM_IMPLICIT           ; $40
00387C  2               
00387C  2  18 0C         .byte OP_EOR, AM_INDEXED_INDIRECT   ; $41
00387E  2               
00387E  2               .ifdef D65816
00387E  2                .byte OP_WDM, AM_ZEROPAGE           ; $42 [WDC 65816 only]
00387E  2               .else
00387E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $42
003880  2               .endif
003880  2               
003880  2               .ifdef D65816
003880  2                .byte OP_EOR, AM_STACK_RELATIVE     ; $43 [WDC 65816 only]
003880  2               .else
003880  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $43
003882  2               .endif
003882  2               
003882  2               .ifdef D65816
003882  2                .byte OP_MVP, AM_BLOCK_MOVE         ; $44 [WDC 65816 only]
003882  2               .else
003882  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $44
003884  2               .endif
003884  2               
003884  2  18 04         .byte OP_EOR, AM_ZEROPAGE           ; $45
003886  2               
003886  2  21 04         .byte OP_LSR, AM_ZEROPAGE           ; $46
003888  2               
003888  2               .ifdef ROCKWELL
003888  2                .byte OP_RMB, AM_ZEROPAGE           ; $47 [65C02 only]
003888  2               .elseif .defined(D65816)
003888  2                .byte OP_EOR, AM_DIRECT_PAGE_INDIRECT_LONG ; $47 [WDC 65816 only]
003888  2               .else
003888  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $47
00388A  2               .endif
00388A  2               
00388A  2  24 01         .byte OP_PHA, AM_IMPLICIT           ; $48
00388C  2               
00388C  2  18 03         .byte OP_EOR, AM_IMMEDIATE          ; $49
00388E  2               
00388E  2  21 02         .byte OP_LSR, AM_ACCUMULATOR        ; $4A
003890  2               
003890  2               .ifdef D65816
003890  2                .byte OP_PHK, AM_IMPLICIT           ; $4B [WDC 65816 only]
003890  2               .else
003890  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4B
003892  2               .endif
003892  2               
003892  2  1C 08         .byte OP_JMP, AM_ABSOLUTE           ; $4C
003894  2               
003894  2  18 08         .byte OP_EOR, AM_ABSOLUTE           ; $4D
003896  2               
003896  2  21 08         .byte OP_LSR, AM_ABSOLUTE           ; $4E
003898  2               
003898  2               .ifdef ROCKWELL
003898  2                .byte OP_BBR, AM_ABSOLUTE           ; $4F [65C02 only]
003898  2               .elseif .defined(D65816)
003898  2                .byte OP_EOR, AM_ABSOLUTE_LONG      ; $4F [WDC 65816 only]
003898  2               .else
003898  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00389A  2               .endif
00389A  2               
00389A  2  0C 07         .byte OP_BVC, AM_RELATIVE           ; $50
00389C  2               
00389C  2  18 0D         .byte OP_EOR, AM_INDIRECT_INDEXED   ; $51
00389E  2               
00389E  2               .ifdef D65C02
00389E  2  18 0E         .byte OP_EOR, AM_INDIRECT_ZEROPAGE  ; $52 [65C02 only]
0038A0  2               .else
0038A0  2                .byte OP_INV, AM_IMPLICIT           ; $52
0038A0  2               .endif
0038A0  2               
0038A0  2               .ifdef D65816
0038A0  2                .byte OP_EOR, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $53 [WDC 65816 only]
0038A0  2               .else
0038A0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038A2  2               .endif
0038A2  2               
0038A2  2               .ifdef D65816
0038A2  2                .byte OP_MVN, AM_BLOCK_MOVE         ; $54 [WDC 65816 only]
0038A2  2               .else
0038A2  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038A4  2               .endif
0038A4  2               
0038A4  2  18 05         .byte OP_EOR, AM_ZEROPAGE_X         ; $55
0038A6  2               
0038A6  2  21 05         .byte OP_LSR, AM_ZEROPAGE_X         ; $56
0038A8  2               
0038A8  2               .ifdef ROCKWELL
0038A8  2                .byte OP_RMB, AM_ZEROPAGE           ; $57 [65C02 only]
0038A8  2               .elseif .defined(D65816)
0038A8  2                .byte OP_EOR, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $57 [WDC 65816 only]
0038A8  2               .else
0038A8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $57
0038AA  2               .endif
0038AA  2               
0038AA  2  10 01         .byte OP_CLI, AM_IMPLICIT           ; $58
0038AC  2               
0038AC  2  18 0A         .byte OP_EOR, AM_ABSOLUTE_Y         ; $59
0038AE  2               
0038AE  2               .ifdef D65C02
0038AE  2  3D 01         .byte OP_PHY, AM_IMPLICIT           ; $5A [65C02 only]
0038B0  2               .else
0038B0  2                .byte OP_INV, AM_IMPLICIT           ; $5A
0038B0  2               .endif
0038B0  2               
0038B0  2               .ifdef D65816
0038B0  2                .byte OP_TCD, AM_IMPLICIT           ; $5B [WDC 65816 only]
0038B0  2               .else
0038B0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038B2  2               .endif
0038B2  2               
0038B2  2               .ifdef D65816
0038B2  2                .byte OP_JML, AM_ABSOLUTE_LONG      ; $5C [WDC 65816 only]
0038B2  2               .else
0038B2  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038B4  2               .endif
0038B4  2               
0038B4  2  18 09         .byte OP_EOR, AM_ABSOLUTE_X         ; $5D
0038B6  2               
0038B6  2  21 09         .byte OP_LSR, AM_ABSOLUTE_X         ; $5E
0038B8  2               
0038B8  2               .ifdef ROCKWELL
0038B8  2                .byte OP_BBR, AM_ABSOLUTE           ; $5F [65C02 only]
0038B8  2               .elseif .defined(D65816)
0038B8  2                .byte OP_EOR, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $5F [WDC 65816 only]
0038B8  2               .else
0038B8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $5F
0038BA  2               .endif
0038BA  2               
0038BA  2  2B 01         .byte OP_RTS, AM_IMPLICIT           ; $60
0038BC  2               
0038BC  2  01 0C         .byte OP_ADC, AM_INDEXED_INDIRECT   ; $61
0038BE  2               
0038BE  2               .ifdef D65816
0038BE  2                .byte OP_PER, AM_PROGRAM_COUNTER_RELATIVE_LONG ; $62 [WDC 65816 only]
0038BE  2               .else
0038BE  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038C0  2               .endif
0038C0  2               
0038C0  2               .ifdef D65816
0038C0  2                .byte OP_ADC, AM_STACK_RELATIVE     ; $63 [WDC 65816 only]
0038C0  2               .else
0038C0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038C2  2               .endif
0038C2  2               
0038C2  2               .ifdef D65C02
0038C2  2  42 04         .byte OP_STZ, AM_ZEROPAGE           ; $64 [65C02 only]
0038C4  2               .else
0038C4  2                .byte OP_INV, AM_IMPLICIT           ; $64
0038C4  2               .endif
0038C4  2               
0038C4  2  01 04         .byte OP_ADC, AM_ZEROPAGE           ; $65
0038C6  2               
0038C6  2  29 04         .byte OP_ROR, AM_ZEROPAGE           ; $66
0038C8  2               
0038C8  2               .ifdef ROCKWELL
0038C8  2                .byte OP_RMB, AM_ZEROPAGE           ; $67 [65C02 only]
0038C8  2               .elseif .defined(D65816)
0038C8  2                .byte OP_ADC, AM_DIRECT_PAGE_INDIRECT_LONG ; $67 [WDC 65816 only]
0038C8  2               .else
0038C8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $67
0038CA  2               .endif
0038CA  2               
0038CA  2  26 01         .byte OP_PLA, AM_IMPLICIT           ; $68
0038CC  2               
0038CC  2  01 03         .byte OP_ADC, AM_IMMEDIATE          ; $69
0038CE  2               
0038CE  2  29 02         .byte OP_ROR, AM_ACCUMULATOR        ; $6A
0038D0  2               
0038D0  2               .ifdef D65816
0038D0  2                .byte OP_RTL, AM_IMPLICIT           ; $6B [WDC 65816 only]
0038D0  2               .else
0038D0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038D2  2               .endif
0038D2  2               
0038D2  2  1C 0B         .byte OP_JMP, AM_INDIRECT           ; $6C
0038D4  2               
0038D4  2  01 08         .byte OP_ADC, AM_ABSOLUTE           ; $6D
0038D6  2               
0038D6  2  29 08         .byte OP_ROR, AM_ABSOLUTE           ; $6E
0038D8  2               
0038D8  2               .ifdef ROCKWELL
0038D8  2                .byte OP_BBR, AM_ABSOLUTE           ; $6F [65C02 only]
0038D8  2               .elseif .defined(D65816)
0038D8  2                .byte OP_ADC, AM_ABSOLUTE_LONG      ; $6F [WDC 65816 only]
0038D8  2               .else
0038D8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $6F
0038DA  2               .endif
0038DA  2               
0038DA  2  0D 07         .byte OP_BVS, AM_RELATIVE           ; $70
0038DC  2               
0038DC  2  01 0D         .byte OP_ADC, AM_INDIRECT_INDEXED   ; $71
0038DE  2               
0038DE  2               .ifdef D65C02
0038DE  2  01 0E         .byte OP_ADC, AM_INDIRECT_ZEROPAGE  ; $72 [65C02 only]
0038E0  2               .else
0038E0  2                .byte OP_INV, AM_IMPLICIT           ; $4F
0038E0  2               .endif
0038E0  2               
0038E0  2               .ifdef D65816
0038E0  2                .byte OP_ADC, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $73 [WDC 65816 only]
0038E0  2               .else
0038E0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038E2  2               .endif
0038E2  2               
0038E2  2               .ifdef D65C02
0038E2  2  42 05         .byte OP_STZ, AM_ZEROPAGE_X         ; $74 [65C02 only]
0038E4  2               .else
0038E4  2                .byte OP_INV, AM_IMPLICIT           ; $74
0038E4  2               .endif
0038E4  2               
0038E4  2  01 05         .byte OP_ADC, AM_ZEROPAGE_X         ; $75
0038E6  2               
0038E6  2  29 05         .byte OP_ROR, AM_ZEROPAGE_X         ; $76
0038E8  2               
0038E8  2               .ifdef ROCKWELL
0038E8  2                .byte OP_RMB, AM_ZEROPAGE           ; $77 [65C02 only]
0038E8  2               .elseif .defined(D65816)
0038E8  2                .byte OP_ADC, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $77 [WDC 65816 only]
0038E8  2               .else
0038E8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $77
0038EA  2               .endif
0038EA  2               
0038EA  2  2F 01         .byte OP_SEI, AM_IMPLICIT           ; $78
0038EC  2               
0038EC  2  01 0A         .byte OP_ADC, AM_ABSOLUTE_Y         ; $79
0038EE  2               
0038EE  2               .ifdef D65C02
0038EE  2  3F 01         .byte OP_PLY, AM_IMPLICIT           ; $7A [65C02 only]
0038F0  2               .else
0038F0  2                .byte OP_INV, AM_IMPLICIT           ; $7A
0038F0  2               .endif
0038F0  2               
0038F0  2               .ifdef D65816
0038F0  2                .byte OP_TDC, AM_IMPLICIT           ; $7B [WDC 65816 only]
0038F0  2               .else
0038F0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0038F2  2               .endif
0038F2  2               
0038F2  2               .ifdef D65C02
0038F2  2  1C 0F         .byte OP_JMP, AM_ABSOLUTE_INDEXED_INDIRECT ; $7C [65C02 only]
0038F4  2               .else
0038F4  2                .byte OP_INV, AM_IMPLICIT           ; $7C
0038F4  2               .endif
0038F4  2               
0038F4  2  01 09         .byte OP_ADC, AM_ABSOLUTE_X         ; $7D
0038F6  2               
0038F6  2  29 09         .byte OP_ROR, AM_ABSOLUTE_X         ; $7E
0038F8  2               
0038F8  2               .ifdef ROCKWELL
0038F8  2                .byte OP_BBR, AM_ABSOLUTE           ; $7F [65C02 only]
0038F8  2               .elseif .defined(D65816)
0038F8  2                .byte OP_ADC, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $7F [WDC 65816 only]
0038F8  2               .else
0038F8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $7F
0038FA  2               .endif
0038FA  2               
0038FA  2                .export OPCODES2
0038FA  2               
0038FA  2               OPCODES2:
0038FA  2               
0038FA  2               .ifdef D65C02
0038FA  2  3B 07         .byte OP_BRA, AM_RELATIVE           ; $80 [65C02 only]
0038FC  2               .else
0038FC  2                .byte OP_INV, AM_IMPLICIT           ; $80
0038FC  2               .endif
0038FC  2               
0038FC  2  30 0C         .byte OP_STA, AM_INDEXED_INDIRECT   ; $81
0038FE  2               
0038FE  2               .ifdef D65816
0038FE  2                .byte OP_BRL, AM_PROGRAM_COUNTER_RELATIVE_LONG ; $82 [WDC 65816 only]
0038FE  2               .else
0038FE  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003900  2               .endif
003900  2               
003900  2               .ifdef D65816
003900  2                .byte OP_STA, AM_STACK_RELATIVE     ; $83 [WDC 65816 only]
003900  2               .else
003900  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003902  2               .endif
003902  2               
003902  2  32 04         .byte OP_STY, AM_ZEROPAGE           ; $84
003904  2               
003904  2  30 04         .byte OP_STA, AM_ZEROPAGE           ; $85
003906  2               
003906  2  31 04         .byte OP_STX, AM_ZEROPAGE           ; $86
003908  2               
003908  2               .ifdef ROCKWELL
003908  2                .byte OP_SMB, AM_ZEROPAGE           ; $87 [65C02 only]
003908  2               .elseif .defined(D65816)
003908  2                .byte OP_STA, AM_DIRECT_PAGE_INDIRECT_LONG ; $87 [WDC 65816 only]
003908  2               .else
003908  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $87
00390A  2               .endif
00390A  2               
00390A  2  17 01         .byte OP_DEY, AM_IMPLICIT           ; $88
00390C  2               
00390C  2               .ifdef D65C02
00390C  2  07 03         .byte OP_BIT, AM_IMMEDIATE          ; $89 [65C02 only]
00390E  2               .else
00390E  2                .byte OP_INV, AM_IMPLICIT           ; $89
00390E  2               .endif
00390E  2               
00390E  2  36 01         .byte OP_TXA, AM_IMPLICIT           ; $8A
003910  2               
003910  2               .ifdef D65816
003910  2                .byte OP_PHB, AM_IMPLICIT           ; $8B [WDC 65816 only]
003910  2               .else
003910  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003912  2               .endif
003912  2               
003912  2  32 08         .byte OP_STY, AM_ABSOLUTE           ; $8C
003914  2               
003914  2  30 08         .byte OP_STA, AM_ABSOLUTE           ; $8D
003916  2               
003916  2  31 08         .byte OP_STX, AM_ABSOLUTE           ; $8E
003918  2               
003918  2               .ifdef ROCKWELL
003918  2                .byte OP_BBS, AM_ABSOLUTE           ; $8F [65C02 only]
003918  2               .elseif .defined(D65816)
003918  2                .byte OP_STA, AM_ABSOLUTE_LONG      ; $8F [WDC 65816 only]
003918  2               .else
003918  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $8F
00391A  2               .endif
00391A  2               
00391A  2  04 07         .byte OP_BCC, AM_RELATIVE           ; $90
00391C  2               
00391C  2  30 0D         .byte OP_STA, AM_INDIRECT_INDEXED   ; $91
00391E  2               
00391E  2               .ifdef D65C02
00391E  2  30 0E         .byte OP_STA, AM_INDIRECT_ZEROPAGE  ; $92 [65C02 only]
003920  2               .else
003920  2                .byte OP_INV, AM_IMPLICIT           ; $92
003920  2               .endif
003920  2               
003920  2               .ifdef D65816
003920  2                .byte OP_STA, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $93 [WDC 65816 only]
003920  2               .else
003920  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003922  2               .endif
003922  2               
003922  2  32 05         .byte OP_STY, AM_ZEROPAGE_X         ; $94
003924  2               
003924  2  30 05         .byte OP_STA, AM_ZEROPAGE_X         ; $95
003926  2               
003926  2  31 06         .byte OP_STX, AM_ZEROPAGE_Y         ; $96
003928  2               
003928  2               .ifdef ROCKWELL
003928  2                .byte OP_SMB, AM_ZEROPAGE           ; $97 [65C02 only]
003928  2               .elseif .defined(D65816)
003928  2                .byte OP_STA, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $97 [WDC 65816 only]
003928  2               .else
003928  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $97
00392A  2               .endif
00392A  2               
00392A  2  38 01         .byte OP_TYA, AM_IMPLICIT           ; $98
00392C  2               
00392C  2  30 0A         .byte OP_STA, AM_ABSOLUTE_Y         ; $99
00392E  2               
00392E  2  37 01         .byte OP_TXS, AM_IMPLICIT           ; $9A
003930  2               
003930  2               .ifdef D65816
003930  2                .byte OP_TXY, AM_IMPLICIT           ; $9B [WDC 65816 only]
003930  2               .else
003930  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003932  2               .endif
003932  2               
003932  2               .ifdef D65C02
003932  2  42 08         .byte OP_STZ, AM_ABSOLUTE           ; $9C [65C02 only]
003934  2               .else
003934  2                .byte OP_INV, AM_IMPLICIT           ; $9c
003934  2               .endif
003934  2               
003934  2  30 09         .byte OP_STA, AM_ABSOLUTE_X         ; $9D
003936  2               
003936  2               .ifdef D65C02
003936  2  42 09         .byte OP_STZ, AM_ABSOLUTE_X         ; $9E [65C02 only]
003938  2               .else
003938  2                .byte OP_INV, AM_IMPLICIT           ; $9E
003938  2               .endif
003938  2               
003938  2               .ifdef ROCKWELL
003938  2                .byte OP_BBS, AM_ABSOLUTE           ; $9F [65C02 only]
003938  2               .elseif .defined(D65816)
003938  2                .byte OP_STA, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $9F [WDC 65816 only]
003938  2               .else
003938  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00393A  2               .endif
00393A  2               
00393A  2  20 03         .byte OP_LDY, AM_IMMEDIATE          ; $A0
00393C  2               
00393C  2  1E 0C         .byte OP_LDA, AM_INDEXED_INDIRECT   ; $A1
00393E  2               
00393E  2  1F 03         .byte OP_LDX, AM_IMMEDIATE          ; $A2
003940  2               
003940  2               .ifdef D65816
003940  2                .byte OP_LDA, AM_STACK_RELATIVE     ; $A3 [WDC 65816 only]
003940  2               .else
003940  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003942  2               .endif
003942  2               
003942  2  20 04         .byte OP_LDY, AM_ZEROPAGE           ; $A4
003944  2               
003944  2  1E 04         .byte OP_LDA, AM_ZEROPAGE           ; $A5
003946  2               
003946  2  1F 04         .byte OP_LDX, AM_ZEROPAGE           ; $A6
003948  2               
003948  2               .ifdef ROCKWELL
003948  2                .byte OP_SMB, AM_ZEROPAGE           ; $A7 [65C02 only]
003948  2               .elseif .defined(D65816)
003948  2                .byte OP_LDA, AM_DIRECT_PAGE_INDIRECT_LONG ; $A7 [WDC 65816 only]
003948  2               .else
003948  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $A7
00394A  2               .endif
00394A  2               
00394A  2  34 01         .byte OP_TAY, AM_IMPLICIT           ; $A8
00394C  2               
00394C  2  1E 03         .byte OP_LDA, AM_IMMEDIATE          ; $A9
00394E  2               
00394E  2  33 01         .byte OP_TAX, AM_IMPLICIT           ; $AA
003950  2               
003950  2               .ifdef D65816
003950  2                .byte OP_PLB, AM_IMPLICIT           ; $AB [WDC 65816 only]
003950  2               .else
003950  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003952  2               .endif
003952  2               
003952  2  20 08         .byte OP_LDY, AM_ABSOLUTE           ; $AC
003954  2               
003954  2  1E 08         .byte OP_LDA, AM_ABSOLUTE           ; $AD
003956  2               
003956  2  1F 08         .byte OP_LDX, AM_ABSOLUTE           ; $AE
003958  2               
003958  2               .ifdef ROCKWELL
003958  2                .byte OP_BBS, AM_ABSOLUTE           ; $AF [65C02 only]
003958  2               .elseif .defined(D65816)
003958  2                .byte OP_LDA, AM_ABSOLUTE_LONG      ; $AF [WDC 65816 only]
003958  2               .else
003958  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00395A  2               .endif
00395A  2               
00395A  2  05 07         .byte OP_BCS, AM_RELATIVE           ; $B0
00395C  2               
00395C  2  1E 0D         .byte OP_LDA, AM_INDIRECT_INDEXED   ; $B1
00395E  2               
00395E  2               .ifdef D65C02
00395E  2  1E 0E         .byte OP_LDA, AM_INDIRECT_ZEROPAGE  ; $B2 [65C02 only]
003960  2               .else
003960  2                .byte OP_INV, AM_IMPLICIT           ; $B2
003960  2               .endif
003960  2               
003960  2               .ifdef D65816
003960  2                .byte OP_LDA, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $B3 [WDC 65816 only]
003960  2               .else
003960  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003962  2               .endif
003962  2               
003962  2  20 05         .byte OP_LDY, AM_ZEROPAGE_X         ; $B4
003964  2               
003964  2  1E 05         .byte OP_LDA, AM_ZEROPAGE_X         ; $B5
003966  2               
003966  2  1F 06         .byte OP_LDX, AM_ZEROPAGE_Y         ; $B6
003968  2               
003968  2               .ifdef ROCKWELL
003968  2                .byte OP_SMB, AM_ZEROPAGE           ; $B7 [65C02 only]
003968  2               .elseif .defined(D65816)
003968  2                .byte OP_LDA, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $B7 [WDC 65816 only]
003968  2               .else
003968  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $B7
00396A  2               .endif
00396A  2               
00396A  2  11 01         .byte OP_CLV, AM_IMPLICIT           ; $B8
00396C  2               
00396C  2  1E 0A         .byte OP_LDA, AM_ABSOLUTE_Y         ; $B9
00396E  2               
00396E  2  35 01         .byte OP_TSX, AM_IMPLICIT           ; $BA
003970  2               
003970  2               .ifdef D65816
003970  2                .byte OP_TYX, AM_IMPLICIT           ; $BB [WDC 65816 only]
003970  2               .else
003970  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003972  2               .endif
003972  2               
003972  2  20 09         .byte OP_LDY, AM_ABSOLUTE_X         ; $BC
003974  2               
003974  2  1E 09         .byte OP_LDA, AM_ABSOLUTE_X         ; $BD
003976  2               
003976  2  1F 0A         .byte OP_LDX, AM_ABSOLUTE_Y         ; $BE
003978  2               
003978  2               .ifdef ROCKWELL
003978  2                .byte OP_BBS, AM_ABSOLUTE           ; $BF [65C02 only]
003978  2               .elseif .defined(D65816)
003978  2                .byte OP_LDA, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $BF [WDC 65816 only]
003978  2               .else
003978  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $BF
00397A  2               .endif
00397A  2               
00397A  2  14 03         .byte OP_CPY, AM_IMMEDIATE          ; $C0
00397C  2               
00397C  2  12 0C         .byte OP_CMP, AM_INDEXED_INDIRECT   ; $C1
00397E  2               
00397E  2               .ifdef D65816
00397E  2                .byte OP_REP, AM_IMMEDIATE          ; $C2 [WDC 65816 only]
00397E  2               .else
00397E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003980  2               .endif
003980  2               
003980  2               .ifdef D65816
003980  2                .byte OP_CMP, AM_STACK_RELATIVE     ; $C3 [WDC 65816 only]
003980  2               .else
003980  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
003982  2               .endif
003982  2               
003982  2  14 04         .byte OP_CPY, AM_ZEROPAGE           ; $C4
003984  2               
003984  2  12 04         .byte OP_CMP, AM_ZEROPAGE           ; $C5
003986  2               
003986  2  15 04         .byte OP_DEC, AM_ZEROPAGE           ; $C6
003988  2               
003988  2               .ifdef ROCKWELL
003988  2                .byte OP_SMB, AM_ZEROPAGE           ; $C7 [65C02 only]
003988  2               .elseif .defined(D65816)
003988  2                .byte OP_CMP, AM_DIRECT_PAGE_INDIRECT_LONG ; $C7 [WDC 65816 only]
003988  2               .else
003988  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $C7
00398A  2               .endif
00398A  2               
00398A  2  1B 01         .byte OP_INY, AM_IMPLICIT           ; $C8
00398C  2               
00398C  2  12 03         .byte OP_CMP, AM_IMMEDIATE          ; $C9
00398E  2               
00398E  2  16 01         .byte OP_DEX, AM_IMPLICIT           ; $CA
003990  2               
003990  2               .if .defined(D65C02) .or .defined(D65816)
003990  2  46 01         .byte OP_WAI, AM_IMPLICIT           ; $CB [WDC 65C02 and 65816 only]
003992  2               .else
003992  2                .byte OP_INV, AM_IMPLICIT           ; $CB
003992  2               .endif
003992  2               
003992  2  14 08         .byte OP_CPY, AM_ABSOLUTE           ; $CC
003994  2               
003994  2  12 08         .byte OP_CMP, AM_ABSOLUTE           ; $CD
003996  2               
003996  2  15 08         .byte OP_DEC, AM_ABSOLUTE           ; $CE
003998  2               
003998  2               .ifdef ROCKWELL
003998  2                .byte OP_BBS, AM_ABSOLUTE           ; $CF [65C02 only]
003998  2               .elseif .defined(D65816)
003998  2                .byte OP_CMP, AM_ABSOLUTE_LONG      ; $CF [WDC 65816 only]
003998  2               .else
003998  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $CF
00399A  2               .endif
00399A  2               
00399A  2  09 07         .byte OP_BNE, AM_RELATIVE           ; $D0
00399C  2               
00399C  2  12 0D         .byte OP_CMP, AM_INDIRECT_INDEXED   ; $D1
00399E  2               
00399E  2               .ifdef D65C02
00399E  2  12 0E         .byte OP_CMP, AM_INDIRECT_ZEROPAGE  ; $D2 [65C02 only]
0039A0  2               .else
0039A0  2                .byte OP_INV, AM_IMPLICIT           ; $D2
0039A0  2               .endif
0039A0  2               
0039A0  2               .ifdef D65816
0039A0  2                .byte OP_CMP, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $D3 [WDC 65816 only]
0039A0  2               .else
0039A0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039A2  2               .endif
0039A2  2               
0039A2  2               .ifdef D65816
0039A2  2                .byte OP_PEI, AM_INDIRECT_ZEROPAGE  ; $D4 [WDC 65816 only]
0039A2  2               .else
0039A2  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039A4  2               .endif
0039A4  2               
0039A4  2  12 05         .byte OP_CMP, AM_ZEROPAGE_X         ; $D5
0039A6  2               
0039A6  2  15 05         .byte OP_DEC, AM_ZEROPAGE_X         ; $D6
0039A8  2               
0039A8  2               .ifdef ROCKWELL
0039A8  2                .byte OP_SMB, AM_ZEROPAGE           ; $D7 [65C02 only]
0039A8  2               .elseif .defined(D65816)
0039A8  2                .byte OP_CMP, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $D7 [WDC 65816 only]
0039A8  2               .else
0039A8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $D7
0039AA  2               .endif
0039AA  2               
0039AA  2  0F 01         .byte OP_CLD, AM_IMPLICIT           ; $D8
0039AC  2               
0039AC  2  12 0A         .byte OP_CMP, AM_ABSOLUTE_Y         ; $D9
0039AE  2               
0039AE  2               .ifdef D65C02
0039AE  2  3C 01         .byte OP_PHX, AM_IMPLICIT           ; $DA [65C02 only]
0039B0  2               .else
0039B0  2                .byte OP_INV, AM_IMPLICIT           ; $CF
0039B0  2               .endif
0039B0  2               
0039B0  2               .if .defined(D65C02) .or .defined(D65816)
0039B0  2  45 01         .byte OP_STP, AM_IMPLICIT           ; $DB [WDC 65C02 and 65816 only]
0039B2  2               .else
0039B2  2                .byte OP_INV, AM_IMPLICIT           ; $DB
0039B2  2               .endif
0039B2  2               
0039B2  2               .ifdef D65816
0039B2  2                .byte OP_JML, AM_ABSOLUTE_INDIRECT_LONG ; $DC [WDC 65816 only]
0039B2  2               .else
0039B2  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039B4  2               .endif
0039B4  2               
0039B4  2  12 09         .byte OP_CMP, AM_ABSOLUTE_X         ; $DD
0039B6  2               
0039B6  2  15 09         .byte OP_DEC, AM_ABSOLUTE_X         ; $DE
0039B8  2               
0039B8  2               .ifdef ROCKWELL
0039B8  2                .byte OP_BBS, AM_ABSOLUTE           ; $DF [65C02 only]
0039B8  2               .elseif .defined(D65816)
0039B8  2                .byte OP_CMP, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $DF [WDC 65816 only]
0039B8  2               .else
0039B8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $DF
0039BA  2               .endif
0039BA  2               
0039BA  2  13 03         .byte OP_CPX, AM_IMMEDIATE          ; $E0
0039BC  2               
0039BC  2  2C 0C         .byte OP_SBC, AM_INDEXED_INDIRECT   ; $E1
0039BE  2               
0039BE  2               .ifdef D65816
0039BE  2                .byte OP_SEP, AM_IMMEDIATE          ; $E2 [WDC 65816 only]
0039BE  2               .else
0039BE  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039C0  2               .endif
0039C0  2               
0039C0  2               .ifdef D65816
0039C0  2                .byte OP_SBC, AM_STACK_RELATIVE     ; $E3 [WDC 65816 only]
0039C0  2               .else
0039C0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039C2  2               .endif
0039C2  2               
0039C2  2  13 04         .byte OP_CPX, AM_ZEROPAGE           ; $E4
0039C4  2               
0039C4  2  2C 04         .byte OP_SBC, AM_ZEROPAGE           ; $E5
0039C6  2               
0039C6  2  19 04         .byte OP_INC, AM_ZEROPAGE           ; $E6
0039C8  2               
0039C8  2               .ifdef ROCKWELL
0039C8  2                .byte OP_SMB, AM_ZEROPAGE           ; $E7 [65C02 only]
0039C8  2               .elseif .defined(D65816)
0039C8  2                .byte OP_SBC, AM_DIRECT_PAGE_INDIRECT_LONG ; $E7 [WDC 65816 only]
0039C8  2               .else
0039C8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $E7
0039CA  2               .endif
0039CA  2               
0039CA  2  1A 01         .byte OP_INX, AM_IMPLICIT           ; $E8
0039CC  2               
0039CC  2  2C 03         .byte OP_SBC, AM_IMMEDIATE          ; $E9
0039CE  2               
0039CE  2  22 01         .byte OP_NOP, AM_IMPLICIT           ; $EA
0039D0  2               
0039D0  2               .ifdef D65816
0039D0  2                .byte OP_XBA, AM_IMPLICIT           ; $EB [WDC 65816 only]
0039D0  2               .else
0039D0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039D2  2               .endif
0039D2  2               
0039D2  2  13 08         .byte OP_CPX, AM_ABSOLUTE           ; $EC
0039D4  2               
0039D4  2  2C 08         .byte OP_SBC, AM_ABSOLUTE           ; $ED
0039D6  2               
0039D6  2  19 08         .byte OP_INC, AM_ABSOLUTE           ; $EE
0039D8  2               
0039D8  2               .ifdef ROCKWELL
0039D8  2                .byte OP_BBS, AM_ABSOLUTE           ; $EF [65C02 only]
0039D8  2               .elseif .defined(D65816)
0039D8  2                .byte OP_SBC, AM_ABSOLUTE_LONG      ; $EF [WDC 65816 only]
0039D8  2               .else
0039D8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $EF
0039DA  2               .endif
0039DA  2               
0039DA  2  06 07         .byte OP_BEQ, AM_RELATIVE           ; $F0
0039DC  2               
0039DC  2  2C 0D         .byte OP_SBC, AM_INDIRECT_INDEXED   ; $F1
0039DE  2               
0039DE  2               .ifdef D65C02
0039DE  2  2C 0E         .byte OP_SBC, AM_INDIRECT_ZEROPAGE  ; $F2 [65C02 only]
0039E0  2               .else
0039E0  2                .byte OP_INV, AM_IMPLICIT           ; $F2
0039E0  2               .endif
0039E0  2               
0039E0  2               .ifdef D65816
0039E0  2                .byte OP_SBC, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $F3 [WDC 65816 only]
0039E0  2               .else
0039E0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039E2  2               .endif
0039E2  2               
0039E2  2               .ifdef D65816
0039E2  2                .byte OP_PEA, AM_ABSOLUTE           ; $F4 [WDC 65816 only]
0039E2  2               .else
0039E2  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039E4  2               .endif
0039E4  2               
0039E4  2  2C 05         .byte OP_SBC, AM_ZEROPAGE_X         ; $F5
0039E6  2               
0039E6  2  19 05         .byte OP_INC, AM_ZEROPAGE_X         ; $F6
0039E8  2               
0039E8  2               .ifdef ROCKWELL
0039E8  2                .byte OP_SMB, AM_ZEROPAGE           ; $F7 [65C02 only]
0039E8  2               .elseif .defined(D65816)
0039E8  2                .byte OP_SBC, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $F7 [WDC 65816 only]
0039E8  2               .else
0039E8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $F7
0039EA  2               .endif
0039EA  2               
0039EA  2  2E 01         .byte OP_SED, AM_IMPLICIT           ; $F8
0039EC  2               
0039EC  2  2C 0A         .byte OP_SBC, AM_ABSOLUTE_Y         ; $F9
0039EE  2               
0039EE  2               .ifdef D65C02
0039EE  2  3E 01         .byte OP_PLX, AM_IMPLICIT           ; $FA [65C02 only]
0039F0  2               .else
0039F0  2                .byte OP_INV, AM_IMPLICIT           ; $FA
0039F0  2               .endif
0039F0  2               
0039F0  2               .ifdef D65816
0039F0  2                .byte OP_XCE, AM_IMPLICIT           ; $FB [WDC 65816 only]
0039F0  2               .else
0039F0  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039F2  2               .endif
0039F2  2               
0039F2  2               .ifdef D65816
0039F2  2                .byte OP_JSR, AM_ABSOLUTE_INDEXED_INDIRECT ; $FC [WDC 65816 only]
0039F2  2               .else
0039F2  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
0039F4  2               .endif
0039F4  2               
0039F4  2  2C 09         .byte OP_SBC, AM_ABSOLUTE_X         ; $FD
0039F6  2               
0039F6  2  19 09         .byte OP_INC, AM_ABSOLUTE_X         ; $FE
0039F8  2               
0039F8  2               .ifdef ROCKWELL
0039F8  2                .byte OP_BBS, AM_ABSOLUTE           ; $FF [65C02 only]
0039F8  2               .elseif .defined(D65816)
0039F8  2                .byte OP_SBC, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $FF [WDC 65816 only]
0039F8  2               .else
0039F8  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $FF
0039FA  2               .endif
0039FA  2               
0039FA  1               .ifdef MINIASM
0039FA  1                 .include "miniasm.s"
0039FA  2               ;
0039FA  2               ; 6502/65C02 Mini Assembler
0039FA  2               ;
0039FA  2               ; Copyright (C) 2012-2016 by Jeff Tranter <tranter@pobox.com>
0039FA  2               ;
0039FA  2               ; Licensed under the Apache License, Version 2.0 (the "License");
0039FA  2               ; you may not use this file except in compliance with the License.
0039FA  2               ; You may obtain a copy of the License at
0039FA  2               ;
0039FA  2               ;   http://www.apache.org/licenses/LICENSE-2.0
0039FA  2               ;
0039FA  2               ; Unless required by applicable law or agreed to in writing, software
0039FA  2               ; distributed under the License is distributed on an "AS IS" BASIS,
0039FA  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0039FA  2               ; See the License for the specific language governing permissions and
0039FA  2               ; limitations under the License.
0039FA  2               ;
0039FA  2               
0039FA  2               ; Mini assembler syntax format:
0039FA  2               ;
0039FA  2               ; A <address>
0039FA  2               ; XXXX: instruction
0039FA  2               ; XXXX: instruction
0039FA  2               ; XXXX: <Esc>
0039FA  2               ;
0039FA  2               ; example:
0039FA  2               ;
0039FA  2               ; A 6000
0039FA  2               ; 6000: NOP
0039FA  2               ; 6001: LDX #0A
0039FA  2               ; 6003: JSR FFEF
0039FA  2               ; 6006: DEX
0039FA  2               ; 6007: BNE 6003
0039FA  2               ; 6009: <Esc>
0039FA  2               ;
0039FA  2               ; Restrictions:
0039FA  2               ; - no symbols or labels
0039FA  2               ; - all values in hex, 2 or 4 digits
0039FA  2               ; - no backspace or other editing features
0039FA  2               ;
0039FA  2               
0039FA  2               ; Variables used (defined in jmon.s)
0039FA  2               ; ADDR - instruction address
0039FA  2               ; OPCODE - instruction op code
0039FA  2               ; OP - instruction type (OP_*)
0039FA  2               ; LEN -length of instruction
0039FA  2               ; IN - input buffer holding operands
0039FA  2               ; AM - addressing mode (AM_*)
0039FA  2               ; MNEM - hold three letter mnemonic string used by assembler
0039FA  2               ; OPERAND - Holds any operands for assembled instruction (2 bytes)
0039FA  2               
0039FA  2               
0039FA  2               ; Assemble code entered a line at a time.
0039FA  2               ; On entry ADDR contains start address of code.
0039FA  2               ; Registers changed: A, X, Y.
0039FA  2               
0039FA  2               AssembleLine:
0039FA  2  A6 38                LDX ADDR                ; output address
0039FC  2  A4 39                LDY ADDR+1
0039FE  2  20 0D 2C             JSR PrintAddress
003A01  2  A9 3A                LDA #':'                ; Output colon
003A03  2  20 EC 2C             JSR PrintChar
003A06  2  20 7E 2C             JSR PrintSpace          ; And space
003A09  2               
003A09  2               ; Input three letter for mnemonic (filter for valid alphabetic characters). Esc will terminate.
003A09  2               
003A09  2  A2 00                LDX #0                  ; Index into MNEM
003A0B  2               GetMnem:
003A0B  2  20 5B 2B             JSR GetKey              ; Get a character
003A0E  2  C9 1B                CMP #ESC                ; <Esc> key?
003A10  2  F0 37                BEQ EscPressed          ; If so, handle it
003A12  2  20 24 2F             JSR ToUpper
003A15  2  C9 41                CMP #'A'
003A17  2  30 F2                BMI GetMnem             ; Ignore if less than 'A'
003A19  2  C9 5B                CMP #'Z'+1
003A1B  2  10 EE                BPL GetMnem             ; or greater than 'Z'
003A1D  2  9D 2B 10             STA MNEM,X              ; Valid, so store it.
003A20  2               .ifdef ECHO
003A20  2                       JSR PrintChar           ; Echo it
003A20  2               .endif
003A20  2  E8                   INX                     ; Advance index
003A21  2  E0 03                CPX #3                  ; Done?
003A23  2  D0 E6                BNE GetMnem             ; If not, continue until we get 3 chars
003A25  2               
003A25  2  20 26 3F             JSR LookupMnemonic      ; Look up mnemonic to see if it is valid
003A28  2  AD 0A 10             LDA OP                  ; Get the returned opcode
003A2B  2  C9 00                CMP #OP_INV             ; Not valid?
003A2D  2  D0 1D                BNE OpOk                ; Branch if okay
003A2F  2               
003A2F  2  20 71 2C             JSR PrintCR
003A32  2  20 A8 2C             JSR Imprint            ; Not a valid mnemonic
003A35  2  49 6E 76 61          .byte "Invalid instruction", 0
003A39  2  6C 69 64 20  
003A3D  2  69 6E 73 74  
003A49  2               
003A49  2               EscPressed:
003A49  2  4C 71 2C             JMP PrintCR             ; Return via caller
003A4C  2               
003A4C  2               ; Mnemonic is valid. Does instruction use implicit addressing mode (i.e. no operand needed)?
003A4C  2               
003A4C  2               OpOk:
003A4C  2  A9 01                LDA #AM_IMPLICIT
003A4E  2  8D 0B 10             STA AM
003A51  2  20 6D 3F             JSR CheckAddressingModeValid
003A54  2  F0 03                BEQ GetOperands
003A56  2  4C F9 3D             JMP GenerateCode                ; It is implicit, so we can jump to generating the code
003A59  2               
003A59  2               ; Not implicit addressing mode. Need to get operand from user.
003A59  2               
003A59  2               GetOperands:
003A59  2  20 7E 2C             JSR PrintSpace          ; Output a space
003A5C  2  20 69 2E             JSR GetLine             ; Get line of input for operand(s)
003A5F  2  B0 E8                BCS EscPressed          ; Check if cancelled by Esc key
003A61  2               
003A61  2               ; Check for addressing mode. Have already checked for implicit.
003A61  2               
003A61  2               ; AM_ACCUMULATOR, e.g. LSR A
003A61  2               ; Operand is just "A"
003A61  2  AD 00 02             LDA IN                        ; Get length
003A64  2  C9 01                CMP #1                        ; Is it 1?
003A66  2  D0 12                BNE TryImm
003A68  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003A6B  2  20 24 2F             JSR ToUpper
003A6E  2  C9 41                CMP #'A'                      ; Is it 'A'?
003A70  2  D0 08                BNE TryImm
003A72  2  A9 02                LDA #AM_ACCUMULATOR           ; Yes, is is accumulator mode
003A74  2  8D 0B 10             STA AM                        ; Save it
003A77  2  4C F9 3D             JMP GenerateCode
003A7A  2               
003A7A  2               ; AM_IMMEDIATE, e.g. LDA #nn
003A7A  2               ; Operand is '#' followed by 2 hex digits.
003A7A  2               TryImm:
003A7A  2  AD 00 02             LDA IN                        ; Get length
003A7D  2  C9 03                CMP #3                        ; Is it 3?
003A7F  2  D0 2B                BNE TryZeroPage
003A81  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003A84  2  C9 23                CMP #'#'                      ; is it '#'?
003A86  2  D0 24                BNE TryZeroPage
003A88  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003A8B  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003A8E  2  F0 1C                BEQ TryZeroPage
003A90  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003A93  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003A96  2  F0 14                BEQ TryZeroPage
003A98  2  A9 03                LDA #AM_IMMEDIATE             ; Yes, this is immediate mode
003A9A  2  8D 0B 10             STA AM                        ; Save it
003A9D  2  AE 02 02             LDX IN+2                      ; Get operand characters
003AA0  2  AC 03 02             LDY IN+3
003AA3  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003AA6  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003AA9  2  4C F9 3D             JMP GenerateCode
003AAC  2               
003AAC  2               ; AM_ZEROPAGE e.g. LDA nn
003AAC  2               ; Operand is 2 hex digits.
003AAC  2               TryZeroPage:
003AAC  2  AD 00 02             LDA IN                        ; Get length
003AAF  2  C9 02                CMP #2                        ; Is it 2?
003AB1  2  D0 24                BNE TryAbsRel
003AB3  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003AB6  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003AB9  2  F0 1C                BEQ TryAbsRel
003ABB  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003ABE  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003AC1  2  F0 14                BEQ TryAbsRel
003AC3  2  A9 04                LDA #AM_ZEROPAGE              ; Yes, this is zero page
003AC5  2  8D 0B 10             STA AM                        ; Save it
003AC8  2  AE 01 02             LDX IN+1                      ; Get operand characters
003ACB  2  AC 02 02             LDY IN+2
003ACE  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003AD1  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003AD4  2  4C F9 3D             JMP GenerateCode
003AD7  2               
003AD7  2               ; AM_ABSOLUTE, e.g. LDA nnnn or AM_RELATIVE, e.g. BEQ nnnn
003AD7  2               ; Operand is 4 hex digits.
003AD7  2               
003AD7  2               TryAbsRel:
003AD7  2  AD 00 02             LDA IN                        ; Get length
003ADA  2  C9 04                CMP #4                        ; Is it 4?
003ADC  2  D0 52                BNE TryZeroPageX
003ADE  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003AE1  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003AE4  2  F0 4A                BEQ TryZeroPageX
003AE6  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003AE9  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003AEC  2  F0 42                BEQ TryZeroPageX
003AEE  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003AF1  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003AF4  2  F0 3A                BEQ TryZeroPageX
003AF6  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003AF9  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003AFC  2  F0 32                BEQ TryZeroPageX
003AFE  2               
003AFE  2               ; It could be absolute or relative, depending on the instruction.
003AFE  2               ; Test both to see which one, if any, is valid.
003AFE  2               
003AFE  2  A9 08                LDA #AM_ABSOLUTE              ; Try absolute addressing mode
003B00  2  8D 0B 10             STA AM                        ; Save it
003B03  2  20 6D 3F             JSR CheckAddressingModeValid
003B06  2  F0 1B                BEQ TryRelative               ; No, try relative
003B08  2               
003B08  2               Save2Operands:
003B08  2  AE 01 02             LDX IN+1                      ; Get operand characters
003B0B  2  AC 02 02             LDY IN+2
003B0E  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003B11  2  8D 2F 10             STA OPERAND+1                 ; Save it as the operand
003B14  2  AE 03 02             LDX IN+3                      ; Get operand characters
003B17  2  AC 04 02             LDY IN+4
003B1A  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003B1D  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003B20  2  4C F9 3D             JMP GenerateCode
003B23  2               
003B23  2               TryRelative:
003B23  2  A9 07                LDA #AM_RELATIVE              ; Try relative addressing mode
003B25  2  8D 0B 10             STA AM                        ; Save it
003B28  2  20 6D 3F             JSR CheckAddressingModeValid
003B2B  2  F0 03                BEQ TryZeroPageX              ; No, try other modes
003B2D  2  4C 08 3B             JMP Save2Operands
003B30  2               
003B30  2               ; AM_ZEROPAGE_X e.g. LDA nn,X
003B30  2               ; Operand is 2 hex digits followed by ,X
003B30  2               
003B30  2               TryZeroPageX:
003B30  2  AD 00 02             LDA IN                        ; Get length
003B33  2  C9 04                CMP #4                        ; Is it 4?
003B35  2  D0 35                BNE TryZeroPageY
003B37  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003B3A  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003B3D  2  F0 2D                BEQ TryZeroPageY
003B3F  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003B42  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003B45  2  F0 25                BEQ TryZeroPageY
003B47  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003B4A  2  C9 2C                CMP #','                      ; Is it a comma?
003B4C  2  D0 1E                BNE TryZeroPageY
003B4E  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003B51  2  20 24 2F             JSR ToUpper
003B54  2  C9 58                CMP #'X'                      ; Is it an X?
003B56  2  D0 14                BNE TryZeroPageY
003B58  2  A9 05                LDA #AM_ZEROPAGE_X            ; Yes, this is zero page X
003B5A  2  8D 0B 10             STA AM                        ; Save it
003B5D  2  AE 01 02             LDX IN+1                      ; Get operand characters
003B60  2  AC 02 02             LDY IN+2
003B63  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003B66  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003B69  2  4C F9 3D             JMP GenerateCode
003B6C  2               
003B6C  2               ; AM_ZEROPAGE_Y e.g. LDA nn,Y
003B6C  2               ; 2 hex digits followed by ,Y
003B6C  2               TryZeroPageY:
003B6C  2  AD 00 02             LDA IN                        ; Get length
003B6F  2  C9 04                CMP #4                        ; Is it 4?
003B71  2  D0 35                BNE TryAbsoluteX
003B73  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003B76  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003B79  2  F0 2D                BEQ TryAbsoluteX
003B7B  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003B7E  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003B81  2  F0 25                BEQ TryAbsoluteX
003B83  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003B86  2  C9 2C                CMP #','                      ; Is it a comma?
003B88  2  D0 1E                BNE TryAbsoluteX
003B8A  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003B8D  2  20 24 2F             JSR ToUpper
003B90  2  C9 59                CMP #'Y'                      ; Is it an Y?
003B92  2  D0 14                BNE TryAbsoluteX
003B94  2  A9 06                LDA #AM_ZEROPAGE_Y            ; Yes, this is zero page Y
003B96  2  8D 0B 10             STA AM                        ; Save it
003B99  2  AE 01 02             LDX IN+1                      ; Get operand characters
003B9C  2  AC 02 02             LDY IN+2
003B9F  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003BA2  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003BA5  2  4C F9 3D             JMP GenerateCode
003BA8  2               
003BA8  2               ; AM_ABSOLUTE_X, e.g. LDA nnnn,X
003BA8  2               ; 4 hex digits followed by ,X
003BA8  2               TryAbsoluteX:
003BA8  2  AD 00 02             LDA IN                        ; Get length
003BAB  2  C9 06                CMP #6                        ; Is it 6?
003BAD  2  D0 51                BNE TryAbsoluteY
003BAF  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003BB2  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003BB5  2  F0 49                BEQ TryAbsoluteY
003BB7  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003BBA  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003BBD  2  F0 41                BEQ TryAbsoluteY
003BBF  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003BC2  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003BC5  2  F0 39                BEQ TryAbsoluteY
003BC7  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003BCA  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003BCD  2  F0 31                BEQ TryAbsoluteY
003BCF  2  AD 05 02             LDA IN+5
003BD2  2  C9 2C                CMP #','
003BD4  2  D0 2A                BNE TryAbsoluteY
003BD6  2  AD 06 02             LDA IN+6
003BD9  2  20 24 2F             JSR ToUpper
003BDC  2  C9 58                CMP #'X'
003BDE  2  D0 20                BNE TryAbsoluteY
003BE0  2  A9 09                LDA #AM_ABSOLUTE_X
003BE2  2  8D 0B 10             STA AM
003BE5  2  AE 01 02             LDX IN+1                      ; Get operand characters
003BE8  2  AC 02 02             LDY IN+2
003BEB  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003BEE  2  8D 2F 10             STA OPERAND+1                 ; Save it as the operand
003BF1  2  AE 03 02             LDX IN+3                      ; Get operand characters
003BF4  2  AC 04 02             LDY IN+4
003BF7  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003BFA  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003BFD  2  4C F9 3D             JMP GenerateCode
003C00  2               
003C00  2               ; AM_ABSOLUTE_Y, e.g. LDA nnnn,Y
003C00  2               ; 4 hex digits followed by ,Y
003C00  2               TryAbsoluteY:
003C00  2  AD 00 02             LDA IN                        ; Get length
003C03  2  C9 06                CMP #6                        ; Is it 6?
003C05  2  D0 51                BNE TryIndexedIndirect
003C07  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003C0A  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003C0D  2  F0 49                BEQ TryIndexedIndirect
003C0F  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003C12  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003C15  2  F0 41                BEQ TryIndexedIndirect
003C17  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003C1A  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003C1D  2  F0 39                BEQ TryIndexedIndirect
003C1F  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003C22  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003C25  2  F0 31                BEQ TryIndexedIndirect
003C27  2  AD 05 02             LDA IN+5
003C2A  2  C9 2C                CMP #','
003C2C  2  D0 2A                BNE TryIndexedIndirect
003C2E  2  AD 06 02             LDA IN+6
003C31  2  20 24 2F             JSR ToUpper
003C34  2  C9 59                CMP #'Y'
003C36  2  D0 20                BNE TryIndexedIndirect
003C38  2  A9 0A                LDA #AM_ABSOLUTE_Y
003C3A  2  8D 0B 10             STA AM
003C3D  2  AE 01 02             LDX IN+1                      ; Get operand characters
003C40  2  AC 02 02             LDY IN+2
003C43  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003C46  2  8D 2F 10             STA OPERAND+1                 ; Save it as the operand
003C49  2  AE 03 02             LDX IN+3                      ; Get operand characters
003C4C  2  AC 04 02             LDY IN+4
003C4F  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003C52  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003C55  2  4C F9 3D             JMP GenerateCode
003C58  2               
003C58  2               ; AM_INDEXED_INDIRECT, e.g. LDA (nn,X)
003C58  2               TryIndexedIndirect:
003C58  2  AD 00 02             LDA IN                        ; Get length
003C5B  2  C9 06                CMP #6                        ; Is it 6?
003C5D  2  D0 43                BNE TryIndirectIndexed
003C5F  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003C62  2  C9 28                CMP #'('
003C64  2  D0 3C                BNE TryIndirectIndexed
003C66  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003C69  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003C6C  2  F0 34                BEQ TryIndirectIndexed
003C6E  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003C71  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003C74  2  F0 2C                BEQ TryIndirectIndexed
003C76  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003C79  2  C9 2C                CMP #','                      ; Is it a comma?
003C7B  2  D0 25                BNE TryIndirectIndexed
003C7D  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
003C80  2  20 24 2F             JSR ToUpper
003C83  2  C9 58                CMP #'X'                      ; Is it an X?
003C85  2  D0 1B                BNE TryIndirectIndexed
003C87  2  AD 06 02             LDA IN+6                      ; Get sixth char of operand
003C8A  2  C9 29                CMP #')'                      ; Is it an )?
003C8C  2  D0 14                BNE TryIndirectIndexed
003C8E  2  A9 0C                LDA #AM_INDEXED_INDIRECT      ; Yes, this is indexed indirect
003C90  2  8D 0B 10             STA AM                        ; Save it
003C93  2  AE 02 02             LDX IN+2                      ; Get operand characters
003C96  2  AC 03 02             LDY IN+3
003C99  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003C9C  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003C9F  2  4C F9 3D             JMP GenerateCode
003CA2  2               
003CA2  2               ; AM_INDIRECT_INDEXED, e.g. LDA (nn),Y
003CA2  2               TryIndirectIndexed:
003CA2  2  AD 00 02             LDA IN                        ; Get length
003CA5  2  C9 06                CMP #6                        ; Is it 6?
003CA7  2  D0 43                BNE TryIndirect
003CA9  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003CAC  2  C9 28                CMP #'('
003CAE  2  D0 3C                BNE TryIndirect
003CB0  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003CB3  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003CB6  2  F0 34                BEQ TryIndirect
003CB8  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003CBB  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003CBE  2  F0 2C                BEQ TryIndirect
003CC0  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003CC3  2  C9 29                CMP #')'                      ; Is it a )?
003CC5  2  D0 25                BNE TryIndirect
003CC7  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
003CCA  2  C9 2C                CMP #','                      ; Is it a comma?
003CCC  2  D0 1E                BNE TryIndirect
003CCE  2  AD 06 02             LDA IN+6                      ; Get sixth char of operand
003CD1  2  20 24 2F             JSR ToUpper
003CD4  2  C9 59                CMP #'Y'                      ; Is it a Y?
003CD6  2  D0 14                BNE TryIndirect
003CD8  2  A9 0D                LDA #AM_INDIRECT_INDEXED      ; Yes, this is indirect indexed
003CDA  2  8D 0B 10             STA AM                        ; Save it
003CDD  2  AE 02 02             LDX IN+2                      ; Get operand characters
003CE0  2  AC 03 02             LDY IN+3
003CE3  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003CE6  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003CE9  2  4C F9 3D             JMP GenerateCode
003CEC  2               
003CEC  2               ; AM_INDIRECT, e.g. JMP (nnnn)
003CEC  2               ; l paren, 4 hex digits, r paren
003CEC  2               TryIndirect:
003CEC  2  AD 00 02             LDA IN                        ; Get length
003CEF  2  C9 06                CMP #6                        ; Is it 6?
003CF1  2  D0 4E                BNE TryIndirectZP
003CF3  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003CF6  2  C9 28                CMP #'('
003CF8  2  D0 47                BNE TryIndirectZP
003CFA  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003CFD  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D00  2  F0 3F                BEQ TryIndirectZP
003D02  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003D05  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D08  2  F0 37                BEQ TryIndirectZP
003D0A  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003D0D  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D10  2  F0 2F                BEQ TryIndirectZP
003D12  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
003D15  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D18  2  F0 27                BEQ TryIndirectZP
003D1A  2  AD 06 02             LDA IN+6                      ; Get fourth char of operand
003D1D  2  C9 29                CMP #')'                      ; Is it a )?
003D1F  2  D0 20                BNE TryIndirectZP
003D21  2  A9 0B                LDA #AM_INDIRECT              ; Yes, this is indirect
003D23  2  8D 0B 10             STA AM                        ; Save it
003D26  2               
003D26  2  AE 02 02             LDX IN+2                      ; Get operand characters
003D29  2  AC 03 02             LDY IN+3
003D2C  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003D2F  2  8D 2F 10             STA OPERAND+1                 ; Save it as the operand
003D32  2  AE 04 02             LDX IN+4                      ; Get operand characters
003D35  2  AC 05 02             LDY IN+5
003D38  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003D3B  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003D3E  2  4C F9 3D             JMP GenerateCode
003D41  2               
003D41  2               ; AM_INDIRECT_ZEROPAGE, e.g. LDA (nn) [65C02 only]
003D41  2               TryIndirectZP:
003D41  2  AD 00 02             LDA IN                        ; Get length
003D44  2  C9 04                CMP #4                        ; Is it 4?
003D46  2  D0 32                BNE TryAbsIndInd
003D48  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003D4B  2  C9 28                CMP #'('
003D4D  2  D0 2B                BNE TryAbsIndInd
003D4F  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003D52  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D55  2  F0 23                BEQ TryAbsIndInd
003D57  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003D5A  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D5D  2  F0 1B                BEQ TryAbsIndInd
003D5F  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003D62  2  C9 29                CMP #')'                      ; Is it a )?
003D64  2  D0 14                BNE TryAbsIndInd
003D66  2  A9 0E                LDA #AM_INDIRECT_ZEROPAGE     ; Yes, this is indirect zeropage
003D68  2  8D 0B 10             STA AM                        ; Save it
003D6B  2               
003D6B  2  AE 02 02             LDX IN+2                      ; Get operand characters
003D6E  2  AC 03 02             LDY IN+3
003D71  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003D74  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003D77  2  4C F9 3D             JMP GenerateCode
003D7A  2               
003D7A  2               ; AM_ABSOLUTE_INDEXED_INDIRECT, e.g. JMP (nnnn,X) [65C02 only]
003D7A  2               TryAbsIndInd:
003D7A  2  AD 00 02             LDA IN                        ; Get length
003D7D  2  C9 08                CMP #8                        ; Is it 8?
003D7F  2  D0 5F                BNE InvalidOp
003D81  2  AD 01 02             LDA IN+1                      ; Get first char of operand
003D84  2  C9 28                CMP #'('
003D86  2  D0 58                BNE InvalidOp
003D88  2  AD 02 02             LDA IN+2                      ; Get second char of operand
003D8B  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D8E  2  F0 50                BEQ InvalidOp
003D90  2  AD 03 02             LDA IN+3                      ; Get third char of operand
003D93  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D96  2  F0 48                BEQ InvalidOp
003D98  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
003D9B  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003D9E  2  F0 40                BEQ InvalidOp
003DA0  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
003DA3  2  20 A5 3F             JSR IsHexDigit                ; Is it a hex digit?
003DA6  2  F0 38                BEQ InvalidOp
003DA8  2  AD 06 02             LDA IN+6                      ; Get sixth char of operand
003DAB  2  C9 2C                CMP #','                      ; Is it a ,?
003DAD  2  D0 31                BNE InvalidOp
003DAF  2  AD 07 02             LDA IN+7                      ; Get 7th char of operand
003DB2  2  20 24 2F             JSR ToUpper
003DB5  2  C9 58                CMP #'X'                      ; Is it a X?
003DB7  2  D0 27                BNE InvalidOp
003DB9  2  AD 08 02             LDA IN+8                      ; Get 8th char of operand
003DBC  2  C9 29                CMP #')'                      ; Is it a )?
003DBE  2  D0 20                BNE InvalidOp
003DC0  2  A9 0F                LDA #AM_ABSOLUTE_INDEXED_INDIRECT ; Yes, this is abolute indexed indirect
003DC2  2  8D 0B 10             STA AM                        ; Save it
003DC5  2               
003DC5  2  AE 02 02             LDX IN+2                      ; Get operand characters
003DC8  2  AC 03 02             LDY IN+3
003DCB  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003DCE  2  8D 2F 10             STA OPERAND+1                 ; Save it as the operand
003DD1  2  AE 04 02             LDX IN+4                      ; Get operand characters
003DD4  2  AC 05 02             LDY IN+5
003DD7  2  20 BE 3F             JSR TwoCharsToBin             ; Convert to binary
003DDA  2  8D 2E 10             STA OPERAND                   ; Save it as the operand
003DDD  2  4C F9 3D             JMP GenerateCode
003DE0  2               
003DE0  2               ; If not any of the above, report "Invalid operand" and return.
003DE0  2               
003DE0  2               InvalidOp:
003DE0  2  20 71 2C             JSR PrintCR
003DE3  2  20 A8 2C             JSR Imprint
003DE6  2  49 6E 76 61          .byte "Invalid operand", 0
003DEA  2  6C 69 64 20  
003DEE  2  6F 70 65 72  
003DF6  2  4C 71 2C             JMP PrintCR             ; Return via caller
003DF9  2               
003DF9  2               GenerateCode:
003DF9  2  20 71 2C             JSR PrintCR             ; Output newline
003DFC  2               
003DFC  2  20 6D 3F             JSR CheckAddressingModeValid   ; See if addressing mode is valid
003DFF  2  D0 1E                BNE OperandOkay
003E01  2               
003E01  2  20 A8 2C             JSR Imprint             ; Not a valid addressing mode
003E04  2  49 6E 76 61          .byte "Invalid addressing mode", 0
003E08  2  6C 69 64 20  
003E0C  2  61 64 64 72  
003E1C  2               
003E1C  2  4C 71 2C             JMP PrintCR             ; Return via caller
003E1F  2               
003E1F  2               OperandOkay:
003E1F  2               
003E1F  2               ; Look up instruction length based on addressing mode and save it
003E1F  2               
003E1F  2  AE 0B 10             LDX AM                   ; Addressing mode
003E22  2  BD E1 37             LDA LENGTHS,X            ; Get instruction length for this addressing mode
003E25  2  8D 0C 10             STA LEN                  ; Save it
003E28  2               
003E28  2               ; Write the opcode to memory
003E28  2               
003E28  2  AD 09 10             LDA OPCODE               ; get opcode
003E2B  2  A0 00                LDY #0
003E2D  2  91 38                STA (ADDR),Y             ; store it
003E2F  2               
003E2F  2               ; Check that we can write it back (in case destination memory is not writable).
003E2F  2               
003E2F  2  D1 38                CMP (ADDR),Y             ; Do we read back what we wrote?
003E31  2  F0 22                BEQ WriteOperands        ; Yes, okay
003E33  2               
003E33  2               ; Memory is not writable for some reason, Report error and quit.
003E33  2               
003E33  2  20 A8 2C             JSR Imprint              ; Print error message
003E36  2  55 6E 61 62          .byte "Unable to write to $", 0
003E3A  2  6C 65 20 74  
003E3E  2  6F 20 77 72  
003E4B  2  A6 38                LDX ADDR
003E4D  2  A4 39                LDY ADDR+1
003E4F  2  20 0D 2C             JSR PrintAddress
003E52  2  4C 71 2C             JMP PrintCR             ; Return via caller
003E55  2               
003E55  2               ; Generate code for operands
003E55  2               
003E55  2               WriteOperands:
003E55  2  AD 0B 10             LDA AM                  ; get addressing mode
003E58  2  C9 01                CMP #AM_IMPLICIT        ; These modes take no operands
003E5A  2  D0 03                BNE TryAcc
003E5C  2  4C 15 3F             JMP ZeroOperands
003E5F  2               TryAcc:
003E5F  2  C9 02                CMP #AM_ACCUMULATOR
003E61  2  D0 03                BNE TryImmed
003E63  2  4C 15 3F             JMP ZeroOperands
003E66  2               
003E66  2               TryImmed:
003E66  2  C9 03                CMP #AM_IMMEDIATE       ; These modes take one operand
003E68  2  D0 03                BNE TryZp
003E6A  2  4C FE 3E             JMP OneOperand
003E6D  2  C9 04        TryZp:  CMP #AM_ZEROPAGE
003E6F  2  D0 03                BNE TryZpX
003E71  2  4C FE 3E             JMP OneOperand
003E74  2  C9 05        TryZpX: CMP #AM_ZEROPAGE_X
003E76  2  D0 03                BNE TryZpY
003E78  2  4C FE 3E             JMP OneOperand
003E7B  2  C9 06        TryZpY: CMP #AM_ZEROPAGE_Y
003E7D  2  F0 7F                BEQ OneOperand
003E7F  2  C9 0C                CMP #AM_INDEXED_INDIRECT
003E81  2  F0 7B                BEQ OneOperand
003E83  2  C9 0D                CMP #AM_INDIRECT_INDEXED
003E85  2  F0 77                BEQ OneOperand
003E87  2  C9 0E                CMP #AM_INDIRECT_ZEROPAGE ; [65C02 only]
003E89  2  F0 73                BEQ OneOperand
003E8B  2               
003E8B  2  C9 08                CMP #AM_ABSOLUTE       ; These modes take two operands
003E8D  2  F0 79                BEQ TwoOperands
003E8F  2  C9 09                CMP #AM_ABSOLUTE_X
003E91  2  F0 75                BEQ TwoOperands
003E93  2  C9 0A                CMP #AM_ABSOLUTE_Y
003E95  2  F0 71                BEQ TwoOperands
003E97  2  C9 0B                CMP #AM_INDIRECT
003E99  2  F0 6D                BEQ TwoOperands
003E9B  2  C9 0F                CMP #AM_ABSOLUTE_INDEXED_INDIRECT
003E9D  2  F0 69                BEQ TwoOperands
003E9F  2               
003E9F  2  C9 07                CMP #AM_RELATIVE       ; Relative is special case
003EA1  2  D0 72                BNE ZeroOperands
003EA3  2               
003EA3  2               ; BEQ nnnn        Relative
003EA3  2               ; Write 1 byte calculated as destination - current address - instruction length
003EA3  2               ; i.e. (OPERAND,OPERAND+1) - ADDR,ADDR+1 - 2
003EA3  2               ; Report error if branch is out of 8-bit offset range.
003EA3  2               
003EA3  2               Relative:
003EA3  2  AD 2E 10              LDA OPERAND                 ; destination low byte
003EA6  2  38                    SEC
003EA7  2  E5 38                 SBC ADDR                    ; subtract address low byte
003EA9  2  8D 2E 10              STA OPERAND                 ; Save it
003EAC  2  AD 2F 10              LDA OPERAND+1               ; destination high byte
003EAF  2  E5 39                 SBC ADDR+1                  ; subtract address high byte (with any borrow)
003EB1  2  8D 2F 10              STA OPERAND+1               ; store it
003EB4  2               
003EB4  2  AD 2E 10              LDA OPERAND
003EB7  2  38                    SEC
003EB8  2  E9 02                 SBC #2                      ; subtract 2 more
003EBA  2  8D 2E 10              STA OPERAND                 ; store it
003EBD  2  AD 2F 10              LDA OPERAND+1               ; destination high byte
003EC0  2  E9 00                 SBC #0                      ; subtract 0 (with any borrow)
003EC2  2  8D 2F 10              STA OPERAND+1               ; store it
003EC5  2               
003EC5  2               ; Report error if branch is out of 8-bit offset range.
003EC5  2               ; Valid range is $0000 - $007F and $FF80 - $FFFF
003EC5  2               
003EC5  2  AD 2F 10              LDA OPERAND+1              ; High byte
003EC8  2  F0 27                 BEQ OkayZero               ; Should be $))
003ECA  2  C9 FF                 CMP #$FF
003ECC  2  F0 2B                 BEQ OkayFF                 ; Or $FF
003ECE  2               OutOfRange:
003ECE  2  20 A8 2C              JSR Imprint
003ED1  2  52 65 6C 61           .byte "Relative branch out of range", 0
003ED5  2  74 69 76 65  
003ED9  2  20 62 72 61  
003EEE  2  4C 71 2C              JMP PrintCR                ; Return via caller
003EF1  2               
003EF1  2               OkayZero:
003EF1  2  AD 2E 10              LDA OPERAND                ; Low byte
003EF4  2  30 D8                 BMI OutOfRange             ; must be $00-$7F (i.e. positive)
003EF6  2  4C FE 3E              JMP OneOperand
003EF9  2               
003EF9  2               OkayFF:
003EF9  2  AD 2E 10              LDA OPERAND                ; Low byte
003EFC  2  10 D0                 BPL OutOfRange             ; must be $80-$FF (i.e. negative)
003EFE  2               
003EFE  2               ; Now fall through to one operand code
003EFE  2               
003EFE  2               OneOperand:
003EFE  2  AD 2E 10             LDA OPERAND                  ; Get operand
003F01  2  A0 01                LDY #1                       ; Offset from instruction
003F03  2  91 38                STA (ADDR),Y                 ; write it
003F05  2  4C 15 3F             JMP ZeroOperands             ; done
003F08  2               
003F08  2               TwoOperands:
003F08  2  AD 2E 10             LDA OPERAND                  ; Get operand low byte
003F0B  2  A0 01                LDY #1                       ; Offset from instruction
003F0D  2  91 38                STA (ADDR),Y                 ; write it
003F0F  2  C8                   INY
003F10  2  AD 2F 10             LDA OPERAND+1                ; Get operand high byte
003F13  2  91 38                STA (ADDR),Y                 ; write it
003F15  2               
003F15  2               ZeroOperands:                        ; Nothing to do
003F15  2               
003F15  2               ; Update current address with instruction length
003F15  2               
003F15  2  18                  CLC
003F16  2  A5 38               LDA ADDR                      ; Low byte
003F18  2  6D 0C 10            ADC LEN                       ; Add length
003F1B  2  85 38               STA ADDR                      ; Store it
003F1D  2  A5 39               LDA ADDR+1                    ; High byte
003F1F  2  69 00               ADC #0                        ; Add any carry
003F21  2  85 39               STA ADDR+1                    ; Store it
003F23  2  4C FA 39            JMP AssembleLine              ; loop back to start of AssembleLine
003F26  2               
003F26  2               ; Look up three letter mnemonic, e.g. "NOP". On entry mnemonic is stored in MNEM.
003F26  2               ; Write index value, e.g. OP_NOP, to OP. Set sit to OP_INV if not found.
003F26  2               ; Registers changed: A, X, Y.
003F26  2               LookupMnemonic:
003F26  2  A2 00                LDX #0                  ; Holds current table index
003F28  2  A9 BB                LDA #<MNEMONICS         ; Store address of start of table in T1 (L/H)
003F2A  2  85 30                STA T1
003F2C  2  A9 36                LDA #>MNEMONICS
003F2E  2  85 31                STA T1+1
003F30  2               Loop:
003F30  2  A0 00                LDY #0                  ; Holds offset of string in table entry
003F32  2  B9 2B 10             LDA MNEM,Y              ; Compare first char of mnemonic to table entry
003F35  2  D1 30                CMP (T1),Y
003F37  2  D0 14                BNE NextOp              ; If different, try next opcode
003F39  2  C8                   INY
003F3A  2  B9 2B 10             LDA MNEM,Y              ; Compare second char of mnemonic to table entry
003F3D  2  D1 30                CMP (T1),Y
003F3F  2  D0 0C                BNE NextOp              ; If different, try next opcode
003F41  2  C8                   INY
003F42  2  B9 2B 10             LDA MNEM,Y              ; Compare third char of mnemonic to table entry
003F45  2  D1 30                CMP (T1),Y
003F47  2  D0 04                BNE NextOp              ; If different, try next opcode
003F49  2               
003F49  2                                               ; We found a match
003F49  2  8E 0A 10             STX OP                  ; Store index in table (X) in OP
003F4C  2  60                   RTS                     ; And return
003F4D  2               
003F4D  2               NextOp:
003F4D  2  E8                   INX                     ; Increment table index
003F4E  2  18                   CLC
003F4F  2  A5 30                LDA T1                  ; Increment pointer to table entry (T1) as 16-bit value
003F51  2  69 03                ADC #3                  ; Adding three because each entry is 3 bytes
003F53  2  85 30                STA T1
003F55  2  A5 31                LDA T1+1                ; Add possible carry to high byte
003F57  2  69 00                ADC #0
003F59  2  85 31                STA T1+1
003F5B  2               
003F5B  2  A5 30                LDA T1                  ; Did we reach the last entry (MNEMONICSEND?)
003F5D  2  C9 E1                CMP #<MNEMONICSEND      ; If not, keep searching
003F5F  2  D0 CF                BNE Loop
003F61  2  A5 31                LDA T1+1
003F63  2  C9 37                CMP #>MNEMONICSEND
003F65  2  D0 C9                BNE Loop
003F67  2               
003F67  2                                               ; End of table reached
003F67  2  A9 00                LDA #OP_INV             ; Value is not valid
003F69  2  8D 0A 10             STA OP
003F6C  2  60                   RTS
003F6D  2               
003F6D  2               ; Given an instruction and addressing mode, return if it is valid.
003F6D  2               ; When called OP should contain instruction (e.g. OP_NOP) and
003F6D  2               ; AM contain the addressing mode (e.g. AM_IMPLICIT).
003F6D  2               ; If valid, sets OPCODE to the opcode (eg. $EA for NOP) and returns 1
003F6D  2               ; in A. If not valid, returns 0 in A.
003F6D  2               ; Registers changed: A, X, Y.
003F6D  2               
003F6D  2               CheckAddressingModeValid:
003F6D  2  A2 00                LDX #0                  ; Holds current table index
003F6F  2  A9 FA                LDA #<OPCODES           ; Store address of start of table in T1 (L/H)
003F71  2  85 30                STA T1
003F73  2  A9 37                LDA #>OPCODES
003F75  2  85 31                STA T1+1
003F77  2               OpLoop:
003F77  2  A0 00                LDY #0                  ; Holds offset into table entry
003F79  2  B1 30                LDA (T1),Y              ; Get a table entry (instruction)
003F7B  2  CD 0A 10             CMP OP                  ; Is it the instruction we are looking for?
003F7E  2  D0 0F                BNE NextInst            ; If different, try next opcode
003F80  2                                               ; Instruction matched. Does the addressing mode match?
003F80  2  C8                   INY                     ; Want second byte of table entry (address mode)
003F81  2  B1 30                LDA (T1),Y              ; Get a table entry (address mode
003F83  2  CD 0B 10             CMP AM                  ; Is it the address mode we are looking for?
003F86  2  D0 07                BNE NextInst            ; If different, try next opcode
003F88  2                                               ; We found a match
003F88  2  8A                   TXA                     ; Get index in table (X), the opcode
003F89  2  8D 09 10             STA OPCODE              ; Store it
003F8C  2  A9 01                LDA #1                  ; Set true return value
003F8E  2  60                   RTS                     ; And return
003F8F  2               
003F8F  2               NextInst:
003F8F  2  E8                   INX                     ; Increment table index
003F90  2  F0 10                BEQ OpNotFound          ; If wrapped past $FF, we did not find what we were looking for
003F92  2  18                   CLC
003F93  2  A5 30                LDA T1                  ; Increment pointer to table entry (T1) as 16-bit value
003F95  2  69 02                ADC #2                  ; Add two because each entry is 2 bytes
003F97  2  85 30                STA T1
003F99  2  A5 31                LDA T1+1                ; Add possible carry to high byte
003F9B  2  69 00                ADC #0
003F9D  2  85 31                STA T1+1
003F9F  2  4C 77 3F             JMP OpLoop
003FA2  2               
003FA2  2               OpNotFound:                     ; End of table reached
003FA2  2  A9 00                LDA #0                  ; Set false return value
003FA4  2  60                   RTS
003FA5  2               
003FA5  2               ; Return if a character is a valid hex digit (0-9, A-F, or a-f).
003FA5  2               ; Pass character in A.
003FA5  2               ; Returns 1 in A if valid, 0 if not valid.
003FA5  2               ; Registers affected: A
003FA5  2               IsHexDigit:
003FA5  2  20 24 2F             JSR ToUpper
003FA8  2  C9 30                CMP #'0'
003FAA  2  30 0C                BMI @Invalid
003FAC  2  C9 3A                CMP #'9'+1
003FAE  2  30 0B                BMI @Okay
003FB0  2  C9 41                CMP #'A'
003FB2  2  30 04                BMI @Invalid
003FB4  2  C9 47                CMP #'F'+1
003FB6  2  30 03                BMI @Okay
003FB8  2               @Invalid:
003FB8  2  A9 00                LDA #0
003FBA  2  60                   RTS
003FBB  2               @Okay:
003FBB  2  A9 01                LDA #1
003FBD  2  60                   RTS
003FBE  2               
003FBE  2               ; Convert two characters containing hex digits to binary
003FBE  2               ; Chars passed in X (first char) and Y (second char).
003FBE  2               ; Returns value in A.
003FBE  2               ; e.g. X='1' Y='A' Returns A = $1A
003FBE  2               ; Does not check that characters are valid hex digits
003FBE  2               TwoCharsToBin:
003FBE  2  8A                   TXA                     ; get first digit
003FBF  2  20 D0 3F             JSR CharToBin           ; convert to binary
003FC2  2  0A                   ASL A                   ; shift to upper nibble
003FC3  2  0A                   ASL A
003FC4  2  0A                   ASL A
003FC5  2  0A                   ASL A
003FC6  2  85 30                STA T1                  ; Save it
003FC8  2  98                   TYA                     ; get second digit
003FC9  2  20 D0 3F             JSR CharToBin           ; convert to binary
003FCC  2  18                   CLC
003FCD  2  65 30                ADC T1                  ; Add the upper nibble
003FCF  2  60                   RTS
003FD0  2               
003FD0  2               ; Convert character containing a hex digit to binary.
003FD0  2               ; Char passed in A. Returns value in A.
003FD0  2               ; e.g. A='A' Returns A=$0A
003FD0  2               ; Does not check that character is valid hex digit.
003FD0  2               CharToBin:
003FD0  2  20 24 2F             JSR ToUpper
003FD3  2  C9 3A                CMP #'9'+1              ; Is it '0'-'9'?
003FD5  2  30 04                BMI @Digit              ; Branch if so
003FD7  2  38                   SEC                     ; Otherwise must be 'A'-'F'
003FD8  2  E9 37                SBC #'A'-10             ; convert to value
003FDA  2  60                   RTS
003FDB  2               @Digit:
003FDB  2  38                   SEC
003FDC  2  E9 30                SBC #'0'                ; convert to value
003FDE  2  60                   RTS
003FDF  2               
003FDF  1               .endif
003FDF  1                 .include "trace.s"
003FDF  2               ;
003FDF  2               ; 6502 Instruction Trace
003FDF  2               ;
003FDF  2               ; Copyright (C) 2012-2019 by Jeff Tranter <tranter@pobox.com>
003FDF  2               ;
003FDF  2               ; Licensed under the Apache License, Version 2.0 (the "License");
003FDF  2               ; you may not use this file except in compliance with the License.
003FDF  2               ; You may obtain a copy of the License at
003FDF  2               ;
003FDF  2               ;   http://www.apache.org/licenses/LICENSE-2.0
003FDF  2               ;
003FDF  2               ; Unless required by applicable law or agreed to in writing, software
003FDF  2               ; distributed under the License is distributed on an "AS IS" BASIS,
003FDF  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
003FDF  2               ; See the License for the specific language governing permissions and
003FDF  2               ; limitations under the License.
003FDF  2               
003FDF  2               ; Trace Feature
003FDF  2               ; --------------
003FDF  2               ;
003FDF  2               ; The "." command single steps one instruction at a time showing the
003FDF  2               ; CPU registers. Starts with the register values listed by the R
003FDF  2               ; command. Updates them after single stepping.
003FDF  2               ;
003FDF  2               ; The R(egister) command shows the current PC and disassembles the
003FDF  2               ; current instruction. It also allows the user to change the PC. Pressing
003FDF  2               ; <Enter> when prompted for a new register value will keep the current
003FDF  2               ; value and advance to the next register.
003FDF  2               ;
003FDF  2               ; The G(o) command will optionally use the PC value if the user
003FDF  2               ; hits <Enter> instead of an address.
003FDF  2               ;
003FDF  2               ; A breakpoint (BRK instruction) will display a message and update
003FDF  2               ; the current register values so that it can be traced. This works
003FDF  2               ; whether the breakpint address is set using the B command or not.
003FDF  2               ;
003FDF  2               ; The command supports tracing/stepping through ROM as well as RAM.
003FDF  2               ;
003FDF  2               ; e.g.
003FDF  2               ;
003FDF  2               ; ? R
003FDF  2               ; A-D2 X-00 Y-03 S-017B P-33 ..-BDIZC
003FDF  2               ; FF00   D8          CLD
003FDF  2               ; A-00 X-01 Y-02 S-01FF P-00 ........
003FDF  2               ; PC-FF00
003FDF  2               ; ? .
003FDF  2               ; A-D2 X-00 Y-03 S-017B P-33 ..-B.IZC
003FDF  2               ; FF01   58          CLI
003FDF  2               ; ? .
003FDF  2               ; A-D2 X-00 Y-03 S-017B P-33 ..-B..ZC
003FDF  2               ; FF02   A0 7F       LDY   #$7F
003FDF  2               ; ? .
003FDF  2               ; A-D2 X-00 Y-7F S-017B P-33 ..-B...C
003FDF  2               ; FF04   8C 12 D0    STY   $D012
003FDF  2               
003FDF  2               ; Variables used (defined in jmon.s):
003FDF  2               ;
003FDF  2               ; SAVE_A  - Holds saved values of registers
003FDF  2               ; SAVE_X  - "
003FDF  2               ; SAVE_Y  - "
003FDF  2               ; SAVE_S  - "
003FDF  2               ; SAVE_P  - "
003FDF  2               ; SAVE_PC - "
003FDF  2               ; NEXT_PC - Value of PC after next instruction
003FDF  2               ; ADDR - instruction address
003FDF  2               ; OPCODE - instruction op code
003FDF  2               ; OP - instruction type (OP_*)
003FDF  2               ; LEN -length of instruction
003FDF  2               ; IN - input buffer holding operands
003FDF  2               ; AM - addressing mode (AM_*)
003FDF  2               ; TRACEINST - buffer holding traced instruction
003FDF  2               
003FDF  2               
003FDF  2               ; Trace the next instruction using saved registers. Execute the
003FDF  2               ; instruction, display new registers values. disassemble new current
003FDF  2               ; instruction, and return.
003FDF  2               
003FDF  2               Trace:
003FDF  2               
003FDF  2               ; Get next instruction op code from saved PC location.
003FDF  2               
003FDF  2  AD 1E 10             LDA SAVE_PC             ; Get address of instruction to execute (low byte)
003FE2  2  85 38                STA ADDR                ; Save in page zero so we can use indirect addressing
003FE4  2  AD 1F 10             LDA SAVE_PC+1           ; Do the same for the high byte of address
003FE7  2  85 39                STA ADDR+1
003FE9  2  A0 00                LDY #0
003FEB  2  B1 38                LDA (ADDR),Y            ; Get the instruction opcode
003FED  2  8D 09 10             STA OPCODE              ; And save it
003FF0  2  20 E4 41             JSR GetLength           ; Determine instruction length
003FF3  2               
003FF3  2               ; Copy next instruction and operands to RAM buffer (can be up to 3 bytes)
003FF3  2               
003FF3  2  A0 00                LDY #0
003FF5  2               @Copy:
003FF5  2  B1 38                LDA (ADDR),Y            ; Get the instruction / operand from memory
003FF7  2  99 30 10             STA TRACEINST,Y         ; Write it to the buffer where we will execute it
003FFA  2  C8                   INY                     ; Increment index
003FFB  2  CC 0C 10             CPY LEN                 ; Did we reach the instruction length?
003FFE  2  D0 F5                BNE @Copy               ; Continue for instruction length
004000  2               
004000  2               ; Now add a jump after the instruction to where we want to go after it is executed
004000  2               
004000  2  A9 4C                LDA #$4C                ; JMP ReturnFromTrace
004002  2  99 30 10             STA TRACEINST,Y
004005  2  C8                   INY
004006  2  A9 75                LDA #<ReturnFromTrace
004008  2  99 30 10             STA TRACEINST,Y
00400B  2  C8                   INY
00400C  2  A9 41                LDA #>ReturnFromTrace
00400E  2  99 30 10             STA TRACEINST,Y
004011  2               
004011  2               ; Calculate new PC value.
004011  2               
004011  2  AD 1E 10             LDA SAVE_PC             ; Existing PC (low byte)
004014  2  18                   CLC
004015  2  6D 0C 10             ADC LEN                 ; Add length to it
004018  2  8D 20 10             STA NEXT_PC             ; Save as next PC (low byte)
00401B  2  AD 1F 10             LDA SAVE_PC+1           ; High byte
00401E  2  69 00                ADC #0                  ; Add any carry
004020  2  8D 21 10             STA NEXT_PC+1           ; Save as next PC (high byte)
004023  2               
004023  2  A9 00                LDA #0
004025  2  8D 38 10             STA TAKEN               ; Clear branch taken flag.
004028  2               
004028  2               ; Special handling for instructions that change flow of control.
004028  2               ; These are not actually executed, they are emulated.
004028  2               ; TODO: Factor out common code for handling instructions which change flow of control.
004028  2               
004028  2               ; Bxx - branch instructions. These are executed but we change the
004028  2               ; destination of the branch so we catch whether they are taken or not.
004028  2               
004028  2  AD 0B 10             LDA AM                  ; Get addressing mode
00402B  2  C9 07                CMP #AM_RELATIVE        ; Relative addressing means a branch instruction
00402D  2  D0 1D                BNE TryBRK
00402F  2               
00402F  2               ; The code in the TRACEINST buffer will look like this:
00402F  2               ;
00402F  2               ;       JMP TRACEINST
00402F  2               ;       ...
00402F  2               ;       Bxx $03 (Taken)         ; Instruction being traced
00402F  2               ;       JMP ReturnFromTrace
00402F  2               ;Taken: JMP BranchTaken
00402F  2               ;        ...
00402F  2               ;ReturnFromTrace:
00402F  2               
00402F  2  A0 01                LDY #1                  ; Points to branch destination
004031  2  A9 03                LDA #$03                ; Want to set it to $03 (Taken)
004033  2  99 30 10             STA TRACEINST,Y
004036  2  A0 05                LDY #5
004038  2  A9 4C                LDA #$4C                ; JMP BranchTaken
00403A  2  99 30 10             STA TRACEINST,Y
00403D  2  C8                   INY
00403E  2  A9 70                LDA #<BranchTaken
004040  2  99 30 10             STA TRACEINST,Y
004043  2  C8                   INY
004044  2  A9 41                LDA #>BranchTaken
004046  2  99 30 10             STA TRACEINST,Y
004049  2               
004049  2               ; Next PC in the case where the branch is not taken was already set earlier.
004049  2               
004049  2  4C 57 41             JMP Execute
00404C  2               
00404C  2               ; BRK - set B=1. Next PC is contents of IRQ vector at $FFFE,$FFFF. Push return address-1 (Current address + 1). Push P.
00404C  2               TryBRK:
00404C  2  AD 09 10             LDA OPCODE              ; Get the opcode
00404F  2  C9 00                CMP #$00                ; BRK ?
004051  2  D0 3E                BNE TryJmp
004053  2               
004053  2  AD 1D 10             LDA SAVE_P              ; Get P
004056  2  09 10                ORA #%00010000          ; Set B bit
004058  2  8D 1D 10             STA SAVE_P
00405B  2               
00405B  2  AD FE FF             LDA $FFFE               ; IRQ vector low
00405E  2  8D 20 10             STA NEXT_PC
004061  2  AD FF FF             LDA $FFFF               ; IRQ vector high
004064  2  8D 21 10             STA NEXT_PC+1
004067  2               
004067  2  A5 38                LDA ADDR                ; Add 1 to current address
004069  2  18                   CLC
00406A  2  69 01                ADC #1
00406C  2  85 38                STA ADDR
00406E  2  A5 39                LDA ADDR+1
004070  2  69 00                ADC #0                  ; Add any carry
004072  2  85 39                STA ADDR+1
004074  2               
004074  2  BA                   TSX                     ; Save our stack pointer
004075  2  8E 22 10             STX THIS_S
004078  2  AE 1C 10             LDX SAVE_S              ; Get program's stack pointer
00407B  2  9A                   TXS
00407C  2               
00407C  2  A5 39                LDA ADDR+1              ; Push return address on program's stack (high byte first)
00407E  2  48                   PHA
00407F  2  A5 38                LDA ADDR
004081  2  48                   PHA
004082  2               
004082  2  AD 1D 10             LDA SAVE_P              ; Push P
004085  2  48                   PHA
004086  2               
004086  2  BA                   TSX                     ; Put program's stack pointer back
004087  2  8E 1C 10             STX SAVE_S
00408A  2               
00408A  2  AE 22 10             LDX THIS_S              ; Restore our stack pointer
00408D  2  9A                   TXS
00408E  2               
00408E  2  4C 8C 41             JMP AfterStep           ; We're done
004091  2               
004091  2               ; JMP (2) - Next PC is operand effective address (possibly indirect).
004091  2               
004091  2               TryJmp:
004091  2  C9 4C                CMP #$4C                ; JMP nnnn ?
004093  2  D0 10                BNE TryJmpI
004095  2  A0 01                LDY #1
004097  2  B1 38                LDA (ADDR),Y            ; Destination address low byte
004099  2  8D 20 10             STA NEXT_PC
00409C  2  C8                   INY
00409D  2  B1 38                LDA (ADDR),Y            ; Destination address high byte
00409F  2  8D 21 10             STA NEXT_PC+1
0040A2  2  4C 8C 41             JMP AfterStep           ; We're done
0040A5  2               
0040A5  2               TryJmpI:
0040A5  2  C9 6C                CMP #$6C                ; JMP (nnnn) ?
0040A7  2  D0 1B                BNE TryJSR
0040A9  2  A0 01                LDY #1
0040AB  2  B1 38                LDA (ADDR),Y            ; Indirect destination address low byte
0040AD  2  85 30                STA T1
0040AF  2  C8                   INY
0040B0  2  B1 38                LDA (ADDR),Y            ; Indirect destination address high byte
0040B2  2  85 31                STA T1+1
0040B4  2  A0 00                LDY #0
0040B6  2  B1 30                LDA (T1),Y              ; Get actual address low byte
0040B8  2  8D 20 10             STA NEXT_PC
0040BB  2  C8                   INY
0040BC  2  B1 30                LDA (T1),Y              ; Get actual address high byte
0040BE  2  8D 21 10             STA NEXT_PC+1
0040C1  2  4C 8C 41             JMP AfterStep           ; We're done
0040C4  2               
0040C4  2               ; JSR - Next PC is operand effective address. Push return address-1 (Current address + 2) on stack.
0040C4  2               
0040C4  2               TryJSR:
0040C4  2  C9 20                CMP #$20                ; JSR nnnn ?
0040C6  2  D0 33                BNE TryRTI
0040C8  2               
0040C8  2  A0 01                LDY #1
0040CA  2  B1 38                LDA (ADDR),Y            ; Destination address low byte
0040CC  2  8D 20 10             STA NEXT_PC
0040CF  2  C8                   INY
0040D0  2  B1 38                LDA (ADDR),Y            ; Destination address high byte
0040D2  2  8D 21 10             STA NEXT_PC+1
0040D5  2               
0040D5  2  A5 38                LDA ADDR                ; Add 2 to current address
0040D7  2  18                   CLC
0040D8  2  69 02                ADC #2
0040DA  2  85 38                STA ADDR
0040DC  2  A5 39                LDA ADDR+1
0040DE  2  69 00                ADC #0                  ; Add any carry
0040E0  2  85 39                STA ADDR+1
0040E2  2               
0040E2  2  BA                   TSX                     ; Save our stack pointer
0040E3  2  8E 22 10             STX THIS_S
0040E6  2  AE 1C 10             LDX SAVE_S              ; Get program's stack pointer
0040E9  2  9A                   TXS
0040EA  2               
0040EA  2  A5 39                LDA ADDR+1              ; Push return address on program's stack
0040EC  2  48                   PHA
0040ED  2  A5 38                LDA ADDR
0040EF  2  48                   PHA
0040F0  2               
0040F0  2  BA                   TSX                     ; Put program's stack pointer back
0040F1  2  8E 1C 10             STX SAVE_S
0040F4  2               
0040F4  2  AE 22 10             LDX THIS_S              ; Restore our stack pointer
0040F7  2  9A                   TXS
0040F8  2               
0040F8  2  4C 8C 41             JMP AfterStep           ; We're done
0040FB  2               
0040FB  2               ; RTI - Pop P. Pop PC. Increment PC to get next PC.
0040FB  2               
0040FB  2               TryRTI:
0040FB  2  C9 40                CMP #$40                ; RTI
0040FD  2  D0 2C                BNE TryRTS
0040FF  2  BA                   TSX                     ; Save our stack pointer
004100  2  8E 22 10             STX THIS_S
004103  2  AE 1C 10             LDX SAVE_S              ; Get program's stack pointer
004106  2  9A                   TXS
004107  2  68                   PLA                     ; Pop P
004108  2  8D 1D 10             STA SAVE_P
00410B  2  68                   PLA                     ; Pop return address low
00410C  2  85 38                STA ADDR
00410E  2  68                   PLA                     ; Pop return address high
00410F  2  85 39                STA ADDR+1
004111  2  BA                   TSX                     ; Put program's stack pointer back
004112  2  8E 1C 10             STX SAVE_S
004115  2  AE 22 10             LDX THIS_S              ; Restore our stack pointer
004118  2  9A                   TXS
004119  2  A5 38                LDA ADDR
00411B  2  18                   CLC
00411C  2  69 01                ADC #1                  ; Add 1 to get new PC
00411E  2  8D 20 10             STA NEXT_PC
004121  2  A5 39                LDA ADDR+1
004123  2  69 00                ADC #0                  ; Add any carry
004125  2  8D 21 10             STA NEXT_PC+1
004128  2  4C 8C 41             JMP AfterStep           ; We're done
00412B  2               
00412B  2               ; RTS - Pop PC. Increment PC to get next PC.
00412B  2               
00412B  2               TryRTS:
00412B  2  C9 60                CMP #$60                ; RTS
00412D  2  D0 28                BNE Execute
00412F  2  BA                   TSX                     ; Save our stack pointer
004130  2  8E 22 10             STX THIS_S
004133  2  AE 1C 10             LDX SAVE_S              ; Get program's stack pointer
004136  2  9A                   TXS
004137  2  68                   PLA                     ; Pop return address low
004138  2  85 38                STA ADDR
00413A  2  68                   PLA                     ; Pop return address high
00413B  2  85 39                STA ADDR+1
00413D  2  BA                   TSX                     ; Put program's stack pointer back
00413E  2  8E 1C 10             STX SAVE_S
004141  2  AE 22 10             LDX THIS_S              ; Restore our stack pointer
004144  2  9A                   TXS
004145  2  A5 38                LDA ADDR
004147  2  18                   CLC
004148  2  69 01                ADC #1                  ; Add 1 to get new PC
00414A  2  8D 20 10             STA NEXT_PC
00414D  2  A5 39                LDA ADDR+1
00414F  2  69 00                ADC #0                  ; Add any carry
004151  2  8D 21 10             STA NEXT_PC+1
004154  2  4C 8C 41             JMP AfterStep           ; We're done
004157  2               
004157  2               ; Not a special instruction. We execute it from the buffer.
004157  2               
004157  2               Execute:
004157  2               ; Save this program's stack pointer so we can restore it later.
004157  2               
004157  2  BA                   TSX
004158  2  8E 22 10             STX THIS_S
00415B  2               
00415B  2               ; Restore registers from saved values.
00415B  2               ; The order is critical here and P must be restored last.
00415B  2               
00415B  2  AE 1C 10             LDX SAVE_S              ; Restore stack pointer
00415E  2  9A                   TXS
00415F  2  AD 1D 10             LDA SAVE_P
004162  2  48                   PHA                     ; Push P
004163  2  AC 1B 10             LDY SAVE_Y              ; Restore Y
004166  2  AE 1A 10             LDX SAVE_X              ; Restore X
004169  2  AD 19 10             LDA SAVE_A              ; Restore A
00416C  2  28                   PLP                     ; Restore P
00416D  2               
00416D  2               ; Call instruction in buffer.
00416D  2               ; It is followed by a JMP ReturnFromTrace so we get back
00416D  2               
00416D  2  4C 30 10             JMP TRACEINST
004170  2               
004170  2               ; We get here if a relative branch being traced was taken.
004170  2               BranchTaken:
004170  2  08                   PHP                     ; Save value of P because INC will change it
004171  2  EE 38 10             INC TAKEN               ; Set flag that branch was taken
004174  2  28                   PLP                     ; Restore P
004175  2                                               ; Fall through to same code as normal return from trace
004175  2               
004175  2               ; We get here after the traced instruction was executed.
004175  2               ReturnFromTrace:
004175  2               
004175  2               ; Save new register values. Opposite order as was restored above.
004175  2               
004175  2  08                   PHP
004176  2  8D 19 10             STA SAVE_A
004179  2  8E 1A 10             STX SAVE_X
00417C  2  8C 1B 10             STY SAVE_Y
00417F  2  68                   PLA
004180  2  8D 1D 10             STA SAVE_P
004183  2  BA                   TSX
004184  2  8E 1C 10             STX SAVE_S
004187  2               
004187  2               ; Clear D mode in case it is set, otherwise it would mess up our code.
004187  2               
004187  2  D8                   CLD
004188  2               
004188  2               ; Restore this program's stack pointer so RTS etc. will still work.
004188  2               
004188  2  AE 22 10             LDX THIS_S
00418B  2  9A                   TXS
00418C  2               
00418C  2               AfterStep:
00418C  2               
00418C  2               ; Special case: If branch was taken (TAKEN=1), need to set next PC accordingly
00418C  2               
00418C  2  AD 38 10             LDA TAKEN
00418F  2  F0 37                BEQ NewPC
004191  2               
004191  2               ; Next PC is Current address (ADDR) + operand (branch offset) + 2
004191  2               
004191  2  A0 01                LDY #1
004193  2  B1 38                LDA (ADDR),Y            ; Branch offset low
004195  2  8D 0D 10             STA REL
004198  2  30 07                BMI Min                 ; If minus, high byte is sign extended to be $FF
00419A  2  A9 00                LDA #0                  ; high byte is zero
00419C  2  8D 0E 10             STA REL+1
00419F  2  F0 05                BEQ Add
0041A1  2               Min:
0041A1  2  A9 FF                LDA #$FF                ; Negative offset, high byte is $FF
0041A3  2  8D 0E 10             STA REL+1
0041A6  2               Add:
0041A6  2  A5 38                LDA ADDR                ; Get current address low byte
0041A8  2  18                   CLC
0041A9  2  6D 0D 10             ADC REL                 ; Add relative offset
0041AC  2  8D 20 10             STA NEXT_PC
0041AF  2  A5 39                LDA ADDR+1              ; Get current address low byte
0041B1  2  6D 0E 10             ADC REL+1               ; Add offset with any carry
0041B4  2  8D 21 10             STA NEXT_PC+1
0041B7  2               
0041B7  2  AD 20 10             LDA NEXT_PC             ; Get low byte of intermediate result
0041BA  2  18                   CLC
0041BB  2  69 02                ADC #2                  ; Add 2
0041BD  2  8D 20 10             STA NEXT_PC
0041C0  2  AD 21 10             LDA NEXT_PC+1           ; Get low byte of intermediate result
0041C3  2  69 00                ADC #0                  ; Add any carry
0041C5  2  8D 21 10             STA NEXT_PC+1
0041C8  2                                               ; Now fall through to code below
0041C8  2               
0041C8  2               ; Set new PC to next PC
0041C8  2               NewPC:
0041C8  2  AD 20 10             LDA NEXT_PC
0041CB  2  8D 1E 10             STA SAVE_PC
0041CE  2  AD 21 10             LDA NEXT_PC+1
0041D1  2  8D 1F 10             STA SAVE_PC+1
0041D4  2               
0041D4  2               ; Display register values
0041D4  2               
0041D4  2  20 6B 27             JSR PrintRegisters
0041D7  2               
0041D7  2               ; Disassemble next instruction (Set ADDR, call DISASM)
0041D7  2               
0041D7  2  AD 1E 10             LDA SAVE_PC
0041DA  2  85 38                STA ADDR
0041DC  2  AD 1F 10             LDA SAVE_PC+1
0041DF  2  85 39                STA ADDR+1
0041E1  2  4C 04 32             JMP DISASM              ; will return via caller
0041E4  2               
0041E4  2               ; Given an instruction opcode, return the instruction's length.
0041E4  2               ; On entry opcode is in OPCODE. Length is returned in LEN.
0041E4  2               ; Also sets opcode type in OP and addressing mode in AM.
0041E4  2               ; Registers changed: A, X
0041E4  2               GetLength:
0041E4  2  AD 09 10             LDA OPCODE
0041E7  2  30 12                BMI @UPPER              ; If bit 7 set, in upper half of table
0041E9  2  0A                   ASL A                   ; double it since table is two bytes per entry
0041EA  2  AA                   TAX
0041EB  2  BD FA 37             LDA OPCODES1,X          ; Get the instruction type (e.g. OP_LDA)
0041EE  2  8D 0A 10             STA OP                  ; Store it
0041F1  2  E8                   INX
0041F2  2  BD FA 37             LDA OPCODES1,X          ; Get addressing mode
0041F5  2  8D 0B 10             STA AM                  ; Store it
0041F8  2  4C 0A 42             JMP @AROUND
0041FB  2               @UPPER:
0041FB  2  0A                   ASL A                   ; Double it since table is two bytes per entry
0041FC  2  AA                   TAX
0041FD  2  BD FA 38             LDA OPCODES2,X          ; Get the instruction type (e.g. OP_LDA)
004200  2  8D 0A 10             STA OP                  ; Store it
004203  2  E8                   INX
004204  2  BD FA 38             LDA OPCODES2,X          ; Get addressing mode
004207  2  8D 0B 10             STA AM                  ; Store it
00420A  2               @AROUND:
00420A  2  AA                   TAX                     ; Put addressing mode in X
00420B  2  BD E1 37             LDA LENGTHS,X           ; Get instruction length given addressing mode
00420E  2  8D 0C 10             STA LEN                 ; Store it
004211  2  60                   RTS                     ; Return
004212  2               
004212  1                 .include "info.s"
004212  2               ; Information Routines
004212  2               ;
004212  2               ; Copyright (C) 2012-2020 by Jeff Tranter <tranter@pobox.com>
004212  2               ;
004212  2               ; Licensed under the Apache License, Version 2.0 (the "License");
004212  2               ; you may not use this file except in compliance with the License.
004212  2               ; You may obtain a copy of the License at
004212  2               ;
004212  2               ;   http://www.apache.org/licenses/LICENSE-2.0
004212  2               ;
004212  2               ; Unless required by applicable law or agreed to in writing, software
004212  2               ; distributed under the License is distributed on an "AS IS" BASIS,
004212  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
004212  2               ; See the License for the specific language governing permissions and
004212  2               ; limitations under the License.
004212  2               ;
004212  2               
004212  2               ; iNfo command
004212  2               ;
004212  2               ; Displays information such as: detected CPU type, clock speed,
004212  2               ;   range of RAM and ROM, detected peripheral cards. etc.
004212  2               ;
004212  2               ; Sample Output:
004212  2               ;
004212  2               ;         Computer: Apple //c
004212  2               ;         CPU type: 65C02
004212  2               ;        CPU speed: 2.0 MHZ
004212  2               ;RAM detected from: $0000 TO $7FFF
004212  2               ;       NMI vector: $0F00
004212  2               ;     RESET vector: $FF00
004212  2               ;   IRQ/BRK vector: $0100
004212  2               ;         ACI card: NOT PRESENT
004212  2               ;       CFFA1 card: NOT PRESENT
004212  2               ;   MULTI I/O card: PRESENT
004212  2               ;        BASIC ROM: PRESENT
004212  2               ;     KRUSADER ROM: PRESENT
004212  2               ;       WOZMON ROM: PRESENT
004212  2               ;Slot ID Type
004212  2               ; 1   31 serial or parallel
004212  2               ; 2   31 serial or parallel
004212  2               ; 3   88 80 column card
004212  2               ; 4   20 joystick or mouse
004212  2               ; 5   -- empty or unknown
004212  2               ; 6   -- empty or unknown
004212  2               ; 7   9B Network or bus interface
004212  2               
004212  2               Info:
004212  2  20 EC 2C             JSR PrintChar           ; Echo command
004215  2  20 71 2C             JSR PrintCR
004218  2               
004218  2  20 A8 2C             JSR Imprint             ; Display computer type
00421B  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00421B  2  20 20 20 20          .asciiz "         Computer: "
00421F  2  20 20 20 20  
004223  2  20 43 6F 6D  
00422F  2               .elseif .defined(OSI)
00422F  2                       .asciiz "      Computer: "
00422F  2               .endif
00422F  2               
00422F  2               .if .defined(APPLE1)
00422F  2                       LDX #<TypeApple1String
00422F  2                       LDY #>TypeApple1String
00422F  2               
00422F  2               .elseif .defined(APPLE2)
00422F  2               
00422F  2               ; Identify model of Apple computer. Algorithm is from Apple //c
00422F  2               ; Reference Manual.
00422F  2               ; ID1 = FBB3
00422F  2               ; ID2 = FBC0
00422F  2               ; if (ID1) = 38
00422F  2               ;   then id = Apple II
00422F  2               ; else if (ID1) = EA
00422F  2               ;   then id = Apple II+
00422F  2               ; else if (ID1) = 06
00422F  2               ;   if (ID2) = EA
00422F  2               ;     then id = Apple //e
00422F  2               ;   else if (ID2) = 00
00422F  2               ;     then id = Apple //c
00422F  2               ; else
00422F  2               ;   id = Unknown
00422F  2               
00422F  2                       ID1 = $FBB3
00422F  2                       ID2 = $FBC0
00422F  2                       LDA ID1
00422F  2                       CMP #$38
00422F  2                       BNE Next1
00422F  2                       LDX #<TypeAppleIIString
00422F  2                       LDY #>TypeAppleIIString
00422F  2                       JMP PrintType
00422F  2               Next1:
00422F  2                       CMP #$EA
00422F  2                       BNE Next2
00422F  2                       LDX #<TypeAppleIIplusString
00422F  2                       LDY #>TypeAppleIIplusString
00422F  2                       JMP PrintType
00422F  2               Next2:
00422F  2                       CMP #$06
00422F  2                       BNE Unknown
00422F  2                       LDA ID2
00422F  2                       CMP #$EA
00422F  2                       BNE Next3
00422F  2                       LDX #<TypeAppleIIeString
00422F  2                       LDY #>TypeAppleIIeString
00422F  2                       JMP PrintType
00422F  2               Next3:
00422F  2                       CMP #$00
00422F  2                       BNE Unknown
00422F  2                       LDX #<TypeAppleIIcString
00422F  2                       LDY #>TypeAppleIIcString
00422F  2                       JMP PrintType
00422F  2               Unknown:
00422F  2                       LDX #<TypeAppleUnknown
00422F  2                       LDY #>TypeAppleUnknown
00422F  2               
00422F  2               .elseif .defined(KIM1)
00422F  2  A2 C2                LDX #<TypeKim1String
004231  2  A0 31                LDY #>TypeKim1String
004233  2               .elseif .defined(OSI)
004233  2                       LDX #<TypeOSIString
004233  2                       LDY #>TypeOSIString
004233  2               .elseif .defined(SBC)
004233  2                       LDX #<TypeSBCString
004233  2                       LDY #>TypeSBCString
004233  2                .endif
004233  2               
004233  2               PrintType:
004233  2  20 86 2C             JSR PrintString
004236  2  20 71 2C             JSR PrintCR
004239  2               
004239  2  20 A8 2C             JSR Imprint             ; Display CPU type
00423C  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00423C  2  20 20 20 20          .asciiz "         CPU type: "
004240  2  20 20 20 20  
004244  2  20 43 50 55  
004250  2               .elseif .defined(OSI)
004250  2                       .asciiz "      CPU type: "
004250  2               .endif
004250  2  20 10 43             JSR CPUType
004253  2  C9 01                CMP #1
004255  2  D0 07                BNE @Try2
004257  2  A2 B1                LDX #<Type6502String
004259  2  A0 31                LDY #>Type6502String
00425B  2  4C 71 42             JMP @PrintCPU
00425E  2               @Try2:
00425E  2  C9 02                CMP #2
004260  2  D0 07                BNE @Try3
004262  2  A2 B6                LDX #<Type65C02String
004264  2  A0 31                LDY #>Type65C02String
004266  2  4C 71 42             JMP @PrintCPU
004269  2               @Try3:
004269  2  C9 03                CMP #3
00426B  2  D0 0A                BNE @Invalid
00426D  2  A2 BC                LDX #<Type65816String
00426F  2  A0 31                LDY #>Type65816String
004271  2               
004271  2               @PrintCPU:
004271  2  20 86 2C             JSR PrintString
004274  2  20 71 2C             JSR PrintCR
004277  2               
004277  2               @Invalid:
004277  2               
004277  2               ; Speed test works on Apple 1 with Multi I/O card or Apple II with
004277  2               ; Super Serial Card or Apple //c with on-board serial.
004277  2               
004277  2               .if .defined(APPLE1) .or .defined (APPLE2)
004277  2               
004277  2               .ifdef APPLE1
004277  2                       JSR MultiIOPresent      ; Can only measure clock speed if we have a Multi I/O card
004277  2               .endif
004277  2               .ifdef APPLE2
004277  2                       JSR SerialPresent       ; Can only measure clock speed if we have a serial port
004277  2               .endif
004277  2                       BEQ @SkipSpeed
004277  2                       JSR Imprint
004277  2                       .asciiz "        CPU speed: "
004277  2                       JSR MeasureCPUSpeed
004277  2                       STA BIN+0
004277  2                       LDA #0
004277  2                       STA BIN+1
004277  2                       JSR BINBCD16
004277  2                       LDA BCD+0               ; Will contain BCD number like $20 for 2.0 MHz
004277  2                       TAX
004277  2                       LSR A
004277  2                       LSR A
004277  2                       LSR A
004277  2                       LSR A
004277  2                       JSR PRHEX
004277  2                       LDA #'.'
004277  2                       JSR PrintChar
004277  2                       TXA
004277  2                       JSR PRHEX
004277  2                       JSR Imprint
004277  2                       .asciiz " MHz"
004277  2                       JSR PrintCR
004277  2               .endif
004277  2               
004277  2               @SkipSpeed:
004277  2  20 A8 2C             JSR Imprint           ; Print range of RAM
00427A  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00427A  2  52 41 4D 20          .asciiz "RAM detected from: $0000 to "
00427E  2  64 65 74 65  
004282  2  63 74 65 64  
004297  2               .elseif .defined(OSI)
004297  2                       .byte "RAM found from: $0000", CR, "            to: ", 0
004297  2               .endif
004297  2  20 FC 2C             JSR PrintDollar
00429A  2  20 41 43             JSR FindTopOfRAM
00429D  2  20 0D 2C             JSR PrintAddress
0042A0  2  20 71 2C             JSR PrintCR
0042A3  2               
0042A3  2  20 A8 2C             JSR Imprint           ; Print NMI vector address
0042A6  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0042A6  2  20 20 20 20          .asciiz "       NMI vector: $"
0042AA  2  20 20 20 4E  
0042AE  2  4D 49 20 76  
0042BB  2               .elseif .defined(OSI)
0042BB  2                       .asciiz "    NMI vector: $"
0042BB  2               .endif
0042BB  2  AE FA FF             LDX $FFFA
0042BE  2  AC FB FF             LDY $FFFB
0042C1  2  20 0D 2C             JSR PrintAddress
0042C4  2  20 71 2C             JSR PrintCR
0042C7  2               
0042C7  2  20 A8 2C             JSR Imprint ; Print reset vector address
0042CA  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0042CA  2  20 20 20 20          .asciiz "     RESET vector: $"
0042CE  2  20 52 45 53  
0042D2  2  45 54 20 76  
0042DF  2               .elseif .defined(OSI)
0042DF  2                       .asciiz "  RESET vector: $"
0042DF  2               .endif
0042DF  2  AE FC FF             LDX $FFFC
0042E2  2  AC FD FF             LDY $FFFD
0042E5  2  20 0D 2C             JSR PrintAddress
0042E8  2  20 71 2C             JSR PrintCR
0042EB  2               
0042EB  2  20 A8 2C             JSR Imprint   ; Print IRQ/BRK vector address
0042EE  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
0042EE  2  20 20 20 49          .asciiz "   IRQ/BRK vector: $"
0042F2  2  52 51 2F 42  
0042F6  2  52 4B 20 76  
004303  2               .elseif .defined(OSI)
004303  2                       .asciiz "IRQ/BRK vector: $"
004303  2               .endif
004303  2  AE FE FF             LDX $FFFE
004306  2  AC FF FF             LDY $FFFF
004309  2  20 0D 2C             JSR PrintAddress
00430C  2  20 71 2C             JSR PrintCR
00430F  2               
00430F  2               .ifdef APPLE1
00430F  2                       JSR Imprint
00430F  2                       .asciiz "         ACI card: "
00430F  2                       JSR ACIPresent
00430F  2                       JSR PrintPresent
00430F  2                       JSR PrintCR
00430F  2               
00430F  2                       JSR Imprint
00430F  2                       .asciiz "       CFFA1 card: "
00430F  2                       JSR CFFA1Present
00430F  2                       JSR PrintPresent
00430F  2                       JSR PrintCR
00430F  2               
00430F  2                       JSR Imprint
00430F  2                       .asciiz "   Multi I/O Card: "
00430F  2                       JSR MultiIOPresent
00430F  2                       JSR PrintPresent
00430F  2                       JSR PrintCR
00430F  2               .endif
00430F  2               
00430F  2               .if .defined(APPLE) .or .defined(OSI)
00430F  2                       JSR Imprint
00430F  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(SBC)
00430F  2                       .asciiz "        BASIC ROM: "
00430F  2               .elseif .defined(OSI)
00430F  2                       .asciiz "     BASIC ROM: "
00430F  2               .endif
00430F  2                       JSR BASICPresent
00430F  2                       JSR PrintPresent
00430F  2                       JSR PrintCR
00430F  2               .endif
00430F  2               
00430F  2               .ifdef APPLE1
00430F  2                       JSR Imprint
00430F  2                       .asciiz "     Krusader ROM: "
00430F  2                       JSR KrusaderPresent
00430F  2                       JSR PrintPresent
00430F  2                       JSR PrintCR
00430F  2               .endif
00430F  2               
00430F  2               .ifdef APPLE1
00430F  2                       JSR Imprint
00430F  2                       .asciiz "       WozMon ROM: "
00430F  2                       JSR WozMonPresent
00430F  2                       JSR PrintPresent
00430F  2                       JSR PrintCR
00430F  2               .endif
00430F  2               
00430F  2               .ifdef APPLE2
00430F  2               ; Display IDs of cards in slots. Uses Pascal 1.1 firmware protocol.
00430F  2               ; Pseudodode:
00430F  2               ; print "Slot ID  Type\n"
00430F  2               ; for s in 1..7
00430F  2               ;   print " s   "
00430F  2               ;   if $Cs05 == $38 and $Cs07 == $18 and $Cn0B == $01
00430F  2               ;     id = $Cs0C
00430F  2               ;     print "id  "
00430F  2               ;     class = ( ID && $F0 ) >> 4
00430F  2               ;      switch class:
00430F  2               ;        case 0: print "reserved"
00430F  2               ;        case 1: print "printer"
00430F  2               ;        case 2: print "joystick or mouse"
00430F  2               ;        case 3: print "serial or parallel"
00430F  2               ;        case 4: print "modem"
00430F  2               ;        case 5: print "sound or speech device"
00430F  2               ;        case 6: print "clock"
00430F  2               ;        case 7: print "mass storage device"
00430F  2               ;        case 8: print "80 column card"
00430F  2               ;        case 9: print "Network or bus interface"
00430F  2               ;        case 10: print "special purpose"
00430F  2               ;        default: print "reserved"
00430F  2               ;   else
00430F  2               ;     print "--  empty or unknown\n"
00430F  2               
00430F  2                       JSR Imprint             ; Print table header
00430F  2                       .asciiz "Slot ID Type"
00430F  2                       JSR PrintCR             ; And newline
00430F  2               
00430F  2                       LDA #1                  ; Initialize slot number
00430F  2                       STA SLOT
00430F  2               Slots:
00430F  2                       JSR PrintSpace          ; Print a space
00430F  2                       LDA SLOT                ; Print slot number
00430F  2                       JSR PRHEX
00430F  2                       LDX #3                  ; Print three spaces
00430F  2                       JSR PrintSpaces
00430F  2               
00430F  2                       LDA SLOT                ; Get slot number
00430F  2                       CLC
00430F  2                       ADC #$C0                ; Calculate $Cs
00430F  2                       STA ADDR+1              ; High byte of address to read
00430F  2               
00430F  2                       LDA #$05                ; Want to read $Cs05
00430F  2                       STA ADDR                ; Low byte of address to read
00430F  2                       LDX #0                  ; Read $Cs05
00430F  2                       LDA (ADDR,X)
00430F  2                       CMP #$38                ; Should be $38 for peripheral card
00430F  2                       BEQ OK1
00430F  2                       JMP EmptySlot
00430F  2               OK1:
00430F  2                       LDA #$07                ; Want to read $Cs07
00430F  2                       STA ADDR                ; Low byte of address to read
00430F  2                       LDX #0                  ; Read $Cs07
00430F  2                       LDA (ADDR,X)
00430F  2                       CMP #$18                ; Should be $18 for peripheral card
00430F  2                       BEQ OK2
00430F  2                       JMP EmptySlot
00430F  2               OK2:
00430F  2                       LDA #$0B                ; Want to read $Cs0B
00430F  2                       STA ADDR                ; Low byte of address to read
00430F  2                       LDX #0                  ; Read $Cs0B
00430F  2                       LDA (ADDR,X)
00430F  2                       CMP #$01                ; Should be $01 for peripheral card
00430F  2                       BEQ OK3
00430F  2                       JMP EmptySlot
00430F  2               OK3:
00430F  2                       LDA #$0C                ; Want to read $Cs0C
00430F  2                       STA ADDR                ; Low byte of address to read
00430F  2                       LDX #0                  ; Read $Cs0C
00430F  2                       LDA (ADDR,X)            ; This is the card ID
00430F  2                       PHA                     ; Save A
00430F  2                       JSR PrintByte           ; Print card ID
00430F  2                       JSR PrintSpace          ; Then a space
00430F  2                       PLA                     ; Restore A (Card ID)
00430F  2                       AND #$F0                ; Mask off class portion of ID (upper nybble)
00430F  2                       LSR                     ; Shift into lower nybble
00430F  2                       LSR
00430F  2                       LSR
00430F  2                       LSR
00430F  2                       CMP #$00                ; Is it class 0?
00430F  2                       BNE Try1                ; If not, try next class.
00430F  2                       JSR Imprint             ; Display class
00430F  2                       .asciiz "reserved"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try1:
00430F  2                       CMP #$01
00430F  2                       BNE Try2
00430F  2                       JSR Imprint
00430F  2                       .asciiz "printer"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try2:
00430F  2                       CMP #$02
00430F  2                       BNE Try3
00430F  2                       JSR Imprint
00430F  2                       .asciiz "joystick or mouse"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try3:
00430F  2                       CMP #$03
00430F  2                       BNE Try4
00430F  2                       JSR Imprint
00430F  2                       .asciiz "serial or parallel"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try4:
00430F  2                       CMP #$04
00430F  2                       BNE Try5
00430F  2                       JSR Imprint
00430F  2                       .asciiz "modem"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try5:
00430F  2                       CMP #$05
00430F  2                       BNE Try6
00430F  2                       JSR Imprint
00430F  2                       .asciiz "sound or speech device"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try6:
00430F  2                       CMP #$06
00430F  2                       BNE Try7
00430F  2                       JSR Imprint
00430F  2                       .asciiz "clock"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try7:
00430F  2                       CMP #$07
00430F  2                       BNE Try8
00430F  2                       JSR Imprint
00430F  2                       .asciiz "mass storage device"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try8:
00430F  2                       CMP #$08
00430F  2                       BNE Try9
00430F  2                       JSR Imprint
00430F  2                       .asciiz "80 column card"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try9:
00430F  2                       CMP #$09
00430F  2                       BNE Try10
00430F  2                       JSR Imprint
00430F  2                       .asciiz "network or bus interface"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Try10:
00430F  2                       CMP #$0A
00430F  2                       BNE Default
00430F  2                       JSR Imprint
00430F  2                       .asciiz "special purpose"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               Default:
00430F  2                       JSR Imprint
00430F  2                       .asciiz "future expansion"
00430F  2                       JSR PrintCR
00430F  2                       JMP NextSlot
00430F  2               EmptySlot:
00430F  2                       JSR Imprint
00430F  2                       .asciiz "-- empty or unknown"
00430F  2                       JSR PrintCR
00430F  2               NextSlot:
00430F  2                       LDA SLOT                ; Get current slot
00430F  2                       CLC                     ; Add one
00430F  2                       ADC #1
00430F  2                       STA SLOT
00430F  2                       CMP #8                  ; Are we done?
00430F  2                       BEQ Done                ; Yes, done.
00430F  2                       JMP Slots               ; No, do next slot.
00430F  2               Done:
00430F  2               .endif
00430F  2  60                   RTS
004310  2               
004310  2               ; Determine type of CPU. Returns result in A.
004310  2               ; 1 - 6502, 2 - 65C02, 3 - 65816.
004310  2               ; Algorithm taken from Western Design Center programming manual.
004310  2               
004310  2               CPUType:
004310  2  F8                   SED           ; Trick with decimal mode used
004311  2  A9 99                LDA #$99      ; Set negative flag
004313  2  18                   CLC
004314  2  69 01                ADC #$01      ; Add 1 to get new accumulator value of 0
004316  2  30 0D                BMI O2        ; 6502 does not clear negative flag so branch taken.
004318  2               
004318  2               ; 65C02 and 65816 clear negative flag in decimal mode
004318  2               
004318  2  18                   CLC
004319  2                       .p816         ; Following Instruction is 65816
004319  2  FB                   XCE           ; Valid on 65816, unimplemented NOP on 65C02
00431A  2  90 05                BCC C02       ; On 65C02 carry will still be clear and branch will be taken.
00431C  2  FB                   XCE           ; Switch back to emulation mode
00431D  2                       .p02          ; Go back to 6502 assembler mode
00431D  2  D8                   CLD
00431E  2  A9 03                LDA #3        ; 65816
004320  2  60                   RTS
004321  2               C02:
004321  2  D8                   CLD
004322  2  A9 02                LDA #2        ; 65C02
004324  2  60                   RTS
004325  2               O2:
004325  2  D8                   CLD
004326  2  A9 01                LDA #1        ; 6502
004328  2  60                   RTS
004329  2               
004329  2               ; Based on the value in A, displays "present" (1) or "not present" (0).
004329  2               
004329  2               PrintPresent:
004329  2  C9 00                CMP #0
00432B  2  D0 08                BNE @Present
00432D  2  20 A8 2C             JSR Imprint
004330  2  6E 6F 74 20          .asciiz "not "
004334  2  00           
004335  2               @Present:
004335  2  20 A8 2C             JSR Imprint
004338  2  70 72 65 73          .asciiz "present"
00433C  2  65 6E 74 00  
004340  2  60                   RTS
004341  2               
004341  2               ; Determines top of installed RAM while trying not to corrupt any other
004341  2               ; program including this one. We assume RAM starts at 0. Returns top
004341  2               ; RAM address in X (low), Y (high).
004341  2               
004341  2                LIMIT = $FFFF        ; Highest address we want to test
004341  2                TOP   = $00          ; Holds current highest address of RAM (two bytes)
004341  2               
004341  2               FindTopOfRAM:
004341  2               
004341  2  A9 02                LDA #<$0002         ; Store $0002 in TOP (don't want to change TOP)
004343  2  85 00                STA TOP
004345  2  A9 00                LDA #>$0002
004347  2  85 01                STA TOP+1
004349  2               
004349  2               @Loop:
004349  2  A0 00                LDY #0
00434B  2  B1 00                LDA (TOP),Y         ; Read current contents of (TOP)
00434D  2  AA                   TAX                 ; Save in register so we can later restore it
00434E  2  A9 00                LDA #0              ; Write all zeroes to (TOP)
004350  2  91 00                STA (TOP),Y
004352  2  D1 00                CMP (TOP),Y         ; Does it read back?
004354  2  D0 42                BNE @TopFound       ; If not, top of memory found
004356  2  A9 FF                LDA #$FF            ; Write all ones to (TOP)
004358  2  91 00                STA (TOP),Y
00435A  2  D1 00                CMP (TOP),Y         ; Does it read back?
00435C  2  D0 3A                BNE @TopFound       ; If not, top of memory found
00435E  2  A9 AA                LDA #$AA            ; Write alternating bits to (TOP)
004360  2  91 00                STA (TOP),Y
004362  2  D1 00                CMP (TOP),Y         ; Does it read back?
004364  2  D0 32                BNE @TopFound       ; If not, top of memory found
004366  2  A9 55                LDA #$55            ; Write alternating bits to (TOP)
004368  2  91 00                STA (TOP),Y
00436A  2  D1 00                CMP (TOP),Y         ; Does it read back?
00436C  2  D0 2A                BNE @TopFound       ; If not, top of memory found
00436E  2               
00436E  2  8A                   TXA                 ; Write original data back to (TOP)
00436F  2  91 00                STA (TOP),Y
004371  2               
004371  2  A5 00                LDA TOP             ; Increment TOP (low,high)
004373  2  18                   CLC
004374  2  69 01                ADC #1
004376  2  85 00                STA TOP
004378  2  A5 01                LDA TOP+1
00437A  2  69 00                ADC #0              ; Add any carry
00437C  2  85 01                STA TOP+1
00437E  2               
00437E  2               ;  Are we testing in the range of this code (i.e. the same 256 byte
00437E  2               ;  page)? If so, need to skip over it because otherwise the memory
00437E  2               ;  test will collide with the code being executed when writing to it.
00437E  2               
00437E  2  A5 01                LDA TOP+1           ; High byte of page
004380  2  C9 43                CMP #>FindTopOfRAM  ; Same page as this code?
004382  2  F0 06                BEQ @Skip
004384  2  C9 43                CMP #>FindTopOfRAMEnd ; Same page as this code (code could cross two pages)
004386  2  F0 02                BEQ @Skip
004388  2  D0 02                BNE @NotUs
00438A  2               @Skip:
00438A  2  E6 01                INC TOP+1           ; Skip over this page when testing
00438C  2               
00438C  2               @NotUs:
00438C  2               
00438C  2  A5 01                LDA TOP+1           ; Did we reach LIMIT? (high byte)
00438E  2  C9 FF                CMP #>LIMIT
004390  2  D0 B7                BNE @Loop           ; If not, keep looping
004392  2  A5 00                LDA TOP             ; Did we reach LIMIT? (low byte)
004394  2  C9 FF                CMP #<LIMIT
004396  2  D0 B1                BNE @Loop           ; If not, keep looping
004398  2               
004398  2               @TopFound:
004398  2  8A                   TXA                 ; Write original data back to (TOP) just in case it is important
004399  2  91 00                STA (TOP),Y
00439B  2               
00439B  2               FindTopOfRAMEnd:            ; End of critical section we don't want to write to during testing
00439B  2               
00439B  2  A5 00                LDA TOP             ; Decrement TOP by 1 to get last RAM address
00439D  2  38                   SEC
00439E  2  E9 01                SBC #1
0043A0  2  85 00                STA TOP
0043A2  2  A5 01                LDA TOP+1
0043A4  2  E9 00                SBC #0              ; Subtract any borrow
0043A6  2  85 01                STA TOP+1
0043A8  2               
0043A8  2  A6 00                LDX TOP             ; Set top of RAM as TOP (X-low Y-high)
0043AA  2  A4 01                LDY TOP+1
0043AC  2               
0043AC  2  60                   RTS                 ; Return
0043AD  2               
0043AD  2               ; Measure CPU clock speed by sending characters out the serial port of
0043AD  2               ; a Multi I/O board and counting how many CPU cycles it takes. Returns
0043AD  2               ; value in A that is approximately CPU speed in MHz * 10.
0043AD  2               
0043AD  2               .if .defined(APPLE1) .or .defined(APPLE2)
0043AD  2               
0043AD  2               MeasureCPUSpeed:
0043AD  2               
0043AD  2               .ifdef APPLE1
0043AD  2               ; 6551 Chip registers
0043AD  2                       TXDATA = $C300
0043AD  2                       RXDATA = $C300
0043AD  2                       STATUSREG = $C301
0043AD  2                       CMDREG = $C302
0043AD  2                       CTLREG = $C303
0043AD  2               .endif
0043AD  2               
0043AD  2               .ifdef APPLE2
0043AD  2               ; 6551 Chip registers
0043AD  2                       TXDATA = $C098
0043AD  2                       RXDATA = $C098
0043AD  2                       STATUSREG = $C099
0043AD  2                       CMDREG = $C09A
0043AD  2                       CTLREG = $C09B
0043AD  2               .endif
0043AD  2               
0043AD  2               ; Set 1 stop bit, 8 bit data, internal clock, 19200bps
0043AD  2                       LDA #%00011111
0043AD  2                       STA CTLREG
0043AD  2               
0043AD  2               ; Set no parity, no echo, no TX interrupts, RTS low, no RX interrupts, DTR low
0043AD  2                      LDA #%00001011
0043AD  2                      STA CMDREG
0043AD  2               
0043AD  2                       LDA #'A'  ; Character to send
0043AD  2                       LDX #0    ; Counter
0043AD  2                       JSR Echo
0043AD  2                       JSR Echo
0043AD  2                       JSR Echo
0043AD  2                       TXA
0043AD  2                       RTS
0043AD  2               
0043AD  2               ; Send character in A out serial port
0043AD  2               Echo:
0043AD  2                       PHA
0043AD  2                       LDA #$10
0043AD  2               TXFULL: INX
0043AD  2                       LDY #8          ; Add additional delay
0043AD  2               @Delay: DEY
0043AD  2                       BNE @Delay
0043AD  2                       NOP
0043AD  2                       NOP
0043AD  2                       BIT STATUSREG ; wait for TDRE bit = 1
0043AD  2                       BEQ TXFULL
0043AD  2                       PLA
0043AD  2                       STA TXDATA
0043AD  2                       RTS
0043AD  2               .endif
0043AD  2               
0043AD  1                 .include "memtest4.s"
0043AD  2               ; Memory test.
0043AD  2               ; Downloaded from http://www.willegal.net/appleii/6502mem.htm and adapted to the CC65 assembler.
0043AD  2               
0043AD  2               ; MACROS
0043AD  2               ;
0043AD  2               ; INITIALIZE ADDRESS WITH START
0043AD  2                       .macro INI_ADDRS
0043AD  2                       LDA START
0043AD  2                       STA ADDRS
0043AD  2                       LDA START + $01
0043AD  2                       STA ADDRS + $01
0043AD  2                       .endmacro
0043AD  2               
0043AD  2               ; INCREMENT ADDRESS
0043AD  2                       .macro INC_ADDRSC
0043AD  2                       INC ADDRS
0043AD  2                       BNE @SKIP_HI
0043AD  2                       INC ADDRS+$01
0043AD  2                @SKIP_HI:
0043AD  2                       LDA END
0043AD  2                       CMP ADDRS
0043AD  2                       BNE @EXIT2
0043AD  2                       LDA END+$01
0043AD  2                       CMP ADDRS+$01
0043AD  2                @EXIT2:
0043AD  2                      .endmacro
0043AD  2               
0043AD  2               ; SET TEST PATTERN
0043AD  2               ; only for tests 4 and 5 (address in address tests), make address High or Low
0043AD  2               ; equal to pattern
0043AD  2               ; test 4 is LSB of address
0043AD  2               ; test 5 is MSB of address
0043AD  2               ;
0043AD  2                       .macro         SET_PATRN
0043AD  2                       CPY        #4
0043AD  2                       BNE         @TEST5
0043AD  2                       LDA        ADDRS
0043AD  2                       STA        TEST_PATRN
0043AD  2               @TEST5:
0043AD  2                       CPY        #5
0043AD  2                       BNE         @EXIT1
0043AD  2                       LDA        ADDRS+$01
0043AD  2                       STA        TEST_PATRN
0043AD  2               @EXIT1:
0043AD  2                       .endmacro
0043AD  2               
0043AD  2               ; start of program
0043AD  2               ;
0043AD  2               ; TESTS TYPE
0043AD  2               ;        0 = all zeros
0043AD  2               ;        1 = all ones
0043AD  2               ;        2 = floating 1s
0043AD  2               ;        3 = floating 0s
0043AD  2               ;        4 = address in address (LS 8 address bits)
0043AD  2               ;        5 = address in address (MS 8 address bits)
0043AD  2               
0043AD  2               MEM_TEST:
0043AD  2  18                   CLC
0043AE  2  AD 13 10             LDA END
0043B1  2  69 01                ADC #1                ; add 1 to END since test goes to END-1
0043B3  2  8D 13 10             STA END
0043B6  2  AD 14 10             LDA END+1
0043B9  2  69 00                ADC #0               ; add possible carry
0043BB  2  8D 14 10             STA END+1
0043BE  2  A9 00                LDA #$00
0043C0  2  85 3D                STA PASSES                ; start at pass 0
0043C2  2               REPEAT:
0043C2  2  A9 00                LDA #$00
0043C4  2  A8                   TAY                        ; TEST # in REG Y
0043C5  2  AA                   TAX                        ; X must be zero
0043C6  2  85 3C                STA TEST_PATRN           ; first pass all zeros
0043C8  2               NX_PASS:
0043C8  2  AD 11 10 85          INI_ADDRS
0043CC  2  3A AD 12 10  
0043D0  2  85 3B        
0043D2  2               LOOP1:
0043D2  2  C0 04 D0 04          SET_PATRN                       ; sets up TEST_PATRN for address in address test
0043D6  2  A5 3A 85 3C  
0043DA  2  C0 05 D0 04  
0043E2  2  A5 3C                LDA        TEST_PATRN
0043E4  2  81 3A                STA        (ADDRS, X)           ; STORE PATTERN
0043E6  2  20 A9 2D             JSR        DELAY                ; delay after writing to EEPROM
0043E9  2  A1 3A                LDA        (ADDRS, X)           ; READ (save result of read in case of error)
0043EB  2  C5 3C                CMP        TEST_PATRN           ; CHECK
0043ED  2  D0 32                BNE        LOOP_ERR2            ; branch if error
0043EF  2  E6 3A D0 02          INC_ADDRSC
0043F3  2  E6 3B AD 13  
0043F7  2  10 C5 3A D0  
004401  2  D0 CF                BNE        LOOP1
004403  2               
004403  2               CK_PATRN:
004403  2  AD 11 10 85          INI_ADDRS         ; INITIALISE ADDRS
004407  2  3A AD 12 10  
00440B  2  85 3B        
00440D  2               
00440D  2               LOOP2:
00440D  2  C0 04 D0 04          SET_PATRN                       ; sets up TEST_PATRN for address in address test
004411  2  A5 3A 85 3C  
004415  2  C0 05 D0 04  
00441D  2  A1 3A                LDA         (ADDRS, X)          ; READ (save result of read in case of error)
00441F  2  C5 3C                CMP        TEST_PATRN           ; CHECK
004421  2               LOOP_ERR2:
004421  2  D0 5F                BNE         LOOP_ERR            ; branch if error
004423  2  E6 3A D0 02          INC_ADDRSC
004427  2  E6 3B AD 13  
00442B  2  10 C5 3A D0  
004435  2  D0 D6                BNE LOOP2
004437  2               ;
004437  2               ; Pass Complete - see what is next
004437  2               ;
004437  2  C0 00                CPY        #0                ; test 0 - all zeros complete
004439  2  D0 08                BNE        CHK_TEST1
00443B  2               ;
00443B  2               ; move to test 1
00443B  2               ;
00443B  2               
00443B  2  A9 FF                LDA        #$FF
00443D  2               NX_TEST:
00443D  2  85 3C                STA        TEST_PATRN
00443F  2  C8                   INY                        ; move to next test
004440  2               NX_PASS3:
004440  2               NX_PASS1:
004440  2               NX_PASS2:
004440  2  4C C8 43             JMP        NX_PASS
004443  2               
004443  2               CHK_TEST1:
004443  2  C0 01                CPY        #1                ; all ones complete?
004445  2  D0 04                BNE        CHK_TEST2
004447  2               
004447  2               ; test 1 - all zeros complete
004447  2               
004447  2  A9 01                LDA        #$01
004449  2  D0 F2                BNE        NX_TEST        ; always
00444B  2               
00444B  2               CHK_TEST2:
00444B  2  C0 02                CPY        #2                ; floating 1s in progress or done
00444D  2  D0 08                BNE        CHK_TEST3
00444F  2               ;
00444F  2               ; pass of test 2 complete - 8 passes in all with 1 in each bit position
00444F  2               ;
00444F  2  06 3C                ASL         TEST_PATRN                ; shift left - zero to LSB- MSB to CARRY
004451  2  90 ED                BCC        NX_PASS1
004453  2               ;
004453  2               ; all test 2 passes complete - prepase for test 3
004453  2               ;
004453  2  A9 7F                LDA        #$7F
004455  2  D0 E6                BNE        NX_TEST                ;always branch
004457  2               
004457  2               CHK_TEST3:                ;floating zeros in progress or done
004457  2  C0 03                CPY        #3
004459  2  D0 08                BNE        CHK_TEST4
00445B  2               ;
00445B  2               ; pass of test 3 complete - 8 passes in all with 0 in each bit position
00445B  2               ;
00445B  2  38                   SEC
00445C  2  66 3C                ROR        TEST_PATRN        ; rotate right - Carry to MSB, LSB to Carry
00445E  2  B0 E0                BCS        NX_PASS2        ; keep going until zero bit reaches carry
004460  2               
004460  2               NXT_ADDR_TEST:
004460  2  C8                   INY                        ; move to test 4 or 5 - address in address
004461  2  D0 DD                BNE        NX_PASS3        ; aways
004463  2               ;
004463  2               ; ADDRESS IN ADDRESS tests - two test only make one pass each
004463  2               ;
004463  2               CHK_TEST4:
004463  2  C0 04                CPY        #4                ; address in address (low done)?
004465  2  F0 F9                BEQ        NXT_ADDR_TEST        ; if test 4 done, start test 5
004467  2               
004467  2               ; test 5 complete - we have finished a complete pass
004467  2               TESTDONE:                        ; print done and stop
004467  2  20 A8 2C             JSR        Imprint
00446A  2  50 61 73 73          .asciiz "Pass "
00446E  2  20 00        
004470  2  E6 3D                INC        PASSES
004472  2  A5 3D                LDA        PASSES
004474  2  20 D9 2C             JSR        PrintByte
004477  2  20 71 2C             JSR        PrintCR
00447A  2               .if .defined(APPLE1)
00447A  2               ; Stop if key pressed
00447A  2                       BIT        $D011 ; Keyboard CR
00447A  2                       BMI        KeyPressed
00447A  2                       JMP        REPEAT
00447A  2               KeyPressed:
00447A  2                       LDA        $D010 ; Keyboard data
00447A  2                       JMP        FINISHED
00447A  2               .elseif .defined(APPLE2)
00447A  2               ; Stop if key pressed
00447A  2                       BIT        $C000 ; Keyboard register
00447A  2                       BMI        KeyPressed
00447A  2                       JMP        REPEAT
00447A  2               KeyPressed:
00447A  2                       STA        $C010 ; Clear keyboard strobe
00447A  2                       JMP        FINISHED
00447A  2               .elseif .defined(OSI)
00447A  2                       LDA        #$00
00447A  2                       STA        $DF00  ; Select all keyboard rows
00447A  2                       LDA        $DF00  ; Read columns
00447A  2                       ORA        #$01   ; Set bit for possible shift lock key
00447A  2                       CMP        #$FF   ; All bits set means no key pressed
00447A  2                       BNE        KeyPressed
00447A  2                       JMP        REPEAT
00447A  2               KeyPressed:
00447A  2                       JMP        FINISHED
00447A  2               .elseif .defined(KIM1)
00447A  2               
00447A  2               ; Can't find any way to detect keypress on KIM-1 without blocking, so
00447A  2               ; just prompt user.
00447A  2  20 64 2D             JSR        PromptToContinue
00447D  2  B0 4E                BCS        FINISHED           ; done
00447F  2  4C C2 43             JMP        REPEAT             ; continue
004482  2               .elseif .defined(SBC)
004482  2                       JSR        MONRDKEY
004482  2                       BCS        FINISHED           ; done
004482  2                       JMP        REPEAT             ; continue
004482  2               .endif
004482  2               
004482  2               ; OUTPUT THE ERROR INFO and STOP
004482  2               ; TEST#, ADDRESS, PATTERN, ERROR
004482  2               LOOP_ERR:
004482  2  48                   PHA
004483  2  8C 07 10             STY     LZ                     ; test # is in Y
004486  2  20 A8 2C             JSR     Imprint
004489  2  45 72 72 6F          .asciiz "Error: "
00448D  2  72 3A 20 00  
004491  2  AD 07 10             LDA     LZ
004494  2  20 D9 2C             JSR     PrintByte                ; test #
004497  2  20 A8 2C             JSR     Imprint
00449A  2  20 41 64 64          .asciiz " Addr: "
00449E  2  72 3A 20 00  
0044A2  2  A5 3B                LDA     ADDRS + $01
0044A4  2  20 D9 2C             JSR     PrintByte                 ; OUTPUT ADDRS HI
0044A7  2  A5 3A                LDA     ADDRS
0044A9  2  20 D9 2C             JSR     PrintByte                 ; OUTPUT ADDRS LO
0044AC  2  20 A8 2C             JSR     Imprint
0044AF  2  20 45 78 70          .asciiz " Exp: "
0044B3  2  3A 20 00     
0044B6  2  A5 3C                LDA     TEST_PATRN
0044B8  2  20 D9 2C             JSR     PrintByte                 ; OUTPUT EXPECTED
0044BB  2  20 A8 2C             JSR     Imprint
0044BE  2  20 52 65 61          .asciiz " Read: "
0044C2  2  64 3A 20 00  
0044C6  2  68                   PLA
0044C7  2  20 D9 2C             JSR     PrintByte                 ; OUTPUT ACTUAL
0044CA  2  20 71 2C             JSR      PrintCR
0044CD  2               FINISHED:
0044CD  2  60                   RTS
0044CE  2               
0044CE  1                 .include "delay.s"
0044CE  2               ; Copyright (C) 2012-2016 by Jeff Tranter <tranter@pobox.com>
0044CE  2               ;
0044CE  2               ; Licensed under the Apache License, Version 2.0 (the "License");
0044CE  2               ; you may not use this file except in compliance with the License.
0044CE  2               ; You may obtain a copy of the License at
0044CE  2               ;
0044CE  2               ;   http://www.apache.org/licenses/LICENSE-2.0
0044CE  2               ;
0044CE  2               ; Unless required by applicable law or agreed to in writing, software
0044CE  2               ; distributed under the License is distributed on an "AS IS" BASIS,
0044CE  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0044CE  2               ; See the License for the specific language governing permissions and
0044CE  2               ; limitations under the License.
0044CE  2               
0044CE  2               ; Delay routine. Taken from the Apple II ROM routine at $FCA8.
0044CE  2               ; Delay in clock cycles is 13 + 27/2 * A + 5/2 * A * A
0044CE  2               ; Changes registers: A
0044CE  2               ; Also see: chapter 3 of "Assembly Cookbook for the Apple II/IIe"
0044CE  2               ; for more details on how to use it.
0044CE  2               
0044CE  2  38           WAIT:    SEC
0044CF  2  48           WAIT2:   PHA
0044D0  2  E9 01        WAIT3:   SBC   #$01
0044D2  2  D0 FC                 BNE   WAIT3
0044D4  2  68                    PLA              ; (13+27/2*A+5/2*A*A)
0044D5  2  E9 01                 SBC   #$01
0044D7  2  D0 F6                 BNE   WAIT2
0044D9  2  60                    RTS
0044DA  2               
0044DA  1               
0044DA  1               ; Non-Page Zero Variables. Note: These must be in RAM. Use a .org
0044DA  1               ; below corresponding to RAM if the program is linked into ROM.
0044DA  1               .org $1000
001000  1               
001000  1  xx           T2:       .res 1                ; Temp variable 2
001001  1  xx           RETOK:    .res 1                ; Sets whether <Return> key is accepted in some input routines
001002  1  xx           BIN:      .res 1                ; Holds binary value low byte
001003  1  xx           BINH:     .res 1                ; Holds binary value high byte
001004  1  xx xx xx     BCD:      .res 3                ; Holds BCD decimal number (3 bytes)
001007  1  xx           LZ:       .res 1                ; Boolean for leading zero suppression
001008  1  xx           LAST:     .res 1                ; Boolean for leading zero suppression / indicates last byte
001009  1  xx           OPCODE:   .res 1                ; Instruction opcode
00100A  1  xx           OP:       .res 1                ; Instruction type OP_*
00100B  1  xx           AM:       .res 1                ; Addressing mode AM_*
00100C  1  xx           LEN:      .res 1                ; Instruction length
00100D  1  xx xx        REL:      .res 2                ; Relative addressing branch offset (2 bytes)
00100F  1  xx xx        DEZT:     .res 2                ; Relative address destination address (2 bytes)
001011  1  xx xx        START:    .res 2                ; Memory test - user entered start of memory range. Min is 8 (2 bytes)
001013  1  xx xx        END:      .res 2                ; Memory test - user entered end of memory range (2 bytes)
001015  1  xx xx xx xx  BPD:      .res 4                ; Instruction at breakpoint (1 byte * 4 breakpoints)
001019  1  xx           SAVE_A:   .res 1                ; Holds saved values of registers
00101A  1  xx           SAVE_X:   .res 1                ; "
00101B  1  xx           SAVE_Y:   .res 1                ; "
00101C  1  xx           SAVE_S:   .res 1                ; "
00101D  1  xx           SAVE_P:   .res 1                ; "
00101E  1  xx xx        SAVE_PC:  .res 2                ; "
001020  1  xx xx        NEXT_PC:  .res 2                ; Value of PC after next instruction
001022  1  xx           THIS_S:   .res 1                ; Saved value of JMON's stack pointer
001023  1  xx           CHAROK:   .res 1                ; Set to 1 if okay to enter characters prefixed by '
001024  1  xx           CHARMODE: .res 1                ; Set if currently entering in character (ASCII) mode
001025  1  xx           OWDELAY:   .res 1               ; Delay value when writing (defaults to zero)
001026  1  xx           OUPPER:   .res 1                ; Set to $FF when only uppercase output is is desired.
001027  1  xx           OHIGHASCII: .res 1              ; Set to $FF when characters should have high bit set
001028  1  xx           OCPU:      .res 1               ; CPU type for disassembly
001029  1  xx           MBIT:      .res 1               ; For 65816 disassembly, tracks state of M bit in P
00102A  1  xx           XBIT:      .res 1               ; For 65816 disassembly, tracks state of X bit in P
00102B  1               .ifdef MINIASM
00102B  1  xx xx xx     MNEM:      .res 3               ; Hold three letter mnemonic string used by assembler
00102E  1  xx xx        OPERAND:   .res 2               ; Holds any operands for assembled instruction
001030  1               .endif
001030  1  xx xx xx xx  TRACEINST: .res 8               ; buffer holding traced instruction followed by a JMP and optionally another jump (Up to 8 bytes)
001034  1  xx xx xx xx  
001038  1  xx           TAKEN:     .res 1               ; Flag indicating if a traced branch instruction was taken
001039  1               .if .defined(APPLE2)
001039  1               SLOT:      .res 1               ; Holds current peripheral card slot number
001039  1               .endif
001039  1  xx           XSAV2:     .res 1               ; Saved registers
00103A  1  xx           YSAV2:     .res 1
00103B  1  xx           ASAV2:     .res 1
00103C  1               
00103C  1  xx           temp1:     .res 1               ; Temporary value
00103D  1  xx           checksum:  .res 1               ; Calculated checksum
00103E  1  xx           bytesRead: .res 1               ; Number of record bytes read
00103F  1  xx           recordType: .res 1              ; S record type field, e.g '9'
001040  1  xx           byteCount: .res 1               ; S record byte count field
001041  1  xx           bytesWritten: .res 1            ; Number of record bytes written
001041  1               
