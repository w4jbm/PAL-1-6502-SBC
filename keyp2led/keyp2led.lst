
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass --intel-hex --tab-size=1 -o keyp2led.hex -m --verbose-list -L keyp2led.lst keyp2led.a65
; Wed Sep 14 12:15:02 2022

;Offset ;Hex            ;Source

;******  Processing input file: keyp2led.a65

                        ; This program will display whatever is typed on the keypad
                        ; to the PAL-1's LEDs
                        ;
                        ; By Jim McClanahan, W4JBM, Sept 2022
                        ;
                        ; Build with:
                        ; $ 64tass --intel-hex keyp2led.a65 -o keyp2led.hex -m --verbose-list -L keyp2led.lst
                        ; $ srec_cat keyp2led.hex -intel -o keyp2led.mos -MOS_Technologies
                        ; $ unix2dos keyp2led.mos
                        ; $ cp keyp2led.mos ~
                        ;
                        ; Rev 1 was really just a quick proof of concept...
                        ;
                        ; Rev 2 moved the bit shifting logic into a subroutine to
                        ; reduce the size by reducing redundant code. Also I noticed
                        ; the display would remain blank until you let up on the key
                        ; because of how I was handling the debounce/repeat condition
                        ; so added a call to SCAND to that loop. Now it is just a bit
                        ; improved quick proof of concept. :-)

                        ; Set the Page Zero locations for digits 12, 34, and 56...
=$fb                    dig12      = $fb
=$fa                    dig34      = $fa
=$f9                    dig56      = $f9

                        ; We need a temporary storage location
=$fd                    tmpx     = $fd

                        ; We will use the SCAND routine in ROM to display the values
=$1f1f                  scand      = $1f1f

                        ; and the GETKEY routine to poll the keyboard
=$1f6a                  getkey     = $1f6a


                        *          = $0200

.0200   d8              init:      cld             ; Always clear decimal
.0201   a9 00                      lda #$00        ; Zero out the display
.0203   85 fb                      sta dig12
.0205   85 fa                      sta dig34
.0207   85 f9                      sta dig56

.0209   20 1f 1f        loop:      jsr scand       ; Light up the LEDs
.020c   20 6a 1f                   jsr getkey      ; Scan the keypad
.020f   c9 15                      cmp #$15        ; Was anything pressed?
.0211   f0 f6                      beq loop        ; If not, loop...

                        ; A key on the keypad has been pressed, so what do we do?

.0213   c9 10                      cmp #$10        ; Is it a (hex) digit?
.0215   b0 32                      bcs functn      ; If not, process as a function

.0217   85 fd                      sta tmpx        ; If a digit, store a copy for later

                        ; We need to shift the contents of dig12, dig34, and dig56 four
                        ; bits (one nibble or one digit) to the left to make room for
                        ; the number that has just been entered. A subroutine does the
                        ; heavy lifting one bit at a time.

.0219   20 38 02        bitshft1:  jsr bitshft     ; Shift bits up one...
.021c   20 38 02        bitshft2:  jsr bitshft     ; ...two...
.021f   20 38 02        bitshft3:  jsr bitshft     ; ...three...
.0222   20 38 02        bitshft4:  jsr bitshft     ; ...and four bits.

                        ; We made space in the right most digit with our shifts,
                        ; so now let's put the digit that was pressed there.

.0225   a5 fd           newnum:    lda tmpx        ; Now add the new number to the...
.0227   05 f9                      ora dig56       ; ...last nibble of dig56
.0229   85 f9                      sta dig56

                        ; We now keep looping until the key has been released...
                        ;
                        ; Note: The call the SCAND was added because without it
                        ; the display would "go dark" until you let up on the key.

.022b   20 1f 1f        wait:      jsr scand       ; Display the updated contents
.022e   20 6a 1f                   jsr getkey      ; Assembly code blazes, so we keep
.0231   c5 fd                      cmp tmpx        ; checking which key is pressed until
.0233   f0 f6                      beq wait        ; it changes before we loop back
.0235   4c 09 02                   jmp loop


                        ; This subroutine shifts the bits to clear room for the
                        ; new nibble at the end of the memory locations. It is called
                        ; four times (once for each bit in the nibble).

.0238   18              bitshft:   clc             ; Shift bits up through the...
.0239   a5 f9                      lda dig56       ; one...
.023b   2a                         rol a
.023c   85 f9                      sta dig56

.023e   a5 fa                      lda dig34       ; two...
.0240   2a                         rol a
.0241   85 fa                      sta dig34

.0243   a5 fb                      lda dig12       ; three bytes
.0245   2a                         rol a
.0246   85 fb                      sta dig12

.0248   60                         rts             ; Our work here is done...

                        ; This is where we can put some type of function to handle the
                        ; press of any non-numberic keys on the keypad.

.0249   ea              functn:    nop             ; We get here if a non-numberic key was pressed
.024a   4c 09 02                   jmp loop        ; ...for now, just loop

;******  End of listing
