ca65 V2.18 - Ubuntu 2.18-1
Main file   : jmon.s
Current file: jmon.s

000000r 1               ; PBUG - A monitor program for the PAL-1 6502 Computer
000000r 1               ;
000000r 1               ; Based heavily on JMON which is
000000r 1               ; Copyright (C) 2012-2021 by Jeff Tranter <tranter@pobox.com>
000000r 1               ;
000000r 1               ; Modification for the PAL-1 clone of the KIM-1 are
000000r 1               ; Copyright (c) 2021 by Jim McClanahan W4JBM
000000r 1               ;
000000r 1               ; $ make pbug.bin
000000r 1               ; $ srec_cat pbug.bin -binary -offset 0x???? -o pbug.hex -intel -CRLF
000000r 1               ;
000000r 1               ; Note: Use offset of 0x2000 (RAM) or 0xB400 (ROM)
000000r 1               ;
000000r 1               ;
000000r 1               ; Licensed under the Apache License, Version 2.0 (the "License");
000000r 1               ; you may not use this file except in compliance with the License.
000000r 1               ; You may obtain a copy of the License at
000000r 1               ;
000000r 1               ;   http://www.apache.org/licenses/LICENSE-2.0
000000r 1               ;
000000r 1               ; Unless required by applicable law or agreed to in writing, software
000000r 1               ; distributed under the License is distributed on an "AS IS" BASIS,
000000r 1               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
000000r 1               ; See the License for the specific language governing permissions and
000000r 1               ; limitations under the License.
000000r 1               
000000r 1               ; Platform
000000r 1               ; Define either APPLE1 for Apple 1 Replica 1, Apple2 for Apple II series,
000000r 1               ; OSI for Ohio Scientific SuperBoard II or ///, or KIM1 for KIM-1 platform.
000000r 1               ; SBC for my Single Board Computer.
000000r 1               ; Normally this is set in the Makefile.
000000r 1               ; APPLE1  = 1
000000r 1               ; APPLE2  = 1
000000r 1               ; OSI     = 1
000000r 1               ; KIM1    = 1
000000r 1               ; SBC     = 1
000000r 1               
000000r 1               ; Define if you want the mini-assembler, comment out if not.
000000r 1               ; Should fit in 8K if this is disabled.
000000r 1               MINIASM = 1
000000r 1               
000000r 1                   .out "Building for PAL-1/KIM-1"
000000r 1               
000000r 1               ; Constants
000000r 1               CR      = $0D                 ; Carriage Return
000000r 1               LF      = $0A                 ; Line Feed
000000r 1               SP      = $20                 ; Space
000000r 1               ESC     = $1B                 ; Escape
000000r 1               NUL     = $00                 ; Null
000000r 1               bytesPerLine = $20            ; S record file bytes per line
000000r 1               
000000r 1               ; Hardware addresses
000000r 1               
000000r 1               T1      = $30                 ; Temp variable 1 (2 bytes)
000000r 1               T2      = $31                 ; Second byte (was previously no on Page 0)
000000r 1               SL      = $32                 ; Start address low byte
000000r 1               SH      = $33                 ; Start address high byte
000000r 1               EL      = $34                 ; End address low byte
000000r 1               EH      = $35                 ; End address high byte
000000r 1               DL      = $36                 ; Destination address low byte
000000r 1               DH      = $37                 ; Destination address high byte
000000r 1               ADDR    = $38                 ; Instruction address, 2 bytes (low/high)
000000r 1               ;ADDRS   = $3A                 ; Memory test - 2 bytes - address of memory
000000r 1               ;TEST_PATRN = $3C              ; Memory test - 1 byte - current test pattern
000000r 1               ;PASSES  = $3D                 ; Memory test - number of passes
000000r 1               VECTOR  = $3A                 ; Holds adddress of IRQ/BREAK entry point (2 bytes)
000000r 1               BPA     = $40                 ; Address of breakpoint (2 bytes * 4 breakpoints)
000000r 1               T3      = $3C                 ; Temp variable 3 (1 byte)
000000r 1               T4      = $3D                 ; Temp variable 4 (2 bytes)
000000r 1               
000000r 1               ; Non page zero locations
000000r 1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
000000r 1                 IN      = $0200               ; Buffer from $0200 through $027F
000000r 1               .elseif .defined(OSI)
000000r 1                 IN      = $0300               ; Buffer from $0300 through $037F
000000r 1               .endif
000000r 1               
000000r 1               ; External Routines
000000r 1               .if .defined(APPLE1)
000000r 1                 BASIC   = $E000               ; BASIC
000000r 1                 WOZMON  = $FF00               ; Woz monitor entry point
000000r 1                 MENU    = $9006               ; CFFA1 menu entry point
000000r 1                 ACI     = $C100               ; ACI (Apple Cassette Interface) firmware entry point
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $FFFE             ; Break/interrupt vector (2 bytes)
000000r 1               .elseif .defined(APPLE2)
000000r 1                 BASIC   = $E000               ; BASIC (cold start)
000000r 1               ; BASIC   = $03D0               ; BASIC (cold start with DOS hooks)
000000r 1                 MONITOR = $FF69               ; Apple monitor entry point
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $03F0             ; Break/interrupt vector (2 bytes)
000000r 1                 BEEP    = $FBE4               ; Beep the speaker
000000r 1               .elseif .defined(OSI)
000000r 1                 BASIC   = $BD11               ; BASIC Cold Start
000000r 1                 OSIMON  = $FE00               ; OSI monitor entry point
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $FFFE             ; Break/interrupt vector (2 bytes)
000000r 1               .elseif .defined(KIM1)
000000r 1                 KIMMON  = $1C00               ; KIM monitor entry point
000000r 1                 BRKVECTOR = $17FE             ; Break/interrupt vector (2 bytes)
000000r 1               ; Note: ECHO not defined because KIM-1 always echoes characters back.
000000r 1               ; NEW NOTE: Working around ECHO issue by manipulating RIOT mask
000000r 1                 ECHO    = 1
000000r 1                 SBD     = $1742               ; PAL-1 RIOT B Data Register
000000r 1               .elseif .defined(SBC)
000000r 1                 BASIC   = $DD05               ; BASIC Cold Start
000000r 1                 ECHO    = 1                   ; Need to echo commands
000000r 1                 BRKVECTOR = $FFFE             ; Break/interrupt vector (2 bytes)
000000r 1                 MONCOUT = $FF3B               ; Console out routine
000000r 1                 MONRDKEY = $FF4A              ; Console in routine
000000r 1               .endif
000000r 1               
000000r 1               ; Start address.
000000r 1               ;   .org $2000
000000r 1                   .org $B400
00B400  1               
00B400  1               ; JMON Entry point
00B400  1                 .export JMON
00B400  1               JMON:
00B400  1               
00B400  1               ; Initialization
00B400  1  D8                   CLD                     ; clear decimal mode
00B401  1  78                   SEI                     ; clear interrupt disable
00B402  1  A2 80                LDX #$80                ; initialize stack pointer to $0180
00B404  1  9A                   TXS                     ; so we are less likely to clobber BRK vector at $0100 on OSI
00B405  1  A9 00                LDA #0
00B407  1               ;       STA OWDELAY             ; initialize write delay to zero
00B407  1  8D 80 17             STA RETOK               ; Don't accept <Return> by default
00B40A  1  8D A2 17             STA CHAROK              ; Don't accept character input by default
00B40D  1  8D A3 17             STA CHARMODE            ; Not currently in char input mode
00B410  1  8D A5 17             STA OHIGHASCII          ; Characters should not have high bit set
00B413  1  A9 FF                LDA #$FF                ; Default to uppercase only mode
00B415  1  8D A4 17             STA OUPPER
00B418  1  A9 01                LDA #1
00B41A  1  8D A8 17             STA XBIT                ; Default 65816 to 8-bit modes
00B41D  1  8D A7 17             STA MBIT
00B420  1  A9 40                LDA #$40                ; Default stack pointer for running program
00B422  1  8D 9B 17             STA SAVE_S              ; ($00 is bad choice since BRK vector is at $0100 on OSI)
00B425  1  20 16 B7             JSR BPSETUP             ; initialization for breakpoints
00B428  1               ;       JSR ClearScreen
00B428  1               
00B428  1               ; Display Welcome message
00B428  1  A2 EE                LDX #<WelcomeMessage
00B42A  1  A0 C0                LDY #>WelcomeMessage
00B42C  1  20 28 BE             JSR PrintString
00B42F  1               
00B42F  1               MainLoop:
00B42F  1               ; Display prompt
00B42F  1  20 4A BE             JSR Imprint
00B432  1  50 41 4C 3E          .asciiz "PAL> "
00B436  1  20 00        
00B438  1               
00B438  1               ; Get first character of command
00B438  1  20 D9 BC             JSR GetKey
00B43B  1  C9 0D                CMP #13           ; Don't treat CR as an input error
00B43D  1  D0 06                BNE _ckcmd
00B43F  1  20 13 BE             JSR PrintCR
00B442  1  4C 2F B4             JMP MainLoop
00B445  1               
00B445  1               ; Call option picker to run appropriate command
00B445  1  20 C0 BF     _ckcmd: JSR OPICK
00B448  1  4C 2F B4             JMP MainLoop
00B44B  1               
00B44B  1               ; Invalid command
00B44B  1               Invalid:
00B44B  1  20 4A BE             JSR Imprint
00B44E  1  0D 0A 49 6E          .byte CR,LF,"Invalid command. Type '?' for help.", CR, LF, 0
00B452  1  76 61 6C 69  
00B456  1  64 20 63 6F  
00B476  1  60                   RTS
00B477  1               
00B477  1               ; Display help
00B477  1               Help:
00B477  1  20 8E BE             JSR PrintChar           ; echo command
00B47A  1  20 13 BE             JSR PrintCR
00B47D  1  A2 EE                LDX #<WelcomeMessage
00B47F  1  A0 C0                LDY #>WelcomeMessage
00B481  1  20 28 BE             JSR PrintString
00B484  1  A2 04                LDX #<HelpString
00B486  1  A0 C1                LDY #>HelpString
00B488  1  4C 28 BE             JMP PrintString         ; Return via caller
00B48B  1               
00B48B  1               
00B48B  1               ; Go to Woz Monitor, OSI Monitor, or KIM-1 Monitor.
00B48B  1               Monitor:
00B48B  1  4C 00 1C             JMP KIMMON              ; Jump into KIM Monitor
00B48E  1               
00B48E  1               ; Go to Mini Assembler
00B48E  1               .ifdef MINIASM
00B48E  1               Assemble:
00B48E  1  20 8E BE             JSR PrintChar           ; echo command
00B491  1  20 20 BE             JSR PrintSpace          ; print a space
00B494  1  20 9D BD             JSR GetAddress          ; Get start address
00B497  1  86 38                STX ADDR                ; Save it
00B499  1  84 39                STY ADDR+1              ; Save it
00B49B  1  20 13 BE             JSR PrintCR             ; Start new line
00B49E  1  4C 76 CB             JMP AssembleLine        ; Call asssembler
00B4A1  1               .endif
00B4A1  1               
00B4A1  1               ; Go to BASIC
00B4A1  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(OSI) .or .defined(SBC)
00B4A1  1               Basic:
00B4A1  1                       JSR BASICPresent        ; Is BASIC ROM present?
00B4A1  1                       BEQ NoBasic
00B4A1  1                       JMP BASIC               ; Jump to BASIC (no facility to return).
00B4A1  1               NoBasic:
00B4A1  1               .ifdef BEEP
00B4A1  1                       JSR BEEP
00B4A1  1               .endif
00B4A1  1                       JSR Imprint             ; Display error that no BASIC is present.
00B4A1  1                       .byte "BASIC not found!", CR, 0
00B4A1  1                       RTS
00B4A1  1               .endif
00B4A1  1               
00B4A1  1               ; Handle breakpoint
00B4A1  1               ; B ?                    <- list status of all breakpoints
00B4A1  1               ; B <n> <address>        <- set breakpoint number <n> at address <address>
00B4A1  1               ; B <n> 0000             <- remove breakpoint <n>
00B4A1  1               ; <n> is 0 through 3.
00B4A1  1               Breakpoint:
00B4A1  1  20 8E BE             JSR PrintChar           ; echo command
00B4A4  1  20 20 BE             JSR PrintSpace          ; print space
00B4A7  1  20 D9 BC     IGN:    JSR GetKey              ; get breakpoint number
00B4AA  1  C9 3F                CMP #'?'                ; ? lists breakpoints
00B4AC  1  F0 26                BEQ LISTB
00B4AE  1  C9 1B                CMP #ESC                ; <Escape> cancels
00B4B0  1  D0 03                BNE Num
00B4B2  1  4C 13 BE             JMP PrintCR
00B4B5  1               
00B4B5  1  C9 30        Num:    CMP #'0'                ; is it 0 through 3?
00B4B7  1  30 EE                BMI IGN                 ; Invalid, ignore and try again
00B4B9  1  C9 34                CMP #'3'+1
00B4BB  1  30 03                BMI VALIDBP
00B4BD  1  4C A7 B4             JMP IGN
00B4C0  1               VALIDBP:
00B4C0  1               .ifdef ECHO
00B4C0  1  20 8E BE             JSR PrintChar           ; echo number
00B4C3  1               .endif
00B4C3  1  38                   SEC
00B4C4  1  E9 30                SBC #'0'                ; convert to number
00B4C6  1  48                   PHA                     ; save it
00B4C7  1  20 20 BE             JSR PrintSpace          ; print space
00B4CA  1  20 9D BD             JSR GetAddress          ; prompt for address
00B4CD  1  20 13 BE             JSR PrintCR
00B4D0  1  68                   PLA                     ; restore BP number
00B4D1  1  4C B6 B7             JMP BPADD
00B4D4  1               
00B4D4  1  20 13 BE     LISTB:  JSR PrintCR
00B4D7  1  4C 76 B7             JMP BPLIST
00B4DA  1               
00B4DA  1               
00B4DA  1               ; Run at address
00B4DA  1               Go:
00B4DA  1  20 8E BE             JSR PrintChar   ; echo command
00B4DD  1  20 20 BE             JSR PrintSpace  ; print space
00B4E0  1  A9 01                LDA #1
00B4E2  1  8D 80 17             STA RETOK
00B4E5  1  20 9D BD             JSR GetAddress  ; prompt for address
00B4E8  1  B0 06                BCS RetPressed  ; Branch if user pressed <Enter>
00B4EA  1  8E 9D 17             STX SAVE_PC     ; store address
00B4ED  1  8C 9E 17             STY SAVE_PC+1
00B4F0  1               
00B4F0  1               RetPressed:
00B4F0  1  AD 9D 17             LDA SAVE_PC
00B4F3  1  85 32                STA SL
00B4F5  1  AD 9E 17             LDA SAVE_PC+1
00B4F8  1  85 33                STA SL+1
00B4FA  1               
00B4FA  1  20 13 BE             JSR PrintCR
00B4FD  1               
00B4FD  1  A9 00                LDA #0
00B4FF  1  8D 80 17             STA RETOK
00B502  1               
00B502  1               ; Save our current stack pointer value
00B502  1               
00B502  1  BA                   TSX
00B503  1  8E A1 17             STX THIS_S
00B506  1               
00B506  1               ; Restore saved values of registers
00B506  1  AE 9B 17             LDX SAVE_S      ; Restore stack pointer
00B509  1  9A                   TXS
00B50A  1  A9 B5                LDA #>(@Return-1) ; Push return address-1 on the stack so an RTS in the called code will return here.
00B50C  1  48                   PHA
00B50D  1  A9 20                LDA #<(@Return-1)
00B50F  1  48                   PHA
00B510  1  AD 9C 17             LDA SAVE_P
00B513  1  48                   PHA             ; Push P
00B514  1  AC 9A 17             LDY SAVE_Y      ; Restore Y
00B517  1  AE 99 17             LDX SAVE_X      ; Restore X
00B51A  1  AD 98 17             LDA SAVE_A      ; Restore A
00B51D  1  28                   PLP             ; Restore P
00B51E  1  6C 32 00             JMP (SL)        ; jump to address
00B521  1               @Return:
00B521  1               
00B521  1               ; Restore our original stack pointer so that RTS will work. Hopefully
00B521  1               ;  the called program did not corrupt the stack.
00B521  1               
00B521  1  AE A1 17             LDX THIS_S
00B524  1  9A                   TXS
00B525  1  60                   RTS
00B526  1               
00B526  1               ; Copy Memory
00B526  1               ;
00B526  1               ; There are to copy routines.
00B526  1               ;
00B526  1               ; Copy Up:
00B526  1               ; If SOURCE > DESTINATION, then start at the bottom of DESTINATION
00B526  1               ; and copy up to avoid overwritting data you want to copy.
00B526  1               ;
00B526  1               ; Copy Down:
00B526  1               ; If SOURCE < DESTINATION, then start at the top of DESTINATION and
00B526  1               ; copy down to avoid overwritting data you want to copy.
00B526  1               ;
00B526  1               ;
00B526  1               ; There is also a check that the END portion of the SOURCE address
00B526  1               ; is equal to or greater than the START portion of the SOURCE
00B526  1               ; address.
00B526  1               
00B526  1               Copy:
00B526  1  20 8E BE             JSR PrintChar   ; echo command
00B529  1  20 20 BE             JSR PrintSpace  ; print space
00B52C  1  20 9D BD             JSR GetAddress  ; prompt for start address
00B52F  1  86 32                STX SL          ; store address
00B531  1  84 33                STY SH
00B533  1  20 20 BE             JSR PrintSpace  ; print space
00B536  1  20 9D BD             JSR GetAddress  ; prompt for end address
00B539  1  86 34                STX EL          ; store address
00B53B  1  84 35                STY EH
00B53D  1  20 20 BE             JSR PrintSpace  ; print space
00B540  1  20 9D BD             JSR GetAddress  ; prompt for destination address
00B543  1  86 36                STX DL          ; store address
00B545  1  84 37                STY DH
00B547  1  20 13 BE             JSR PrintCR
00B54A  1  20 7F BF             JSR RequireStartNotAfterEnd
00B54D  1  90 01                BCC @okay1
00B54F  1  60                   RTS
00B550  1               
00B550  1               ; Separate copy up and down routines to handle avoid overlapping memory
00B550  1               
00B550  1               @okay1:
00B550  1  A5 33                LDA SH
00B552  1  C5 37                CMP DH
00B554  1  90 2C                BCC @okayDown             ; copy up
00B556  1  D0 08                BNE @okayUp           ; copy down
00B558  1  A5 32                LDA SL
00B55A  1  C5 36                CMP DL
00B55C  1  90 24                BCC @okayDown
00B55E  1  B0 00                BCS @okayUp
00B560  1               
00B560  1               ; This code is used for when the SOURCE>DESTINATION
00B560  1               
00B560  1               @okayUp:
00B560  1               ;        LDA #'U'    ; for troubleshooting
00B560  1               ;        JSR PrintChar
00B560  1  A0 00                LDY #0
00B562  1               @copyUp:
00B562  1  B1 32                LDA (SL),Y              ; copy from source
00B564  1  91 36                STA (DL),Y              ; to destination
00B566  1  A5 33                LDA SH                  ; reached end yet?
00B568  1  C5 35                CMP EH
00B56A  1  D0 07                BNE @NotDoneU
00B56C  1  A5 32                LDA SL
00B56E  1  C5 34                CMP EL
00B570  1  D0 01                BNE @NotDoneU
00B572  1  60                   RTS                     ; done
00B573  1               
00B573  1               ; Increment SOURCE address (16 bits)
00B573  1               
00B573  1               ; This has been reworked and simplified. We have a 16 bit
00B573  1               ; value in X and X+1 that we want to increment. So we
00B573  1               ; increment X first and then check if it went to Zero.
00B573  1               ; If not we are done, but if it did go from $FF to $00
00B573  1               ; then we need to increment X+1.
00B573  1               
00B573  1               @NotDoneU:
00B573  1               
00B573  1               ; Increment SOURCE address
00B573  1               
00B573  1  E6 32                INC SL
00B575  1  D0 02                BNE @NoInc1
00B577  1  E6 33                INC SH
00B579  1               @NoInc1:
00B579  1               
00B579  1               ; Increment DESTINATION address (16 bits)
00B579  1  E6 36                INC DL
00B57B  1  D0 02                BNE @NoInc2
00B57D  1  E6 37                INC DH
00B57F  1               @NoInc2:
00B57F  1               
00B57F  1  4C 62 B5             JMP @copyUp
00B582  1               
00B582  1               @okayDown:
00B582  1               
00B582  1               ; Calculate the LENGTH of the copy
00B582  1               ; LENGTH = SOURCE END (EL & EH) - SOURCE START (SL & SH)
00B582  1               
00B582  1  38                   SEC
00B583  1  A5 34                LDA EL                 ; End (low)Calculate length = End - Start
00B585  1  E5 32                SBC SL
00B587  1  85 30                STA T1
00B589  1               
00B589  1  A5 35                LDA EH
00B58B  1  E5 33                SBC SH
00B58D  1  85 31                STA T2
00B58F  1               
00B58F  1               ; Add LENGTH of copy to the DESTINATION address because
00B58F  1               ; we will put data at the destination from the top down
00B58F  1               
00B58F  1  18                   CLC
00B590  1  A5 36                LDA DL
00B592  1  65 30                ADC T1
00B594  1  85 36                STA DL
00B596  1  A5 37                LDA DH
00B598  1  65 31                ADC T2
00B59A  1  85 37                STA DH
00B59C  1               
00B59C  1               ;        LDA #'D'  ; for debugging
00B59C  1               ;        JSR PrintChar
00B59C  1  A0 00                LDY #0
00B59E  1               
00B59E  1               @copyDown:
00B59E  1  B1 34                LDA (EL),Y              ; copy from source
00B5A0  1  91 36                STA (DL),Y              ; to destination
00B5A2  1  A5 35                LDA EH                  ; reached end yet?
00B5A4  1  C5 33                CMP SH
00B5A6  1  D0 07                BNE @NotDoneD
00B5A8  1  A5 34                LDA EL
00B5AA  1  C5 32                CMP SL
00B5AC  1  D0 01                BNE @NotDoneD
00B5AE  1  60                   RTS                     ; done
00B5AF  1               
00B5AF  1               
00B5AF  1               ; This has been reworked and simplified. We have a 16 bit
00B5AF  1               ; value in X and X+1 that we want to decrement. So we
00B5AF  1               ; LDA X and see if it is Zero. If it is, we need to decrement
00B5AF  1               ; both X+1 and X. Otherwise we just need to decrement X.
00B5AF  1               
00B5AF  1               ; DECrement the end address
00B5AF  1               
00B5AF  1               @NotDoneD:
00B5AF  1  A5 34                LDA EL
00B5B1  1  D0 02                BNE @NoDec1
00B5B3  1  C6 35                DEC EL+1
00B5B5  1               @NoDec1:
00B5B5  1  C6 34                DEC EL
00B5B7  1               
00B5B7  1               ; DECrement the destination address
00B5B7  1               
00B5B7  1  A5 36                LDA DL
00B5B9  1  D0 02                BNE @NoDec2
00B5BB  1  C6 37                DEC DL+1
00B5BD  1               @NoDec2:
00B5BD  1  C6 36                DEC DL
00B5BF  1               
00B5BF  1  4C 9E B5             JMP @copyDown
00B5C2  1               
00B5C2  1               ; Search Memory
00B5C2  1               Search:
00B5C2  1               .ifdef ECHO
00B5C2  1  20 8E BE             JSR PrintChar   ; echo command
00B5C5  1               .endif
00B5C5  1  20 20 BE             JSR PrintSpace
00B5C8  1  20 9D BD             JSR GetAddress  ; get start address
00B5CB  1  86 32                STX SL
00B5CD  1  84 33                STY SH
00B5CF  1  20 20 BE             JSR PrintSpace
00B5D2  1  20 9D BD             JSR GetAddress  ; get end address
00B5D5  1  86 34                STX EL
00B5D7  1  84 35                STY EH
00B5D9  1  20 20 BE             JSR PrintSpace
00B5DC  1  20 61 C0             JSR GetHexBytes         ; Get search pattern
00B5DF  1  20 13 BE             JSR PrintCR
00B5E2  1  AD 00 02             LDA IN                  ; If length of pattern is zero, return
00B5E5  1  D0 01                BNE @lenokay
00B5E7  1  60                   RTS
00B5E8  1               
00B5E8  1               @lenokay:
00B5E8  1  20 7F BF             JSR RequireStartNotAfterEnd
00B5EB  1  90 01                BCC @StartSearch
00B5ED  1  60                   RTS
00B5EE  1               
00B5EE  1               @StartSearch:
00B5EE  1  A2 00                LDX #0                  ; Index into fill pattern
00B5F0  1               @search:
00B5F0  1  A0 00                LDY #0
00B5F2  1  BD 01 02             LDA IN+1,X              ; Get byte of pattern data
00B5F5  1  D1 32                CMP (SL),Y              ; compare with memory data
00B5F7  1  D0 08                BNE @NoMatch
00B5F9  1  E8                   INX
00B5FA  1  EC 00 02             CPX IN                  ; End of pattern reached?
00B5FD  1  F0 40                BEQ @Match              ; If so, found match
00B5FF  1  D0 11                BNE @PartialMatch
00B601  1               @NoMatch:
00B601  1  86 30                STX T1                  ; Subtract X from SL,SH
00B603  1  38                   SEC
00B604  1  A5 32                LDA SL
00B606  1  E5 30                SBC T1
00B608  1  85 32                STA SL
00B60A  1  A5 33                LDA SH
00B60C  1  E9 00                SBC #0
00B60E  1  85 33                STA SH
00B610  1               @Continue:
00B610  1  A2 00                LDX #0                  ; Reset search to end of pattern
00B612  1               @PartialMatch:
00B612  1  A5 33                LDA SH                  ; reached end yet?
00B614  1  C5 35                CMP EH
00B616  1  D0 19                BNE @NotDone
00B618  1  A5 32                LDA SL
00B61A  1  C5 34                CMP EL
00B61C  1  D0 13                BNE @NotDone
00B61E  1  20 4A BE             JSR Imprint
00B621  1  4E 6F 74 20          .byte "Not found...", CR, LF, 0
00B625  1  66 6F 75 6E  
00B629  1  64 2E 2E 2E  
00B630  1  60                   RTS
00B631  1               @NotDone:
00B631  1  A5 32                LDA SL                  ; increment address
00B633  1  18                   CLC
00B634  1  69 01                ADC #1
00B636  1  85 32                STA SL
00B638  1  90 02                BCC @NoCarry
00B63A  1  E6 33                INC SH
00B63C  1               @NoCarry:
00B63C  1  4C F0 B5             JMP @search
00B63F  1               
00B63F  1               @Match:
00B63F  1  CE 00 02             DEC IN                  ; Calculate start address as SL,SH minus (IN - 1)
00B642  1  A5 32                LDA SL
00B644  1  38                   SEC
00B645  1  ED 00 02             SBC IN
00B648  1  85 32                STA SL
00B64A  1  A5 33                LDA SH
00B64C  1  E9 00                SBC #0                  ; Includes possible carry
00B64E  1  85 33                STA SH
00B650  1  EE 00 02             INC IN
00B653  1  20 4A BE             JSR Imprint
00B656  1  46 6F 75 6E          .asciiz "Found at: "
00B65A  1  64 20 61 74  
00B65E  1  3A 20 00     
00B661  1  A6 32                LDX SL
00B663  1  A4 33                LDY SH
00B665  1  20 AF BD             JSR PrintAddress
00B668  1  20 13 BE             JSR PrintCR
00B66B  1  20 06 BF             JSR PromptToContinue
00B66E  1  90 A0                BCC @Continue
00B670  1               EndSearch:
00B670  1  60                   RTS             ; done
00B671  1               
00B671  1               ; Verify Memory
00B671  1               ;Verify:
00B671  1               ;.ifdef ECHO
00B671  1               ;        JSR PrintChar   ; echo command
00B671  1               ;.endif
00B671  1               ;        JSR PrintSpace  ; print space
00B671  1               ;        JSR GetAddress  ; prompt for start address
00B671  1               ;        STX SL          ; store address
00B671  1               ;        STY SH
00B671  1               ;        JSR PrintSpace  ; print space
00B671  1               ;        JSR GetAddress  ; prompt for end address
00B671  1               ;        STX EL          ; store address
00B671  1               ;        STY EH
00B671  1               ;        JSR PrintSpace  ; print space
00B671  1               ;        JSR GetAddress  ; prompt for destination address
00B671  1               ;        STX DL          ; store address
00B671  1               ;        STY DH
00B671  1               ;        JSR PrintCR
00B671  1               ;        JSR RequireStartNotAfterEnd
00B671  1               ;        BCC @verify
00B671  1               ;        RTS
00B671  1               ;
00B671  1               ;@verify:
00B671  1               ;        LDY #0
00B671  1               ;        LDA (SL),Y              ; compare source
00B671  1               ;        CMP (DL),Y              ; to destination
00B671  1               ;        BEQ @match
00B671  1               ;        JSR Imprint             ; report mismatch
00B671  1               ;        .asciiz "Mismatch: "
00B671  1               ;        LDX SL
00B671  1               ;        LDY SH
00B671  1               ;        JSR PrintAddress
00B671  1               ;        LDA #':'
00B671  1               ;        JSR PrintChar
00B671  1               ;        JSR PrintSpace
00B671  1               ;        LDY #0
00B671  1               ;        LDA (SL),Y
00B671  1               ;        JSR PrintByte
00B671  1               ;        JSR PrintSpace
00B671  1               ;        LDX DL
00B671  1               ;        LDY DH
00B671  1               ;        JSR PrintAddress
00B671  1               ;        LDA #':'
00B671  1               ;        JSR PrintChar
00B671  1               ;        JSR PrintSpace
00B671  1               ;        LDY #0
00B671  1               ;        LDA (DL),Y
00B671  1               ;        JSR PrintByte
00B671  1               ;        JSR PrintCR
00B671  1               ;        JSR PromptToContinue
00B671  1               ;        BCS @Done               ; ESC pressed, return
00B671  1               ;@match: LDA SH                  ; reached end yet?
00B671  1               ;        CMP EH
00B671  1               ;        BNE @NotDone
00B671  1               ;        LDA SL
00B671  1               ;        CMP EL
00B671  1               ;        BNE @NotDone
00B671  1               ;@Done:
00B671  1               ;        RTS                     ; done
00B671  1               ;@NotDone:
00B671  1               ;        LDA SL                  ; increment start address
00B671  1               ;        CLC
00B671  1               ;        ADC #1
00B671  1               ;        STA SL
00B671  1               ;        BCC @NoCarry1
00B671  1               ;        INC SH
00B671  1               ;@NoCarry1:
00B671  1               ;        LDA DL                  ; increment destination address
00B671  1               ;        CLC
00B671  1               ;        ADC #1
00B671  1               ;        STA DL
00B671  1               ;        BCC @NoCarry2
00B671  1               ;        INC DH
00B671  1               ;@NoCarry2:
00B671  1               ;        JMP @verify
00B671  1               
00B671  1               ; Dump Memory
00B671  1               
00B671  1                       BYTESPERLINE = 16
00B671  1               
00B671  1               Dump:
00B671  1               ; echo 'D' and space, wait for start address
00B671  1               .ifdef ECHO
00B671  1  20 8E BE             JSR PrintChar
00B674  1               .endif
00B674  1  20 20 BE             JSR PrintSpace
00B677  1  20 9D BD             JSR GetAddress          ; Get start address
00B67A  1  86 32                STX SL
00B67C  1  84 33                STY SH
00B67E  1  20 13 BE     @line:  JSR PrintCR
00B681  1  A2 00        @line2: LDX #0
00B683  1  20 A3 BC     @loop:  JSR DumpLine            ; display line of output
00B686  1  A5 32                LDA SL                  ; add 8 (4 for OSI) to start address
00B688  1  18                   CLC
00B689  1  69 10                ADC #BYTESPERLINE
00B68B  1  85 32                STA SL
00B68D  1  90 02                BCC @NoCarry
00B68F  1  E6 33                INC SH
00B691  1               @NoCarry:
00B691  1  E8                   INX
00B692  1  E0 17                CPX #23                 ; display 23 lines
00B694  1  D0 ED                BNE @loop
00B696  1  20 06 BF             JSR PromptToContinue
00B699  1  90 E6                BCC @line2
00B69B  1  60                   RTS
00B69C  1               
00B69C  1               ; Unassemble Memory
00B69C  1               Unassemble:
00B69C  1               ; echo 'U' and space, wait for start address
00B69C  1               .ifdef ECHO
00B69C  1  20 8E BE             JSR PrintChar
00B69F  1               .endif
00B69F  1  20 20 BE             JSR PrintSpace
00B6A2  1  20 9D BD             JSR GetAddress          ; Get start address
00B6A5  1  86 38                STX ADDR
00B6A7  1  84 39                STY ADDR+1
00B6A9  1  20 13 BE     @line:  JSR PrintCR
00B6AC  1  A9 17        @nline: LDA #23
00B6AE  1  48           @loop:  PHA
00B6AF  1  20 80 C3             JSR DISASM              ; display line of output
00B6B2  1  68                   PLA
00B6B3  1  38                   SEC
00B6B4  1  E9 01                SBC #1
00B6B6  1  D0 F6                BNE @loop
00B6B8  1  20 06 BF             JSR PromptToContinue
00B6BB  1  90 EF                BCC @nline
00B6BD  1  60                   RTS
00B6BE  1               
00B6BE  1               ; Test Memory
00B6BE  1               Test:
00B6BE  1               .ifdef ECHO
00B6BE  1               ;        JSR PrintChar           ; echo command
00B6BE  1               .endif
00B6BE  1               ;        JSR PrintSpace
00B6BE  1               ;        JSR GetAddress          ; get start address
00B6BE  1               ;        STX START
00B6BE  1               ;        STY START+1
00B6BE  1               ;        JSR PrintSpace
00B6BE  1               ;        JSR GetAddress          ; get end address
00B6BE  1               ;        STX END
00B6BE  1               ;        STY END+1
00B6BE  1               ;        JSR PrintCR
00B6BE  1               ;        JSR Imprint
00B6BE  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00B6BE  1               ;        .asciiz "Testing memory from $"
00B6BE  1               .elseif .defined(OSI)
00B6BE  1               ;        .byte "Testing memory from", CR, LF, "$", 0
00B6BE  1               .endif
00B6BE  1               ;        LDX START
00B6BE  1               ;        LDY START+1
00B6BE  1               ;        JSR PrintAddress
00B6BE  1               ;        JSR Imprint
00B6BE  1               ;        .asciiz " to $"
00B6BE  1               ;        LDX END
00B6BE  1               ;        LDY END+1
00B6BE  1               ;        JSR PrintAddress
00B6BE  1               ;       JSR Imprint
00B6BE  1               ;       .byte CR,LF,"Press any key to stop", CR, LF, 0
00B6BE  1               ;        JMP MEM_TEST
00B6BE  1               
00B6BE  1               ; Memory fill command
00B6BE  1               Fill:
00B6BE  1               .ifdef ECHO
00B6BE  1  20 8E BE             JSR PrintChar           ; echo command
00B6C1  1               .endif
00B6C1  1  20 20 BE             JSR PrintSpace
00B6C4  1  20 9D BD             JSR GetAddress          ; get start address
00B6C7  1  86 32                STX SL
00B6C9  1  84 33                STY SH
00B6CB  1  20 20 BE             JSR PrintSpace
00B6CE  1  20 9D BD             JSR GetAddress          ; get end address
00B6D1  1  86 34                STX EL
00B6D3  1  84 35                STY EH
00B6D5  1  20 20 BE             JSR PrintSpace
00B6D8  1  20 61 C0             JSR GetHexBytes         ; Get fill pattern
00B6DB  1  20 13 BE             JSR PrintCR
00B6DE  1  AD 00 02             LDA IN                  ; If length of pattern is zero, return
00B6E1  1  D0 01                BNE @lenokay
00B6E3  1  60                   RTS
00B6E4  1               @lenokay:
00B6E4  1  20 7F BF             JSR RequireStartNotAfterEnd
00B6E7  1  90 01                BCC @fill
00B6E9  1  60                   RTS
00B6EA  1               
00B6EA  1               @fill:
00B6EA  1  A0 00                LDY #0
00B6EC  1  A2 00                LDX #0                  ; Index into fill pattern
00B6EE  1               @dofill:
00B6EE  1  BD 01 02             LDA IN+1,X              ; Get next byte of fill pattern
00B6F1  1  91 32                STA (SL),Y              ; store data (first byte)
00B6F3  1               ;       JSR DELAY               ; delay after writing to EEPROM
00B6F3  1  A5 33                LDA SH                  ; reached end yet?
00B6F5  1  C5 35                CMP EH
00B6F7  1  D0 07                BNE @NotDone
00B6F9  1  A5 32                LDA SL
00B6FB  1  C5 34                CMP EL
00B6FD  1  D0 01                BNE @NotDone
00B6FF  1  60                   RTS                     ; done
00B700  1               @NotDone:
00B700  1  A5 32                LDA SL                  ; increment address
00B702  1  18                   CLC
00B703  1  69 01                ADC #1
00B705  1  85 32                STA SL
00B707  1  90 02                BCC @NoCarry
00B709  1  E6 33                INC SH
00B70B  1               @NoCarry:
00B70B  1  E8                   INX                     ; increment index into pattern
00B70C  1  EC 00 02             CPX IN                  ; end of pattern reached?
00B70F  1  D0 DD                BNE @dofill             ; if not, go back
00B711  1  A2 00                LDX #0                  ; Otherwise go back to start of pattern
00B713  1  4C EE B6             JMP @dofill
00B716  1               
00B716  1               ; Do setup so we can support breakpoints
00B716  1               BPSETUP:
00B716  1               .if .defined(APPLE1) .or .defined(OSI) .or .defined(SBC)
00B716  1               
00B716  1               ; On the Apple 1 and OSI platforms the BRK vector is in RAM and we
00B716  1               ; write a JMP instruction to our handler there.
00B716  1               
00B716  1                       LDA BRKVECTOR           ; get address of BRK vector
00B716  1                       STA VECTOR              ; and save in page zero
00B716  1                       LDA BRKVECTOR+1
00B716  1                       STA VECTOR+1
00B716  1                       LDA #$4C                ; JMP instruction
00B716  1                       LDY #0
00B716  1                       STA (VECTOR),Y          ; store at IRQ/BRK vector
00B716  1                       CMP (VECTOR),Y          ; if we don't read back what we wrote
00B716  1                       BNE VNOTINRAM           ; then vector address is not writable (user may have put it in ROM)
00B716  1                       LDA #<BRKHANDLER        ; handler address low byte
00B716  1                       INY
00B716  1                       STA (VECTOR),Y          ; write it after JMP
00B716  1                       LDA #>BRKHANDLER        ; handler address high byte
00B716  1                       INY
00B716  1                       STA (VECTOR),Y          ; write it after JMP
00B716  1               
00B716  1               .elseif .defined(KIM1) .or .defined(APPLE2) .or .defined(SBC)
00B716  1               
00B716  1               ; On the KIM-1 and Apple II, the BRK vector is in ROM but the handler
00B716  1               ; goes through a vector in RAM.
00B716  1               
00B716  1  A9 16                LDA #<BRKHANDLER        ; handler address low byte
00B718  1  8D FE 17             STA BRKVECTOR
00B71B  1  CD FE 17             CMP BRKVECTOR           ; if we don't read back what we wrote
00B71E  1  D0 1C                BNE VNOTINRAM           ; ...then vector address is not writable (shouldn't happen, but...)
00B720  1  A9 B8                LDA #>BRKHANDLER        ; handler address high byte
00B722  1  8D FF 17             STA BRKVECTOR+1
00B725  1               .endif
00B725  1  A9 00                LDA #0                  ; Mark all breakpoints as cleared (BPA and BPD set to 0)
00B727  1  A2 00                LDX #0
00B729  1  A0 00                LDY #0
00B72B  1               CLEAR:
00B72B  1  99 40 00             STA BPA,Y
00B72E  1  99 41 00             STA BPA+1,Y
00B731  1  9D 94 17             STA BPD,X
00B734  1  C8                   INY
00B735  1  C8                   INY
00B736  1  E8                   INX
00B737  1  E0 04                CPX #4
00B739  1  D0 F0                BNE CLEAR
00B73B  1  60                   RTS
00B73C  1               VNOTINRAM:
00B73C  1  20 4A BE             JSR Imprint
00B73F  1  42 52 4B 20          .byte "BRK vector not in RAM!", CR, LF, 0
00B743  1  76 65 63 74  
00B747  1  6F 72 20 6E  
00B758  1  60                   RTS
00B759  1               BNOTINRAM:
00B759  1  20 4A BE             JSR Imprint
00B75C  1  42 72 65 61          .byte "Breakpoint not in RAM!", CR, LF, 0
00B760  1  6B 70 6F 69  
00B764  1  6E 74 20 6E  
00B775  1  60                   RTS
00B776  1               
00B776  1               ; List breakpoints, e.g.
00B776  1               ; "BREAKPOINT n AT $nnnn"
00B776  1               BPLIST:
00B776  1  A2 00                LDX #0
00B778  1               LIST:
00B778  1  8A                   TXA
00B779  1  48                   PHA
00B77A  1  A2 1B                LDX #<KnownBPString1
00B77C  1  A0 C3                LDY #>KnownBPString1
00B77E  1  20 28 BE             JSR PrintString
00B781  1               
00B781  1  68                   PLA
00B782  1  48                   PHA
00B783  1  4A                   LSR A                   ; divide by 2
00B784  1  20 84 BE             JSR PRHEX
00B787  1  A2 27                LDX #<KnownBPString2
00B789  1  A0 C3                LDY #>KnownBPString2
00B78B  1  20 28 BE             JSR PrintString
00B78E  1  68                   PLA
00B78F  1  48                   PHA
00B790  1  AA                   TAX
00B791  1  B5 40                LDA BPA,X
00B793  1  E8                   INX
00B794  1  B4 40                LDY BPA,X
00B796  1  AA                   TAX
00B797  1  20 AF BD             JSR PrintAddress
00B79A  1  20 13 BE             JSR PrintCR
00B79D  1  68                   PLA
00B79E  1  AA                   TAX
00B79F  1  E8                   INX
00B7A0  1  E8                   INX
00B7A1  1  E0 08                CPX #8
00B7A3  1  D0 D3                BNE LIST
00B7A5  1  60                   RTS
00B7A6  1               
00B7A6  1               ; Return 1 in A if breakpoint number A exists, otherwise return 0.
00B7A6  1               BPEXISTS:
00B7A6  1  0A                   ASL A                   ; need to multiply by 2 to get offset in array
00B7A7  1  AA                   TAX
00B7A8  1  B5 40                LDA BPA,X
00B7AA  1  D0 07                BNE EXISTS
00B7AC  1  B5 41                LDA BPA+1,X
00B7AE  1  D0 03                BNE EXISTS
00B7B0  1  A9 00                LDA #0
00B7B2  1  60                   RTS
00B7B3  1               EXISTS:
00B7B3  1  A9 01                LDA #1
00B7B5  1  60                   RTS
00B7B6  1               
00B7B6  1               ; Add breakpoint number A at address in X,Y
00B7B6  1               BPADD:
00B7B6  1  86 30                STX T1
00B7B8  1  84 31                STY T2
00B7BA  1  48                   PHA
00B7BB  1  20 A6 B7             JSR BPEXISTS            ; if breakpoint already exists, remove it first
00B7BE  1  F0 05                BEQ ADDIT
00B7C0  1  68                   PLA
00B7C1  1  48                   PHA
00B7C2  1  20 E2 B7             JSR BPREMOVE            ; remove it
00B7C5  1               ADDIT:
00B7C5  1  68                   PLA
00B7C6  1  A8                   TAY
00B7C7  1  0A                   ASL A                   ; need to multiply by 2 to get offset in array
00B7C8  1  AA                   TAX
00B7C9  1  A5 30                LDA T1
00B7CB  1  95 40                STA BPA,X               ; save address of breakpoint
00B7CD  1  A5 31                LDA T2
00B7CF  1  95 41                STA BPA+1,X
00B7D1  1  A1 40                LDA (BPA,X)             ; get instruction at breakpoint address
00B7D3  1  99 94 17             STA BPD,Y               ; save it
00B7D6  1  A9 00                LDA #0                  ; BRK instruction
00B7D8  1  81 40                STA (BPA,X)             ; write breakpoint over code
00B7DA  1  C1 40                CMP (BPA,X)             ; If we don't read back what we wrote
00B7DC  1  F0 03                BEQ InRam
00B7DE  1  4C 59 B7             JMP BNOTINRAM           ; then address is not writable (user may have put it in ROM)
00B7E1  1  60           InRam:  RTS
00B7E2  1               
00B7E2  1               ; Remove breakpoint number A
00B7E2  1               BPREMOVE:
00B7E2  1  48                   PHA
00B7E3  1  20 A6 B7             JSR BPEXISTS
00B7E6  1  D0 1B                BNE OK
00B7E8  1  20 4A BE             JSR Imprint
00B7EB  1  42 72 65 61          .byte "Breakpoint not set!", CR, LF, 0
00B7EF  1  6B 70 6F 69  
00B7F3  1  6E 74 20 6E  
00B801  1  68                   PLA
00B802  1  60                   RTS
00B803  1               OK:
00B803  1  68                   PLA
00B804  1  A8                   TAY
00B805  1  0A                   ASL A                   ; multiply by 2 because table entries are two bytes
00B806  1  AA                   TAX
00B807  1  B9 94 17             LDA BPD,Y               ; get original instruction
00B80A  1  81 40                STA (BPA,X)             ; restore instruction at breakpoint address
00B80C  1  A9 00                LDA #0                  ; set BPA to address$0000 to clear breakpoint
00B80E  1  95 40                STA BPA,X
00B810  1  95 41                STA BPA+1,X
00B812  1  99 94 17             STA BPD,Y               ; and clear BPD
00B815  1  60                   RTS
00B816  1               
00B816  1               ; Breakpoint handler
00B816  1               BRKHANDLER:
00B816  1               .if .defined(APPLE2)
00B816  1               
00B816  1               ; On the Apple II platform the ROM interrupt handler has already
00B816  1               ; determined that a BRK intruction was executed and has saved the
00B816  1               ; register values in RAM.
00B816  1               
00B816  1                       SEC                     ; subtract 2 from return address to get actual instruction address
00B816  1                       LDA $3A
00B816  1                       SBC #2
00B816  1                       STA SAVE_PC             ; PC low
00B816  1                       LDA $3B
00B816  1                       SBC #0
00B816  1                       STA SAVE_PC+1           ; PC high
00B816  1                       LDA $45
00B816  1                       STA SAVE_A              ; A
00B816  1                       LDA $46
00B816  1                       STA SAVE_X              ; X
00B816  1                       LDA $47
00B816  1                       STA SAVE_Y              ; Y
00B816  1                       LDA $48
00B816  1                       STA SAVE_P              ; P
00B816  1                       JMP CHECKADDR
00B816  1               
00B816  1               .else
00B816  1               
00B816  1               ; On other platforms, save registers. Then look at processor status to
00B816  1               ; see if it was BRK or an IRQ. If IRQ, display a message and return
00B816  1               ; from interrupt. Otherwise handle as a BRK statement.
00B816  1               
00B816  1  8D 98 17             STA SAVE_A              ; save registers
00B819  1  8E 99 17             STX SAVE_X
00B81C  1  8C 9A 17             STY SAVE_Y
00B81F  1  68                   PLA                     ; P is on stack
00B820  1  8D 9C 17             STA SAVE_P
00B823  1  48                   PHA                     ; put P back on stack
00B824  1  A9 10                LDA  #%00010000         ; position of B bit
00B826  1  2C 9C 17             BIT  SAVE_P             ; is B bit set, indicating BRK and not IRQ?
00B829  1  D0 1E                BNE  BREAK              ; If so, got to break handler
00B82B  1  20 13 BE             JSR  PrintCR            ; Otherwise print message that we got an interrupt
00B82E  1  20 4A BE             JSR  Imprint
00B831  1  49 6E 74 65          .byte "Interrupt ?", CR, LF, 0
00B835  1  72 72 75 70  
00B839  1  74 20 3F 0D  
00B83F  1  AC 9A 17             LDY  SAVE_Y
00B842  1  AE 99 17             LDX  SAVE_X             ; Restore registers and return from interrupt
00B845  1  AD 98 17             LDA  SAVE_A
00B848  1  40                   RTI
00B849  1               BREAK:
00B849  1  BA                   TSX                     ; get stack pointer
00B84A  1  38                   SEC                     ; subtract 2 from return address to get actual instruction address
00B84B  1  BD 02 01             LDA $0102,X
00B84E  1  E9 02                SBC #2
00B850  1  9D 02 01             STA $0102,X             ; put original instruction address back on stack
00B853  1  8D 9D 17             STA SAVE_PC             ; also save it for later reference
00B856  1  BD 03 01             LDA $0103,X
00B859  1  E9 00                SBC #0
00B85B  1  9D 03 01             STA $0103,X
00B85E  1  8D 9E 17             STA SAVE_PC+1
00B861  1               .endif
00B861  1  A2 00                LDX #0
00B863  1               CHECKADDR:
00B863  1  AD 9D 17             LDA SAVE_PC             ; see if PC matches address of a breakpoint
00B866  1  D5 40                CMP BPA,X
00B868  1  D0 07                BNE TRYNEXT
00B86A  1  AD 9E 17             LDA SAVE_PC+1
00B86D  1  D5 41                CMP BPA+1,X
00B86F  1  F0 2A                BEQ MATCHES
00B871  1               TRYNEXT:
00B871  1  E8                   INX
00B872  1  E8                   INX
00B873  1  E0 08                CPX #8                  ; last breakpoint reached
00B875  1  D0 EC                BNE CHECKADDR
00B877  1               UNKNOWN:
00B877  1  20 13 BE             JSR PrintCR
00B87A  1  20 4A BE             JSR Imprint
00B87D  1  42 72 65 61          .asciiz "Breakpoint ? at $"
00B881  1  6B 70 6F 69  
00B885  1  6E 74 20 3F  
00B88F  1  AE 9D 17             LDX SAVE_PC
00B892  1  AC 9E 17             LDY SAVE_PC+1
00B895  1  20 AF BD             JSR PrintAddress
00B898  1  4C C2 B8             JMP RESTORE
00B89B  1               MATCHES:
00B89B  1  8A                   TXA
00B89C  1  48                   PHA
00B89D  1  20 13 BE             JSR PrintCR
00B8A0  1  A2 1B                LDX #<KnownBPString1
00B8A2  1  A0 C3                LDY #>KnownBPString1
00B8A4  1  20 28 BE             JSR PrintString
00B8A7  1  68                   PLA                      ; get BP # x2
00B8A8  1  48                   PHA                      ; save it again
00B8A9  1  4A                   LSR A                    ; divide by 2 to get BP number
00B8AA  1  20 84 BE             JSR PRHEX
00B8AD  1  A2 27                LDX #<KnownBPString2
00B8AF  1  A0 C3                LDY #>KnownBPString2
00B8B1  1  20 28 BE             JSR PrintString
00B8B4  1  AE 9D 17             LDX SAVE_PC
00B8B7  1  AC 9E 17             LDY SAVE_PC+1
00B8BA  1  20 AF BD             JSR PrintAddress
00B8BD  1  68                   PLA
00B8BE  1  4A                   LSR A
00B8BF  1  20 E2 B7             JSR BPREMOVE
00B8C2  1               RESTORE:
00B8C2  1  20 13 BE             JSR PrintCR
00B8C5  1  20 09 BA             JSR PrintRegisters      ; Print current values
00B8C8  1  AD 9D 17             LDA SAVE_PC             ; Disassemble current instruction
00B8CB  1  85 38                STA ADDR
00B8CD  1  AD 9E 17             LDA SAVE_PC+1
00B8D0  1  85 39                STA ADDR+1
00B8D2  1  20 80 C3             JSR DISASM
00B8D5  1  4C 2F B4             JMP MainLoop           ; Continue with JMon main command loop
00B8D8  1               
00B8D8  1               ; Memory write command.
00B8D8  1               ; Format:
00B8D8  1               ; : <addr> <bb> <bb> ... <Enter> or <Esc> (up to 255 chars)
00B8D8  1               ; eg:
00B8D8  1               ; : A000 12 34 56 78
00B8D8  1               Memory:
00B8D8  1  20 8E BE             JSR PrintChar           ; Echo command
00B8DB  1  20 20 BE             JSR PrintSpace          ; Then a space
00B8DE  1               ;       JSR PrintCR
00B8DE  1  20 9D BD             JSR GetAddress          ; Get start address (ESC will exit)
00B8E1  1  86 32                STX SL
00B8E3  1  84 33                STY SH
00B8E5  1  A9 01                LDA #1
00B8E7  1  8D A2 17             STA CHAROK              ; Set flag to accept character input
00B8EA  1  8D 80 17             STA RETOK               ; Set flag to accep return
00B8ED  1               writeLoop:
00B8ED  1  20 20 BE             JSR PrintSpace          ; Echo space
00B8F0  1  20 65 BD             JSR GetByte             ; Get data byte (ESC will exit)
00B8F3  1  90 04                BCC @noret              ; Hopefully return will exit also W4JBM
00B8F5  1  20 13 BE             JSR PrintCR
00B8F8  1  60                   RTS
00B8F9  1  A0 00        @noret: LDY #0
00B8FB  1  91 32                STA (SL),Y              ; write data to address
00B8FD  1               ;        CMP (SL),Y
00B8FD  1               ;        BEQ Okay
00B8FD  1               ;        JSR Imprint             ; Display message that same data not written back
00B8FD  1               ;        .byte " Read: ", 0
00B8FD  1               ;        LDY #0
00B8FD  1               ;        LDA (SL),Y
00B8FD  1               ;        JSR PrintByte
00B8FD  1               ;        JSR PrintSpace
00B8FD  1               Okay:
00B8FD  1  18                   CLC                     ; increment address
00B8FE  1  A5 32                LDA SL
00B900  1  69 01                ADC #1
00B902  1  85 32                STA SL
00B904  1  90 02                BCC nocarry
00B906  1  E6 33                INC SH
00B908  1               nocarry:
00B908  1  A9 0F                LDA #BYTESPERLINE-1     ; Is address a multiple of 8/4?
00B90A  1  24 32                BIT SL
00B90C  1  D0 DF                BNE writeLoop           ; If not, keep getting data
00B90E  1  20 13 BE             JSR PrintCR             ; Otherwise start new line
00B911  1  A6 32                LDX SL
00B913  1  A4 33                LDY SH
00B915  1  20 AF BD             JSR PrintAddress        ; Display current address
00B918  1  4C ED B8             JMP writeLoop           ; Input more data
00B91B  1               
00B91B  1               ; Register change command.
00B91B  1               ; Displays and sets values of registers
00B91B  1               ; Values are set when JMON is entered.
00B91B  1               ; Uses values with Go command.
00B91B  1               ;
00B91B  1               ; R A-D2 X-00 Y-04 S-01FE P-FF NVBDIZC
00B91B  1               ; FF02   A0 7F       LDY   #$7F
00B91B  1               ;   A-00 X-00 Y-00 S-0180 P-01
00B91B  1               ; PC-FF02
00B91B  1               ;
00B91B  1               ; Displays saved value of registers
00B91B  1               ; Prompts for new value for each register.
00B91B  1               ; <Esc> cancels at any time.
00B91B  1               
00B91B  1               Registers:
00B91B  1               .ifdef ECHO
00B91B  1  20 8E BE             JSR PrintChar           ; Echo command
00B91E  1               .endif
00B91E  1  20 13 BE             JSR PrintCR
00B921  1               
00B921  1  20 09 BA             JSR PrintRegisters      ; Print current values
00B924  1               
00B924  1  AD 9D 17             LDA SAVE_PC             ; Disassemble current instruction
00B927  1  85 38                STA ADDR
00B929  1  AD 9E 17             LDA SAVE_PC+1
00B92C  1  85 39                STA ADDR+1
00B92E  1  20 80 C3             JSR DISASM
00B931  1               
00B931  1  A9 01                LDA #1
00B933  1  8D 80 17             STA RETOK
00B936  1  A9 41                LDA #'A'                ; Now print and prompt for new values
00B938  1  20 8E BE             JSR PrintChar
00B93B  1  A9 2D                LDA #'-'
00B93D  1  20 8E BE             JSR PrintChar
00B940  1  20 65 BD             JSR GetByte
00B943  1  B0 06                BCS RetPressed1
00B945  1  8D 98 17             STA SAVE_A
00B948  1  4C 51 B9             JMP EnterX
00B94B  1               RetPressed1:
00B94B  1  AD 98 17             LDA SAVE_A
00B94E  1  20 7B BE             JSR PrintByte
00B951  1               EnterX:
00B951  1  20 20 BE             JSR PrintSpace
00B954  1  A9 58                LDA #'X'
00B956  1  20 8E BE             JSR PrintChar
00B959  1  A9 2D                LDA #'-'
00B95B  1  20 8E BE             JSR PrintChar
00B95E  1  20 65 BD             JSR GetByte
00B961  1  B0 06                BCS RetPressed2
00B963  1  8D 99 17             STA SAVE_X
00B966  1  4C 6F B9             JMP EnterY
00B969  1               RetPressed2:
00B969  1  AD 99 17             LDA SAVE_X
00B96C  1  20 7B BE             JSR PrintByte
00B96F  1               EnterY:
00B96F  1  20 20 BE             JSR PrintSpace
00B972  1  A9 59                LDA #'Y'
00B974  1  20 8E BE             JSR PrintChar
00B977  1  A9 2D                LDA #'-'
00B979  1  20 8E BE             JSR PrintChar
00B97C  1  20 65 BD             JSR GetByte
00B97F  1  B0 06                BCS RetPressed3
00B981  1  8D 9A 17             STA SAVE_Y
00B984  1  4C 8D B9             JMP EnterS
00B987  1               RetPressed3:
00B987  1  AD 9A 17             LDA SAVE_Y
00B98A  1  20 7B BE             JSR PrintByte
00B98D  1               EnterS:
00B98D  1  8D 9A 17             STA SAVE_Y
00B990  1  20 20 BE             JSR PrintSpace
00B993  1  A9 53                LDA #'S'
00B995  1  20 8E BE             JSR PrintChar
00B998  1  A9 2D                LDA #'-'
00B99A  1  20 8E BE             JSR PrintChar
00B99D  1  A9 01                LDA #$01
00B99F  1  20 7B BE             JSR PrintByte
00B9A2  1  20 65 BD             JSR GetByte
00B9A5  1  B0 06                BCS RetPressed4
00B9A7  1  8D 9B 17             STA SAVE_S
00B9AA  1  4C B3 B9             JMP EnterP
00B9AD  1               RetPressed4:
00B9AD  1  AD 9B 17             LDA SAVE_S
00B9B0  1  20 7B BE             JSR PrintByte
00B9B3  1               EnterP:
00B9B3  1  20 20 BE             JSR PrintSpace
00B9B6  1  A9 50                LDA #'P'
00B9B8  1  20 8E BE             JSR PrintChar
00B9BB  1  A9 2D                LDA #'-'
00B9BD  1  20 8E BE             JSR PrintChar
00B9C0  1  20 65 BD             JSR GetByte
00B9C3  1  B0 06                BCS RetPressed5
00B9C5  1  8D 9C 17             STA SAVE_P
00B9C8  1  4C D1 B9             JMP PrintP
00B9CB  1               RetPressed5:
00B9CB  1  AD 9C 17             LDA SAVE_P
00B9CE  1  20 7B BE             JSR PrintByte
00B9D1  1               PrintP:
00B9D1  1  20 20 BE             JSR PrintSpace
00B9D4  1  20 BB C0             JSR OUTP
00B9D7  1  20 13 BE             JSR PrintCR
00B9DA  1  A9 50                LDA #'P'
00B9DC  1  20 8E BE             JSR PrintChar
00B9DF  1  A9 43                LDA #'C'
00B9E1  1  20 8E BE             JSR PrintChar
00B9E4  1  A9 2D                LDA #'-'
00B9E6  1  20 8E BE             JSR PrintChar
00B9E9  1  20 9D BD             JSR GetAddress
00B9EC  1  B0 09                BCS RetPressed6
00B9EE  1  8E 9D 17             STX SAVE_PC
00B9F1  1  8C 9E 17             STY SAVE_PC+1
00B9F4  1  4C 00 BA             JMP Eol
00B9F7  1               RetPressed6:
00B9F7  1  AE 9D 17             LDX SAVE_PC
00B9FA  1  AC 9E 17             LDY SAVE_PC+1
00B9FD  1  20 AF BD             JSR PrintAddress
00BA00  1               Eol:
00BA00  1  20 13 BE             JSR PrintCR
00BA03  1  A9 00                LDA #0
00BA05  1  8D 80 17             STA RETOK
00BA08  1  60                   RTS
00BA09  1               
00BA09  1               ; Print saved values of registers
00BA09  1               PrintRegisters:
00BA09  1  A9 41                LDA #'A'
00BA0B  1  20 8E BE             JSR PrintChar
00BA0E  1  A9 2D                LDA #'-'
00BA10  1  20 8E BE             JSR PrintChar
00BA13  1  AD 98 17             LDA SAVE_A
00BA16  1  20 7B BE             JSR PrintByte
00BA19  1  20 20 BE             JSR PrintSpace
00BA1C  1  A9 58                LDA #'X'
00BA1E  1  20 8E BE             JSR PrintChar
00BA21  1  A9 2D                LDA #'-'
00BA23  1  20 8E BE             JSR PrintChar
00BA26  1  AD 99 17             LDA SAVE_X
00BA29  1  20 7B BE             JSR PrintByte
00BA2C  1  20 20 BE             JSR PrintSpace
00BA2F  1  A9 59                LDA #'Y'
00BA31  1  20 8E BE             JSR PrintChar
00BA34  1  A9 2D                LDA #'-'
00BA36  1  20 8E BE             JSR PrintChar
00BA39  1  AD 9A 17             LDA SAVE_Y
00BA3C  1  20 7B BE             JSR PrintByte
00BA3F  1  20 20 BE             JSR PrintSpace
00BA42  1  A9 53                LDA #'S'
00BA44  1  20 8E BE             JSR PrintChar
00BA47  1  A9 2D                LDA #'-'
00BA49  1  20 8E BE             JSR PrintChar
00BA4C  1  A9 01                LDA #01
00BA4E  1  20 7B BE             JSR PrintByte
00BA51  1  AD 9B 17             LDA SAVE_S
00BA54  1  20 7B BE             JSR PrintByte
00BA57  1  20 20 BE             JSR PrintSpace
00BA5A  1  A9 50                LDA #'P'
00BA5C  1  20 8E BE             JSR PrintChar
00BA5F  1  A9 2D                LDA #'-'
00BA61  1  20 8E BE             JSR PrintChar
00BA64  1  AD 9C 17             LDA SAVE_P
00BA67  1  20 7B BE             JSR PrintByte
00BA6A  1  20 20 BE             JSR PrintSpace
00BA6D  1  20 BB C0             JSR OUTP
00BA70  1  4C 13 BE             JMP PrintCR
00BA73  1               
00BA73  1               
00BA73  1               ; Checksum command. Sum memory bytes in a range and show 16-bit result.
00BA73  1               ; Format: K <start> <end>
00BA73  1               ; e.g.
00BA73  1               ; K C100 C1FF 1234
00BA73  1               Checksum:
00BA73  1               .ifdef ECHO
00BA73  1  20 8E BE             JSR PrintChar           ; echo command
00BA76  1               .endif
00BA76  1  20 20 BE             JSR PrintSpace          ; print space
00BA79  1  20 9D BD             JSR GetAddress          ; prompt for start address
00BA7C  1  86 32                STX SL                  ; store address
00BA7E  1  84 33                STY SH
00BA80  1  20 20 BE             JSR PrintSpace          ; print space
00BA83  1  20 9D BD             JSR GetAddress          ; prompt for end address
00BA86  1  86 34                STX EL                  ; store address
00BA88  1  84 35                STY EH
00BA8A  1  20 13 BE             JSR PrintCR
00BA8D  1               
00BA8D  1  20 7F BF             JSR RequireStartNotAfterEnd
00BA90  1  90 01                BCC @okay1
00BA92  1  60                   RTS
00BA93  1               
00BA93  1               @okay1:
00BA93  1  A9 00                LDA #0                  ; Initialize checkum to zero
00BA95  1  85 36                STA DL
00BA97  1  85 37                STA DH
00BA99  1  A0 00                LDY #0
00BA9B  1               @CalcSum:
00BA9B  1  B1 32                LDA (SL),Y              ; read a byte
00BA9D  1  18                   CLC
00BA9E  1  65 36                ADC DL                  ; add to sum
00BAA0  1  85 36                STA DL
00BAA2  1  90 02                BCC @NoCarry1
00BAA4  1  E6 37                INC DH                  ; add carry to upper byte of sum
00BAA6  1               @NoCarry1:
00BAA6  1  A5 33                LDA SH                  ; reached end yet?
00BAA8  1  C5 35                CMP EH
00BAAA  1  D0 10                BNE @NotDone
00BAAC  1  A5 32                LDA SL
00BAAE  1  C5 34                CMP EL
00BAB0  1  D0 0A                BNE @NotDone
00BAB2  1               
00BAB2  1  A6 36                LDX DL                  ; Get checksum value
00BAB4  1  A4 37                LDY DH
00BAB6  1  20 AF BD             JSR PrintAddress        ; Print it
00BAB9  1  4C 13 BE             JMP PrintCR
00BABC  1               
00BABC  1               @NotDone:
00BABC  1  A5 32                LDA SL                  ; increment start address
00BABE  1  18                   CLC
00BABF  1  69 01                ADC #1
00BAC1  1  85 32                STA SL
00BAC3  1  90 02                BCC @NoCarry2
00BAC5  1  E6 33                INC SH
00BAC7  1               @NoCarry2:
00BAC7  1  4C 9B BA             JMP @CalcSum
00BACA  1               
00BACA  1               ; S Record Loader
00BACA  1               ; Format: J
00BACA  1               ; Load a Motorola hex (RUN or S record) format file into memory. Exits
00BACA  1               ; if <ESC> is received at any time or after an S9 record is received.
00BACA  1               ; Executes the loaded code if the start address is non-zero.
00BACA  1               ;
00BACA  1               ; File record format:
00BACA  1               ; S <rec type> <byte count> <address> <data>... <checksum> <CR>/<LF>/<NUL>
00BACA  1               ;
00BACA  1               ; e.g.
00BACA  1               ; S00F000068656C6C6F202020202000003C
00BACA  1               ; S11F00007C0802A6900100049421FFF07C6C1B787C8C23783C6000003863000026
00BACA  1               ; S11F001C4BFFFFE5398000007D83637880010014382100107C0803A64E800020E9
00BACA  1               ; S111003848656C6C6F20776F726C642E0A0042
00BACA  1               ; S5030003F9
00BACA  1               ; S9030000FC
00BACA  1               ;
00BACA  1               ; Record types:
00BACA  1               ; S0 header - accepted but ignored
00BACA  1               ; S1 - 16-bit address record
00BACA  1               ; S2,S3,S4 - not supported
00BACA  1               ; S5,S6 - accepted but ignored
00BACA  1               ; S7,S8 - not supported
00BACA  1               ; S9 - start address. Executes if address is not zero.
00BACA  1               ;
00BACA  1               ; At any point, quit if <ESC> character received.
00BACA  1               ;
00BACA  1               ; Modified to Intel Hex by W4JBM
00BACA  1               
00BACA  1               Load:
00BACA  1  A2 68                ldx     #<SLoading
00BACC  1  A0 C3                ldy     #>SLoading
00BACE  1  20 13 BE             jsr     PrintCR
00BAD1  1  20 28 BE             jsr     PrintString     ; Display "Loading"
00BAD4  1  20 13 BE             jsr     PrintCR
00BAD7  1               
00BAD7  1               SRecord:
00BAD7  1  A9 00                lda     #0
00BAD9  1  8D BB 17             sta     checksum        ; Checksum = 0
00BADC  1  8D BC 17             sta     bytesRead       ; BytesRead = 0
00BADF  1  8D BE 17             sta     byteCount       ; ByteCount = 0
00BAE2  1  85 38                sta     ADDR            ; Address = 0
00BAE4  1  85 39                sta     ADDR+1
00BAE6  1               
00BAE6  1               sloop:
00BAE6  1  20 D9 BC             jsr     GetKey          ; Get character
00BAE9  1  C9 1B                cmp     #ESC
00BAEB  1  D0 01                bne     notesc
00BAED  1  60                   rts                     ; Return if <ESC>
00BAEE  1               notesc:
00BAEE  1               ;       jsr     PrintChar       ; Echo the character
00BAEE  1  C9 0D                cmp     #CR             ; Ignore if <CR>
00BAF0  1  F0 F4                beq     sloop
00BAF2  1  C9 0A                cmp     #LF             ; Ignore if <LF>
00BAF4  1  F0 F0                beq     sloop
00BAF6  1  C9 00                cmp     #NUL            ; Ignore if <NUL>
00BAF8  1  F0 EC                beq     sloop
00BAFA  1               
00BAFA  1  C9 3A                cmp     #':'            ; Should be ':'
00BAFC  1  F0 0B                beq     validType
00BAFE  1               ;        bne     invalidRecord   ; If not, error
00BAFE  1               
00BAFE  1               invalidRecord:
00BAFE  1  A2 4A                ldx     #<SInvalidRecord
00BB00  1  A0 C3                ldy     #>SInvalidRecord
00BB02  1  20 28 BE             jsr     PrintString     ; Display "Invalid record"
00BB05  1  20 13 BE             jsr     PrintCR
00BB08  1  60                   rts                     ; Return
00BB09  1               
00BB09  1               validType:
00BB09  1  20 80 BC             jsr     getHexByte      ; Get byte count
00BB0C  1  8D BE 17             sta     byteCount       ; Save as byte count
00BB0F  1  8D BB 17             sta     checksum        ; and use for start of checksum
00BB12  1               
00BB12  1               getadd:
00BB12  1  20 95 BC             jsr     getHexAddress   ; Get 16-bit start address
00BB15  1  B0 E7                bcs     invalidRecord
00BB17  1               
00BB17  1  86 38                stx     ADDR            ; Save as address
00BB19  1  84 39                sty     ADDR+1
00BB1B  1               
00BB1B  1  8A                   txa
00BB1C  1  18                   clc
00BB1D  1  6D BB 17             adc     checksum        ; Add address bytes to checksum
00BB20  1  8D BB 17             sta     checksum
00BB23  1  98                   tya
00BB24  1  18                   clc
00BB25  1  6D BB 17             adc     checksum
00BB28  1  8D BB 17             sta     checksum
00BB2B  1               
00BB2B  1               getType:
00BB2B  1  20 80 BC             jsr     getHexByte      ; Get type
00BB2E  1  8D BD 17             sta     recordType     ; Save as byte count
00BB31  1  C9 00                cmp     #0              ; Record Type 0 has data
00BB33  1  F0 06                beq     checkcnt
00BB35  1  C9 01                cmp     #1              ; Record Type 1 means we are done
00BB37  1  F0 5C                beq     endofload
00BB39  1  D0 C3                bne     invalidRecord   ; Anything else is an error
00BB3B  1               
00BB3B  1               checkcnt:
00BB3B  1  AD BE 17             lda     byteCount
00BB3E  1  C9 00                cmp     #0              ; Record too short?
00BB40  1  F0 BC                beq     invalidRecord
00BB42  1  C9 21                cmp     #$21            ; Record too long?
00BB44  1  B0 B8                bcs     invalidRecord
00BB46  1               
00BB46  1               readRecord:
00BB46  1  20 80 BC             jsr     getHexByte      ; Get two hex digits
00BB49  1  B0 B3                bcs     invalidRecord   ; Exit if invalid
00BB4B  1               
00BB4B  1  8D BA 17             sta     temp1           ; Save data
00BB4E  1               
00BB4E  1  18                   clc
00BB4F  1  6D BB 17             adc     checksum        ; Add data read to checksum
00BB52  1  8D BB 17             sta     checksum
00BB55  1               
00BB55  1  AD BA 17             lda     temp1           ; Get data back
00BB58  1  A0 00                ldy     #0
00BB5A  1  91 38                sta     (ADDR),y        ; Write data to address
00BB5C  1               
00BB5C  1  AD BC 17             lda     bytesRead       ; If bytesRead = byteCount
00BB5F  1  18                   clc
00BB60  1  69 01                adc     #1
00BB62  1  CD BE 17             cmp     byteCount
00BB65  1  F0 0C                beq     dataend         ; ...break out of loop
00BB67  1               
00BB67  1               
00BB67  1               
00BB67  1               nowrite:
00BB67  1  E6 38                inc     ADDR            ; Increment address (low byte)
00BB69  1  D0 02                bne     @nocarry1
00BB6B  1  E6 39                inc     ADDR+1          ; Increment address (high byte)
00BB6D  1               @nocarry1:
00BB6D  1  EE BC 17             inc     bytesRead       ; Increment bytesRead
00BB70  1  4C 46 BB             jmp     readRecord      ; Go back and read more data
00BB73  1               
00BB73  1               
00BB73  1               ; We get here when bytesRead = byteCount
00BB73  1               
00BB73  1               dataend:
00BB73  1  A9 2E                lda     #'.'
00BB75  1  20 8E BE             jsr     PrintChar
00BB78  1  20 80 BC             jsr     getHexByte      ; Get two hex digits (checksum)
00BB7B  1  B0 81                bcs     invalidRecord
00BB7D  1               okay1:
00BB7D  1  49 FF                eor     #$FF            ; Calculate 2's complement
00BB7F  1  18                   clc
00BB80  1  69 01                adc     #1
00BB82  1  CD BB 17             cmp     checksum        ; Compare to calculated checksum
00BB85  1  F0 0B                beq     sumokay         ; branch if matches
00BB87  1  A2 59                ldx     #<SChecksumError
00BB89  1  A0 C3                ldy     #>SChecksumError
00BB8B  1  20 28 BE             jsr     PrintString     ; Display "Checksum error"
00BB8E  1  20 13 BE             jsr     PrintCR
00BB91  1  60                   rts                     ; Return
00BB92  1               
00BB92  1               sumokay:
00BB92  1  4C D7 BA             jmp     SRecord         ; If not go back and read more records
00BB95  1               
00BB95  1               
00BB95  1               ; We get here if we have a Record Type of 1
00BB95  1               endofload:
00BB95  1  20 80 BC             jsr     getHexByte      ; Get two hex digits (checksum)
00BB98  1               
00BB98  1               ;
00BB98  1               ; On the PAL-1/KIM-1, we have not UART/ACIA buffering, so we
00BB98  1               ; do a delay at the end just in case any spurour CR or LF
00BB98  1               ; characters come in. This is really ugly, brute force code.
00BB98  1               
00BB98  1  A0 FF                 ldy #$FF
00BB9A  1  A2 FF        @delay1: ldx #$FF
00BB9C  1  CA           @delay2: dex
00BB9D  1  D0 FD                 bne @delay2
00BB9F  1  CA           @delay3: dex
00BBA0  1  D0 FD                 bne @delay3
00BBA2  1  CA           @delay4: dex
00BBA3  1  D0 FD                 bne @delay4
00BBA5  1  CA           @delay5: dex
00BBA6  1  D0 FD                 bne @delay5
00BBA8  1  88                    dey
00BBA9  1  D0 EF                 bne @delay1
00BBAB  1               
00BBAB  1  20 13 BE             jsr     PrintCR
00BBAE  1  A2 70                ldx     #<SLoaded
00BBB0  1  A0 C3                ldy     #>SLoaded
00BBB2  1  20 28 BE             jsr     PrintString     ; Display "Loaded"
00BBB5  1  20 13 BE             jsr     PrintCR
00BBB8  1  60                   rts
00BBB9  1               
00BBB9  1               
00BBB9  1               ; Write S record file to output frome startAddress to endAddress with
00BBB9  1               ; execution start address goAddress.
00BBB9  1               ;
00BBB9  1               ; Changed to Intel Hex by W4JBM
00BBB9  1               
00BBB9  1               Writer:
00BBB9  1  20 8E BE             JSR     PrintChar       ; echo command
00BBBC  1  20 20 BE             JSR     PrintSpace      ; print space
00BBBF  1  20 9D BD             JSR     GetAddress      ; prompt for start address
00BBC2  1  86 32                STX     SL              ; store address
00BBC4  1  84 33                STY     SH
00BBC6  1  20 20 BE             JSR     PrintSpace      ; print space
00BBC9  1  20 9D BD             JSR     GetAddress      ; prompt for end address
00BBCC  1  86 34                STX     EL              ; store address
00BBCE  1  84 35                STY     EH
00BBD0  1               ;       JSR     PrintSpace      ; print space
00BBD0  1               ;       JSR     GetAddress      ; prompt for go address
00BBD0  1               ;       STX     DL              ; store address
00BBD0  1               ;       STY     DH
00BBD0  1  20 13 BE             JSR     PrintCR
00BBD3  1               
00BBD3  1  20 7F BF             JSR     RequireStartNotAfterEnd
00BBD6  1  90 01                BCC     @okay
00BBD8  1  60                   RTS
00BBD9  1               @okay:
00BBD9  1  A5 32                lda     SL              ; address = startAddress
00BBDB  1  85 38                sta     ADDR
00BBDD  1  A5 33                lda     SH
00BBDF  1  85 39                sta     ADDR+1
00BBE1  1               
00BBE1  1               ; Write S0 record, fixed as: <CR>S0030000FC<CR>
00BBE1  1               
00BBE1  1               ;        ldx     #<S0String
00BBE1  1               ;        ldy     #>S0String
00BBE1  1               ;        jsr     PrintString
00BBE1  1               
00BBE1  1               writes1:                        ; Write S1 records
00BBE1  1  A9 00                lda     #0
00BBE3  1  8D BF 17             sta     bytesWritten    ; bytesWritten = 0
00BBE6  1               
00BBE6  1  A9 3A                lda     #':'
00BBE8  1  20 8E BE             jsr     PrintChar
00BBEB  1               
00BBEB  1               ; Changed bytes per line to hard coded 20
00BBEB  1               
00BBEB  1  A9 20                lda     #$20             ; write bytesPerLine
00BBED  1  8D BB 17             sta     checksum        ; update checksum
00BBF0  1  20 7B BE             jsr     PrintByte
00BBF3  1               
00BBF3  1  A6 38                ldx      ADDR           ; write address
00BBF5  1  A4 39                ldy      ADDR+1
00BBF7  1  20 AF BD             jsr      PrintAddress
00BBFA  1               
00BBFA  1  A9 30                lda     #'0'            ; Record Type "00"
00BBFC  1  20 8E BE             jsr     PrintChar
00BBFF  1  20 8E BE             jsr     PrintChar
00BC02  1               
00BC02  1               
00BC02  1  AD BB 17             lda      checksum       ; checksum = checksum + address high
00BC05  1  18                   clc
00BC06  1  65 39                adc      ADDR+1
00BC08  1  18                   clc
00BC09  1  65 38                adc      ADDR           ; checksum = checksum + address low
00BC0B  1  8D BB 17             sta      checksum
00BC0E  1               
00BC0E  1               writeLoop1:
00BC0E  1  A0 00                ldy     #0
00BC10  1  B1 38                lda     (ADDR),y
00BC12  1  20 7B BE             jsr     PrintByte       ; print byte at address
00BC15  1               
00BC15  1  B1 38                lda     (ADDR),y        ; Get back A (modified by PrintByte)
00BC17  1  18                   clc
00BC18  1  6D BB 17             adc     checksum        ; checksum = checksum + byte at address
00BC1B  1  8D BB 17             sta     checksum
00BC1E  1               
00BC1E  1  E6 38                inc     ADDR            ; Increment address (low byte)
00BC20  1  D0 02                bne     nocarry1
00BC22  1  E6 39                inc     ADDR+1          ; Increment address (high byte)
00BC24  1               nocarry1:
00BC24  1  EE BF 17             inc     bytesWritten    ; bytesWritten = bytesWritten + 1
00BC27  1               
00BC27  1  AD BF 17             lda     bytesWritten    ; if bytesWritten = bytesPerLine
00BC2A  1  C9 20                cmp     #$20            ; Another hard coded change to bytes per line
00BC2C  1  D0 E0                bne     writeLoop1      ; ...go back and loop
00BC2E  1               
00BC2E  1  AD BB 17             lda     checksum        ; Calculate checksum 2's complement
00BC31  1  49 FF                eor     #$ff
00BC33  1  18                   clc
00BC34  1  69 01                adc     #1
00BC36  1  20 7B BE             jsr     PrintByte       ; Output checksum
00BC39  1  20 13 BE             jsr     PrintCR         ; Output line terminator
00BC3C  1               
00BC3C  1               ;        lda     ADDR+1          ; if address < endAddress, go back and continue
00BC3C  1               ;        cmp     EH
00BC3C  1               ;        bmi     writes1
00BC3C  1               ;        lda     ADDR
00BC3C  1               ;        cmp     EL
00BC3C  1               ;        bmi     writes1
00BC3C  1               
00BC3C  1  A5 39                lda     ADDR+1          ; if address <= endAddress, go back and continue
00BC3E  1  C5 35                cmp     EH
00BC40  1  D0 04                bne     @tstaddr
00BC42  1  A5 38                lda     ADDR
00BC44  1  C5 34                cmp     EL
00BC46  1               @tstaddr:
00BC46  1  90 99                bcc     writes1
00BC48  1  F0 97                beq     writes1
00BC4A  1               
00BC4A  1               ; Write Final
00BC4A  1               writes9:
00BC4A  1  20 4A BE             JSR Imprint
00BC4D  1  3A 30 30 30          .asciiz ":00000001FF"
00BC51  1  30 30 30 30  
00BC55  1  31 46 46 00  
00BC59  1               
00BC59  1               ;        lda     #'S'            ; Write S9
00BC59  1               ;        jsr     PrintChar
00BC59  1               ;        lda     #'9'
00BC59  1               ;        jsr     PrintChar
00BC59  1               ;        lda     #$03            ; Write 03
00BC59  1               ;        jsr     PrintByte
00BC59  1               ;        lda     #$03            ; checksum = 03
00BC59  1               ;        sta     checksum
00BC59  1               
00BC59  1               ;        ldx     DL              ; Send go address
00BC59  1               ;        ldy     DH
00BC59  1               ;        jsr     PrintAddress
00BC59  1               
00BC59  1               ;        lda     checksum        ; checksum = checksum + goAaddress high
00BC59  1               ;        clc
00BC59  1               ;        adc     DH
00BC59  1               ;        clc
00BC59  1               ;        adc     DL              ; checksum = checksum + goAddress low
00BC59  1               ;        sta     checksum
00BC59  1               
00BC59  1               ;        lda     checksum        ; Calculate checksum 1's complement
00BC59  1               ;        eor     #$ff
00BC59  1               ;        jsr     PrintByte       ; Output checksum
00BC59  1  20 13 BE             jsr     PrintCR         ; Output line terminator
00BC5C  1               
00BC5C  1  60                   rts
00BC5D  1               
00BC5D  1               ; Read character corresponding to hex number ('0'-'9','A'-'F').
00BC5D  1               ; If valid, return binary value in A and carry bit clear.
00BC5D  1               ; If not valid, return with carry bit set.
00BC5D  1               getHexChar:
00BC5D  1  20 D9 BC             jsr     GetKey          ; Read character
00BC60  1               ;       jsr     PrintChar       ; Echo the character
00BC60  1  C9 30                cmp     #'0'            ; Error if < '0'
00BC62  1  30 18                bmi     error1
00BC64  1  C9 3A                cmp     #'9'+1          ; Valid if <= '9'
00BC66  1  30 0E                bmi     number1
00BC68  1  C9 47                cmp     #'F'+1          ; Error if > 'F'
00BC6A  1  10 10                bpl     error1
00BC6C  1  C9 41                cmp     #'A'            ; Error if < 'A'
00BC6E  1  30 0C                bmi     error1
00BC70  1  38                   sec
00BC71  1  E9 37                sbc     #'A'-10         ; Value is character-('A'-10)
00BC73  1  4C 7E BC             jmp     good1
00BC76  1               number1:
00BC76  1  38                   sec
00BC77  1  E9 30                sbc     #'0'            ; Value is character-'0'
00BC79  1  4C 7E BC             jmp     good1
00BC7C  1               error1:
00BC7C  1  38                   sec                     ; Set carry to indicate error
00BC7D  1  60                   rts                     ; Return
00BC7E  1               good1:
00BC7E  1  18                   clc                     ; Clear carry to indicate valid
00BC7F  1  60                   rts                     ; Return
00BC80  1               
00BC80  1               ; Read two characters corresponding to 8-bit hex number.
00BC80  1               ; If valid, return binary value in A and carry bit clear.
00BC80  1               ; If not valid, return with carry bit set.
00BC80  1               getHexByte:
00BC80  1  20 5D BC             jsr     getHexChar      ; Get high nybble
00BC83  1  B0 1D                bcs     bad1            ; Branch if invalid
00BC85  1  0A                   asl                     ; Shift return value left to upper nybble
00BC86  1  0A                   asl
00BC87  1  0A                   asl
00BC88  1  0A                   asl
00BC89  1  8D BA 17             sta     temp1           ; Save value
00BC8C  1  20 5D BC             jsr     getHexChar      ; Get low nybble
00BC8F  1  B0 11                bcs     bad1            ; Branch if invalid
00BC91  1  0D BA 17             ora     temp1           ; Add (OR) return value to previous value
00BC94  1  60                   rts                     ; Return with carry clear
00BC95  1               
00BC95  1               ; Read four characters corresponding to 16-bit hex address.
00BC95  1               ; If valid, return binary value in X (low) and Y (high) and carry bit clear.
00BC95  1               ; If not valid, return with carry bit set.
00BC95  1               getHexAddress:
00BC95  1  20 80 BC             jsr     getHexByte      ; Get high order byte
00BC98  1  B0 08                bcs     bad1            ; Branch if invalid
00BC9A  1  A8                   tay                     ; Save value in Y
00BC9B  1  20 80 BC             jsr     getHexByte      ; Get low order byte
00BC9E  1  B0 02                bcs     bad1            ; Branch if invalid
00BCA0  1  AA                   tax                     ; Save value in X
00BCA1  1  60                   rts                     ; Return with carry clear
00BCA2  1               bad1:
00BCA2  1  60                   rts                     ; Return with carry set
00BCA3  1               
00BCA3  1               ; -------------------- Utility Functions --------------------
00BCA3  1               
00BCA3  1               ; Generate one line of output for the dump command.
00BCA3  1               ; Apple 1 format:         AAAA DD DD DD DD DD DD DD DD ........
00BCA3  1               ; Superboard /// format:  AAAA DD DD DD DD ....
00BCA3  1               ; Displays 8 (4 for OSI) bytes of memory
00BCA3  1               ; Starting address in SL,SH.
00BCA3  1               ; Registers changed: None
00BCA3  1               DumpLine:
00BCA3  1  48                   PHA                     ; save A
00BCA4  1  8A                   TXA
00BCA5  1  48                   PHA                     ; Save X
00BCA6  1  98                   TYA
00BCA7  1  48                   PHA                     ; Save Y
00BCA8  1  A6 32                LDX SL                  ; Get start address
00BCAA  1  A4 33                LDY SH
00BCAC  1  20 AF BD             JSR PrintAddress        ; Display address
00BCAF  1  20 20 BE             JSR PrintSpace          ; and then a space
00BCB2  1  A0 00                LDY #0
00BCB4  1  B1 32        @loop1: LDA (SL),Y              ; Get byte of data from memory
00BCB6  1  20 7B BE             JSR PrintByte           ; Display it in hex
00BCB9  1  20 20 BE             JSR PrintSpace          ; Followed by space
00BCBC  1  C8                   INY
00BCBD  1  C0 10                CPY #BYTESPERLINE       ; Print 8/4 bytes per line
00BCBF  1  D0 F3                BNE @loop1
00BCC1  1  20 20 BE             JSR PrintSpace
00BCC4  1  A0 00                LDY #0
00BCC6  1  B1 32        @loop2: LDA (SL),Y              ; Now get the same data
00BCC8  1  20 00 BE             JSR PrintAscii          ; Display it in ASCII
00BCCB  1  C8                   INY
00BCCC  1  C0 10                CPY #BYTESPERLINE       ; 8/4 characters per line
00BCCE  1  D0 F6                BNE @loop2
00BCD0  1  20 13 BE             JSR PrintCR             ; new line
00BCD3  1  68                   PLA                     ; Restore Y
00BCD4  1  A8                   TAY
00BCD5  1  68                   PLA                     ; Restore X
00BCD6  1  AA                   TAX
00BCD7  1  68                   PLA                     ; Restore A
00BCD8  1  60                   RTS
00BCD9  1               
00BCD9  1               ; Get character from keyboard
00BCD9  1               ; Returns character in A
00BCD9  1               ; Clears high bit to be valid ASCII
00BCD9  1               ; Registers changed: A
00BCD9  1               GetKey:
00BCD9  1               .if .defined(APPLE1)
00BCD9  1                       LDA KBDCR               ; Read keyboard control register
00BCD9  1                       BPL GetKey              ; Loop until key pressed (bit 7 goes high)
00BCD9  1                       LDA KBD                 ; Get keyboard data
00BCD9  1                       AND #%01111111          ; Clear most significant bit to convert to standard ASCII
00BCD9  1                       RTS
00BCD9  1               .elseif .defined(APPLE2)
00BCD9  1                       LDA $C000               ; Read keyboard register
00BCD9  1                       BPL GetKey              ; Loop until key pressed (bit 7 goes high)
00BCD9  1                       AND #%01111111          ; Clear most significant bit to convert to standard ASCII
00BCD9  1                       PHA
00BCD9  1                       LDA $C010               ; Clear keyboard strobe
00BCD9  1                       PLA
00BCD9  1                       RTS
00BCD9  1               .elseif .defined(OSI)
00BCD9  1                       JMP $FD00               ; Call OSI keyboard input routine
00BCD9  1               ;       JMP $FE80               ; Call OSI serial input routine
00BCD9  1               .elseif .defined(KIM1)
00BCD9  1  AD 42 17             LDA SBD                 ; Get the RIOT register
00BCDC  1  29 FE                AND #$FE                 ; Mask out low bit
00BCDE  1  8D 42 17             STA SBD                 ; And store it
00BCE1  1  98                   TYA                     ; Save Y on stack
00BCE2  1  48                   PHA
00BCE3  1  20 5A 1E             JSR $1E5A               ; Call KIM GETCH routine. Returns char in A. Changes Y.
00BCE6  1  85 3C                STA T3                  ; Save A
00BCE8  1  AD 42 17             LDA SBD                 ; Get the RIOT register
00BCEB  1  09 01                ORA #1                  ; Mask in low bit
00BCED  1  8D 42 17             STA SBD                 ; And store it
00BCF0  1  68                   PLA                     ; Restore Y from stack
00BCF1  1  A8                   TAY
00BCF2  1  A5 3C                LDA T3                  ; Restore A
00BCF4  1  60                   RTS
00BCF5  1               .elseif .defined(SBC)
00BCF5  1               WaitForKeypress:
00BCF5  1                       JSR MONRDKEY
00BCF5  1                       BCC WaitForKeypress
00BCF5  1                       RTS
00BCF5  1               .endif
00BCF5  1               
00BCF5  1               ; Gets a hex digit (0-9,A-F). Echoes character as typed.
00BCF5  1               ; ESC key cancels command and goes back to command loop.
00BCF5  1               ; If RETOK is zero, ignore Return key.
00BCF5  1               ; If RETOK is non-zero, pressing Return will cause it to return with A=0 and carry set.
00BCF5  1               ; If CHAROK is non-zero, pressing a single quote allows entering a character.
00BCF5  1               ; Ignores invalid characters. Returns binary value in A
00BCF5  1               ; Registers changed: A
00BCF5  1               GetHex:
00BCF5  1  20 D9 BC             JSR GetKey
00BCF8  1  C9 1B                CMP #ESC                ; ESC key?
00BCFA  1  D0 0D                BNE @checkRet
00BCFC  1  20 13 BE             JSR PrintCR
00BCFF  1  68                   PLA                     ; pop return address on stack
00BD00  1  68                   PLA
00BD01  1  A9 00                LDA #0
00BD03  1  8D A2 17             STA CHAROK              ; Clear flag to accept character input
00BD06  1  4C 2F B4             JMP MainLoop            ; Abort command
00BD09  1               @checkRet:
00BD09  1  C9 0D                CMP #CR                 ; Return key?
00BD0B  1  D0 09                BNE @next
00BD0D  1  AD 80 17             LDA RETOK               ; Flag set to check for return?
00BD10  1  F0 E3                BEQ GetHex              ; If not, ignore Return key
00BD12  1  A9 00                LDA #0
00BD14  1  38                   SEC                     ; Carry set indicates Return pressed
00BD15  1  60                   RTS
00BD16  1               @next:
00BD16  1  C9 27                CMP #'''                ; Single quote for character input?
00BD18  1  D0 25                BNE @next1
00BD1A  1  AD A2 17             LDA CHAROK              ; Are we accepting character input?
00BD1D  1  F0 D6                BEQ GetHex              ; If not, ignore character
00BD1F  1               .ifdef ECHO
00BD1F  1  A9 27                LDA #'''                ; Echo a quote
00BD21  1  20 8E BE             JSR PrintChar
00BD24  1               .endif
00BD24  1  A9 01                LDA #1                  ; Set flag that we are in character input mode
00BD26  1  8D A3 17             STA CHARMODE
00BD29  1  20 D9 BC             JSR GetKey              ; Get a character
00BD2C  1               
00BD2C  1  2C A5 17             BIT OHIGHASCII          ; If OHIGHASCII option is on, set high bit of character
00BD2F  1  10 02                BPL @NoConv
00BD31  1  09 80                ORA #%10000000
00BD33  1               @NoConv:
00BD33  1               .ifdef ECHO
00BD33  1  20 8E BE             JSR PrintChar           ; Echo it
00BD36  1               .endif
00BD36  1               .ifdef ECHO
00BD36  1  48                   PHA                     ; Save the character
00BD37  1  A9 27                LDA #'''                ; Echo a quote
00BD39  1  20 8E BE             JSR PrintChar
00BD3C  1  68                   PLA                     ; Restore the character
00BD3D  1               .endif
00BD3D  1  18                   CLC                     ; Normal return
00BD3E  1  60                   RTS
00BD3F  1               @next1:
00BD3F  1  20 E3 C0             JSR ToUpper
00BD42  1  C9 30                CMP #'0'
00BD44  1  30 AF                BMI GetHex              ; Invalid, ignore and try again
00BD46  1  C9 3A                CMP #'9'+1
00BD48  1  30 0B                BMI @Digit
00BD4A  1  C9 41                CMP #'A'
00BD4C  1  30 A7                BMI GetHex              ; Invalid, ignore and try again
00BD4E  1  C9 47                CMP #'F'+1
00BD50  1  30 0B                BMI @Letter
00BD52  1  4C F5 BC             JMP GetHex              ; Invalid, ignore and try again
00BD55  1               @Digit:
00BD55  1               .ifdef ECHO
00BD55  1  20 8E BE             JSR PrintChar           ; echo
00BD58  1               .endif
00BD58  1  38                   SEC
00BD59  1  E9 30                SBC #'0'                ; convert to value
00BD5B  1  18                   CLC
00BD5C  1  60                   RTS
00BD5D  1               @Letter:
00BD5D  1               .ifdef ECHO
00BD5D  1  20 8E BE             JSR PrintChar           ; echo
00BD60  1               .endif
00BD60  1  38                   SEC
00BD61  1  E9 37                SBC #'A'-10             ; convert to value
00BD63  1  18                   CLC
00BD64  1  60                   RTS
00BD65  1               
00BD65  1               ; Get Byte as 2 chars 0-9,A-F
00BD65  1               ; Echoes characters as typed.
00BD65  1               ; Ignores invalid characters
00BD65  1               ; Returns byte in A
00BD65  1               ; If RETOK is zero, ignore Return key.
00BD65  1               ; If RETOK is non-zero, pressing Return as first character will cause it to return with A=0 and carry set.
00BD65  1               ; If CHAROK is non-zero, pressing a single quote allows entering a character.
00BD65  1               ; Registers changed: A
00BD65  1               GetByte:
00BD65  1  20 F5 BC             JSR GetHex
00BD68  1  90 01                BCC @NotRet
00BD6A  1  60                   RTS                     ; <Return> was pressed, so return
00BD6B  1               @NotRet:
00BD6B  1  48                   PHA                     ; Save character
00BD6C  1  AD A3 17             LDA CHARMODE            ; Are we in character input mode?
00BD6F  1  F0 08                BEQ @Normal
00BD71  1  A9 00                LDA #0                  ; If so, we got our byte as a character. Clear charmode.
00BD73  1  8D A3 17             STA CHARMODE
00BD76  1  18                   CLC
00BD77  1  68                   PLA                     ; Restore character
00BD78  1  60                   RTS                     ; Normal return
00BD79  1               @Normal:
00BD79  1  68                   PLA
00BD7A  1  0A                   ASL
00BD7B  1  0A                   ASL
00BD7C  1  0A                   ASL
00BD7D  1  0A                   ASL
00BD7E  1  85 30                STA T1                  ; Store first nybble
00BD80  1  AD A2 17             LDA CHAROK              ; Get value of CHAROK
00BD83  1  85 31                STA T2                  ; Save it
00BD85  1  A9 00                LDA #0
00BD87  1  8D A2 17             STA CHAROK              ; Disable char input for second nybble of a byte
00BD8A  1               @IgnoreRet:
00BD8A  1  20 F5 BC             JSR GetHex
00BD8D  1  B0 FB                BCS @IgnoreRet          ; If <Return> pressed, ignore it and try again
00BD8F  1  18                   CLC
00BD90  1  65 30                ADC T1                  ; Add second nybble
00BD92  1  85 30                STA T1                  ; Save it
00BD94  1  A5 31                LDA T2                  ; Restore value of CHAROK
00BD96  1  8D A2 17             STA CHAROK
00BD99  1  A5 30                LDA T1                  ; Get value to return
00BD9B  1  18                   CLC                     ; Fix exit on 00
00BD9C  1  60                   RTS
00BD9D  1               
00BD9D  1               ; Get Address as 4 chars 0-9,A-F
00BD9D  1               ; Echoes characters as typed.
00BD9D  1               ; Ignores invalid characters
00BD9D  1               ; Returns address in X (low), Y (high)
00BD9D  1               ; Registers changed: X, Y
00BD9D  1               GetAddress:
00BD9D  1  48                   PHA                     ; Save A
00BD9E  1  20 65 BD             JSR GetByte             ; Get the first (most significant) hex byte
00BDA1  1  B0 0A                BCS @RetPressed         ; Quit if Return pressed
00BDA3  1  A8                   TAY                     ; Save in Y
00BDA4  1  A9 00                LDA #0
00BDA6  1  8D 80 17             STA RETOK               ; One byte already entered so can't hit return now for default.
00BDA9  1  20 65 BD             JSR GetByte             ; Get the second (least significant) hex byte
00BDAC  1  AA                   TAX                     ; Save in X
00BDAD  1               @RetPressed:
00BDAD  1  68                   PLA                     ; Restore A
00BDAE  1  60                   RTS
00BDAF  1               
00BDAF  1               ; Print 16-bit address in hex
00BDAF  1               ; Pass byte in X (low) and Y (high)
00BDAF  1               ; Registers changed: None
00BDAF  1               PrintAddress:
00BDAF  1  48                   PHA                     ; Save A
00BDB0  1  98                   TYA                     ; Get low byte
00BDB1  1  20 7B BE             JSR PRBYTE              ; Print it
00BDB4  1  8A                   TXA                     ; Get high byte
00BDB5  1  20 7B BE             JSR PRBYTE              ; Print it
00BDB8  1  68                   PLA                     ; Restore A
00BDB9  1  60                   RTS
00BDBA  1               
00BDBA  1               ; Print byte in BCD with leading zero suppression
00BDBA  1               ; Pass byte in A
00BDBA  1               ; Registers changed: None
00BDBA  1               ; Call first time with LZ cleared
00BDBA  1               PrintByteLZ:
00BDBA  1               ; Check for special case: number is $00, LZ is 0, LAST is 1
00BDBA  1               ; Last 0 should not be suppressed since it is the final one in $0000
00BDBA  1  C9 00                CMP #$00
00BDBC  1  D0 13                BNE @normal
00BDBE  1  48                   PHA
00BDBF  1  AD 86 17             LDA LZ
00BDC2  1  D0 0C                BNE @pull
00BDC4  1  AD 87 17             LDA LAST
00BDC7  1  F0 07                BEQ @pull
00BDC9  1  A9 30                LDA #'0'
00BDCB  1  20 8E BE             JSR PrintChar
00BDCE  1  68                   PLA
00BDCF  1  60                   RTS
00BDD0  1  68           @pull: PLA
00BDD1  1               @normal:
00BDD1  1  48                   PHA                     ; save for lower nybble
00BDD2  1  29 F0                AND #$F0                ; mask out upper nybble
00BDD4  1  4A                   LSR                     ; shift into lower nybble
00BDD5  1  4A                   LSR
00BDD6  1  4A                   LSR
00BDD7  1  4A                   LSR
00BDD8  1  18                   CLC
00BDD9  1  69 30                ADC #'0'
00BDDB  1  20 E7 BD             JSR PrintCharLZ
00BDDE  1  68                   PLA                     ; restore value
00BDDF  1  29 0F                AND #$0F                ; mask out lower nybble
00BDE1  1  18                   CLC
00BDE2  1  69 30                ADC #'0'
00BDE4  1  4C E7 BD             JMP PrintCharLZ
00BDE7  1               
00BDE7  1               ; Print character but suppress 0 if LZ it not set.
00BDE7  1               ; Sets LZ when non-zero printed.
00BDE7  1               ; Pass char in A
00BDE7  1               PrintCharLZ:
00BDE7  1  C9 30                CMP #'0'                ; is it 0?
00BDE9  1  D0 0C                BNE @notzero            ; if not, print it normally
00BDEB  1  48                   PHA
00BDEC  1  AD 86 17             LDA LZ                  ; is LZ zero?
00BDEF  1  D0 02                BNE @print
00BDF1  1  68                   PLA
00BDF2  1  60                   RTS                     ; suppress leading zero
00BDF3  1  68           @print: PLA
00BDF4  1  4C 8E BE             JMP PrintChar
00BDF7  1               
00BDF7  1               @notzero:
00BDF7  1  20 8E BE             JSR PrintChar           ; print it
00BDFA  1  A9 01                LDA #1                  ; set LZ to 1
00BDFC  1  8D 86 17             STA LZ
00BDFF  1  60                   RTS
00BE00  1               
00BE00  1               ; Print byte as ASCII character or "."
00BE00  1               ; Pass character in A.
00BE00  1               ; Registers changed: None
00BE00  1               PrintAscii:
00BE00  1  C9 20                CMP #$20                ; first printable character (space)
00BE02  1  30 07                BMI NotAscii
00BE04  1  C9 7F                CMP #$7E+1              ; last printable character (~)
00BE06  1  10 03                BPL NotAscii
00BE08  1  4C 8E BE             JMP PrintChar
00BE0B  1               
00BE0B  1               NotAscii:
00BE0B  1  48                   PHA                     ; save A
00BE0C  1  A9 2E                LDA #'.'
00BE0E  1  20 8E BE             JSR PrintChar
00BE11  1  68                   PLA                     ; restore A
00BE12  1  60                   RTS
00BE13  1               
00BE13  1               ; Print a carriage return
00BE13  1               ; Registers changed: None
00BE13  1               PrintCR:
00BE13  1  48                   PHA
00BE14  1  A9 0D                LDA #CR
00BE16  1  20 8E BE             JSR PrintChar
00BE19  1  A9 0A                LDA #LF
00BE1B  1  20 8E BE             JSR PrintChar
00BE1E  1  68                   PLA
00BE1F  1  60                   RTS
00BE20  1               
00BE20  1               ; Print a space
00BE20  1               ; Registers changed: None
00BE20  1               PrintSpace:
00BE20  1  48                   PHA
00BE21  1  A9 20                LDA #SP
00BE23  1  20 8E BE             JSR PrintChar
00BE26  1  68                   PLA
00BE27  1  60                   RTS
00BE28  1               
00BE28  1               ; Print a string
00BE28  1               ; Pass address of string in X (low) and Y (high).
00BE28  1               ; String must be terminated in a null (zero).
00BE28  1               ; Registers changed: None
00BE28  1               ;
00BE28  1               PrintString:
00BE28  1  48                   PHA             ; Save A
00BE29  1  98                   TYA
00BE2A  1  48                   PHA             ; Save Y
00BE2B  1  86 30                STX T1          ; Save in page zero so we can use indirect addressing
00BE2D  1  84 31                STY T1+1
00BE2F  1  A0 00                LDY #0          ; Set offset to zero
00BE31  1  B1 30        @loop:  LDA (T1),Y      ; Read a character
00BE33  1  F0 11                BEQ done        ; Done if we get a null (zero)
00BE35  1  20 8E BE             JSR PrintChar   ; Print it
00BE38  1  18                   CLC             ; Increment address
00BE39  1  A5 30                LDA T1          ; Low byte
00BE3B  1  69 01                ADC #1
00BE3D  1  85 30                STA T1
00BE3F  1  90 02                BCC @nocarry
00BE41  1  E6 31                INC T1+1        ; High byte
00BE43  1               @nocarry:
00BE43  1  4C 31 BE             JMP @loop       ; Go back and print next character
00BE46  1               done:
00BE46  1  68                   PLA
00BE47  1  A8                   TAY             ; Restore Y
00BE48  1  68                   PLA             ; Restore A
00BE49  1  60                   RTS
00BE4A  1               
00BE4A  1               ; Embedded string printer. Unpops the stack to find the embedded
00BE4A  1               ; string. It outputs one character at a time until a $00 marker is
00BE4A  1               ; found. Then it jumps back to the calling program just beyond the
00BE4A  1               ; string. Based on code from "Assembly Cookbook for the Apple II/IIe
00BE4A  1               ; by Don Lancaster.
00BE4A  1               
00BE4A  1               Imprint:
00BE4A  1  8E B7 17             STX XSAV2       ; Save registers
00BE4D  1  8C B8 17             STY YSAV2
00BE50  1  8D B9 17             STA ASAV2
00BE53  1  68                   PLA             ; Get pointer low and save
00BE54  1  85 3D                STA T4
00BE56  1  68                   PLA             ; Get pointer high and save
00BE57  1  85 3E                STA T4+1
00BE59  1  A0 00                LDY #$00        ; No indexing
00BE5B  1               NXTCHR2:
00BE5B  1  E6 3D                INC T4          ; Get next high address
00BE5D  1  D0 02                BNE NOC2        ; Skip if no carry
00BE5F  1  E6 3E                INC T4+1        ; Increment high address
00BE61  1  B1 3D        NOC2:   LDA (T4),Y      ; Get character
00BE63  1  F0 06                BEQ END2        ; If zero marker
00BE65  1  20 8E BE             JSR PrintChar   ; Print character
00BE68  1  4C 5B BE             JMP NXTCHR2     ; Branch back
00BE6B  1  A5 3E        END2:   LDA T4+1        ; Restore PC low
00BE6D  1  48                   PHA
00BE6E  1  A5 3D                LDA T4          ; Restore PC high
00BE70  1  48                   PHA
00BE71  1  AE B7 17             LDX XSAV2
00BE74  1  AC B8 17             LDY YSAV2       ; Restore registers
00BE77  1  AD B9 17             LDA ASAV2
00BE7A  1  60                   RTS             ; And exit
00BE7B  1               
00BE7B  1               ; Print byte as two hex chars.
00BE7B  1               ; Taken from Woz Monitor PRBYTE routine ($FFDC).
00BE7B  1               ; Pass byte in A
00BE7B  1               ; Registers changed: A
00BE7B  1               PrintByte:
00BE7B  1               PRBYTE:
00BE7B  1  48                   PHA             ; Save A for LSD.
00BE7C  1  4A                   LSR
00BE7D  1  4A                   LSR
00BE7E  1  4A                   LSR             ; MSD to LSD position.
00BE7F  1  4A                   LSR
00BE80  1  20 84 BE             JSR PRHEX       ; Output hex digit.
00BE83  1  68                   PLA             ; Restore A.
00BE84  1                                       ; Falls through into PRHEX routine
00BE84  1               
00BE84  1               ; Print nybble as one hex digit.
00BE84  1               ; Take from Woz Monitor PRHEX routine ($FFE5).
00BE84  1               ; Pass byte in A
00BE84  1               ; Registers changed: A
00BE84  1               PRHEX:
00BE84  1  29 0F                AND #$0F        ; Mask LSD for hex print.
00BE86  1               .if .defined(APPLE1) .or .defined(APPLE2)
00BE86  1                       ORA #'0'+$80    ; Add "0".
00BE86  1                       CMP #$BA        ; Digit?
00BE86  1               .else
00BE86  1  09 30                ORA #'0'        ; Add "0".
00BE88  1  C9 3A                CMP #$3A        ; Digit?
00BE8A  1               .endif
00BE8A  1  90 02                BCC PrintChar   ; Yes, output it.
00BE8C  1  69 06                ADC #$06        ; Add offset for letter.
00BE8E  1                                       ; Falls through into PrintChar routine
00BE8E  1               
00BE8E  1               ; Output a character
00BE8E  1               ; Pass byte in A
00BE8E  1               ; Registers changed: none
00BE8E  1               PrintChar:
00BE8E  1               .if .defined(APPLE1)
00BE8E  1                                       ; Based on Woz Monitor ECHO routine ($FFEF).
00BE8E  1                       PHP             ; Save status
00BE8E  1                       PHA             ; Save A as it may be changed
00BE8E  1               @Loop:
00BE8E  1                       BIT DSP         ; bit (B7) cleared yet?
00BE8E  1                       BMI @Loop       ; No, wait for display.
00BE8E  1               
00BE8E  1               ; If option is set, convert lower case character to upper case
00BE8E  1               
00BE8E  1                       BIT OUPPER      ; Check value of option
00BE8E  1                       BPL @NotLower   ; Skip conversion if not set
00BE8E  1                       JSR ToUpper
00BE8E  1               @NotLower:
00BE8E  1                       STA DSP         ; Output character. Sets DA.
00BE8E  1                       PLA             ; Restore A
00BE8E  1                       PLP             ; Restore status
00BE8E  1                       RTS             ; Return.
00BE8E  1               
00BE8E  1               .elseif .defined(APPLE2)
00BE8E  1                       PHP             ; Save status
00BE8E  1                       PHA             ; Save A as it may be changed
00BE8E  1                       ORA #%10000000  ; Make sure high bit is set
00BE8E  1                       JSR $FDF0       ; Apple II COUT1
00BE8E  1                       PLA             ; Restore A
00BE8E  1                       PLP             ; Restore status
00BE8E  1                       RTS             ; Return
00BE8E  1               
00BE8E  1               .elseif .defined(OSI)
00BE8E  1                       PHP             ; Save status
00BE8E  1                       PHA             ; Save A as it may be changed
00BE8E  1                       JSR $BF2D       ; Call OSI screen character out routine
00BE8E  1               ;       JSR $FCB1       ; Call OSI serial character out routine
00BE8E  1                       CMP #CR         ; Is it Return?
00BE8E  1                       BNE @ret        ; If not, return
00BE8E  1                       LDA #LF
00BE8E  1                       JSR $BF2D       ; Else print Linefeed too (screen)
00BE8E  1               ;       JSR $FCB1       ; Else print Linefeed too (serial)
00BE8E  1               @ret:
00BE8E  1                       PLA             ; Restore A
00BE8E  1                       PLP             ; Restore status
00BE8E  1                       RTS             ; Return.
00BE8E  1               
00BE8E  1               .elseif .defined(KIM1)
00BE8E  1               
00BE8E  1  08                   PHP             ; Save status
00BE8F  1  85 3C                STA     T3      ; Save A
00BE91  1  98                   TYA             ; Save Y
00BE92  1  48                   PHA
00BE93  1  A5 3C                LDA     T3      ; Get A back
00BE95  1  20 A0 1E             JSR     $1EA0   ; Call monitor OUTCH character out routine. Changes A and Y.
00BE98  1  68                   PLA             ; Restore Y
00BE99  1  A8                   TAY
00BE9A  1  A5 3C                LDA     T3      ; Restore A
00BE9C  1  28                   PLP             ; Restore status
00BE9D  1  60                   RTS             ; Return.
00BE9E  1               
00BE9E  1               .elseif .defined(SBC)
00BE9E  1               
00BE9E  1                       PHP             ; Save status
00BE9E  1                       PHA             ; Save A as it may be changed
00BE9E  1                       JSR MONCOUT
00BE9E  1                       CMP #CR         ; Is it Return?
00BE9E  1                       BNE @ret1       ; If not, return
00BE9E  1                       LDA #LF
00BE9E  1                       JSR MONCOUT     ; Else print linefeed too
00BE9E  1               @ret1:
00BE9E  1                       PLA             ; Restore A
00BE9E  1                       PLP             ; Restore status
00BE9E  1                       RTS             ; Return.
00BE9E  1               
00BE9E  1               .endif
00BE9E  1               
00BE9E  1               ; Print a dollar sign
00BE9E  1               ; Registers changed: None
00BE9E  1               PrintDollar:
00BE9E  1  48                   PHA
00BE9F  1  A9 24                LDA #'$'
00BEA1  1  20 8E BE             JSR PrintChar
00BEA4  1  68                   PLA
00BEA5  1  60                   RTS
00BEA6  1               
00BEA6  1               ; Print ",X"
00BEA6  1               ; Registers changed: None
00BEA6  1               PrintCommaX:
00BEA6  1  48                   PHA
00BEA7  1  A9 2C                LDA #','
00BEA9  1  20 8E BE             JSR PrintChar
00BEAC  1  A9 58                LDA #'X'
00BEAE  1  20 8E BE             JSR PrintChar
00BEB1  1  68                   PLA
00BEB2  1  60                   RTS
00BEB3  1               
00BEB3  1               ; Print ",Y"
00BEB3  1               ; Registers changed: None
00BEB3  1               PrintCommaY:
00BEB3  1  48                   PHA
00BEB4  1  A9 2C                LDA #','
00BEB6  1  20 8E BE             JSR PrintChar
00BEB9  1  A9 59                LDA #'Y'
00BEBB  1  20 8E BE             JSR PrintChar
00BEBE  1  68                   PLA
00BEBF  1  60                   RTS
00BEC0  1               
00BEC0  1               ; Print ",S"
00BEC0  1               ; Registers changed: None
00BEC0  1               PrintCommaS:
00BEC0  1  48                   PHA
00BEC1  1  A9 2C                LDA #','
00BEC3  1  20 8E BE             JSR PrintChar
00BEC6  1  A9 53                LDA #'S'
00BEC8  1  20 8E BE             JSR PrintChar
00BECB  1  68                   PLA
00BECC  1  60                   RTS
00BECD  1               
00BECD  1               ; Print "($"
00BECD  1               ; Registers changed: None
00BECD  1               PrintLParenDollar:
00BECD  1  48                   PHA
00BECE  1  A9 28                LDA #'('
00BED0  1  20 8E BE             JSR PrintChar
00BED3  1  A9 24                LDA #'$'
00BED5  1  20 8E BE             JSR PrintChar
00BED8  1  68                   PLA
00BED9  1  60                   RTS
00BEDA  1               
00BEDA  1               ; Print "[$"
00BEDA  1               ; Registers changed: None
00BEDA  1               PrintLBraceDollar:
00BEDA  1  48                   PHA
00BEDB  1  A9 5B                LDA #'['
00BEDD  1  20 8E BE             JSR PrintChar
00BEE0  1  A9 24                LDA #'$'
00BEE2  1  20 8E BE             JSR PrintChar
00BEE5  1  68                   PLA
00BEE6  1  60                   RTS
00BEE7  1               
00BEE7  1               ; Print a right parenthesis
00BEE7  1               ; Registers changed: None
00BEE7  1               PrintRParen:
00BEE7  1  48                   PHA
00BEE8  1  A9 29                LDA #')'
00BEEA  1  20 8E BE             JSR PrintChar
00BEED  1  68                   PLA
00BEEE  1  60                   RTS
00BEEF  1               
00BEEF  1               ; Print a right brace
00BEEF  1               ; Registers changed: None
00BEEF  1               PrintRBrace:
00BEEF  1  48                   PHA
00BEF0  1  A9 5D                LDA #']'
00BEF2  1  20 8E BE             JSR PrintChar
00BEF5  1  68                   PLA
00BEF6  1  60                   RTS
00BEF7  1               
00BEF7  1               ; Print several space characters.
00BEF7  1               ; X contains number of spaces to print.
00BEF7  1               ; Registers changed: X
00BEF7  1               PrintSpaces:
00BEF7  1  48                   PHA                     ; save A
00BEF8  1  A9 20                LDA #' '
00BEFA  1  20 FF BE             JSR PrintChars
00BEFD  1  68                   PLA                     ; restore A
00BEFE  1  60                   RTS
00BEFF  1               
00BEFF  1               ; Output a character multiple times
00BEFF  1               ; A contains character to print.
00BEFF  1               ; X contains number of times to print.
00BEFF  1               ; Registers changed: X
00BEFF  1               PrintChars:
00BEFF  1  20 8E BE             JSR PrintChar
00BF02  1  CA                   DEX
00BF03  1  D0 FA                BNE PrintChars
00BF05  1  60                   RTS
00BF06  1               
00BF06  1               ; Ask user whether to continue or not. Returns with carry clear if
00BF06  1               ; user selected <space> to continue, carry set if user selected <ESC>
00BF06  1               ; to stop.
00BF06  1               ;
00BF06  1               ; Prints CR to go back to start of line
00BF06  1               ;
00BF06  1               ; Registers changed: none
00BF06  1               
00BF06  1               PromptToContinue:
00BF06  1  48                   PHA                     ; save registers
00BF07  1  8A                   TXA
00BF08  1  48                   PHA
00BF09  1  98                   TYA
00BF0A  1  48                   PHA
00BF0B  1  20 4A BE             JSR Imprint
00BF0E  1  20 20 3C 53          .asciiz "  <Space> to continue or <ESC> to stop"
00BF12  1  70 61 63 65  
00BF16  1  3E 20 74 6F  
00BF35  1               @SpaceOrEscape:
00BF35  1  20 D9 BC             JSR GetKey
00BF38  1  C9 20                CMP #' '
00BF3A  1  F0 07                BEQ @Cont
00BF3C  1  C9 1B                CMP #ESC
00BF3E  1  D0 F5                BNE @SpaceOrEscape
00BF40  1  38                   SEC                     ; carry set indicates ESC pressed
00BF41  1  B0 33                BCS @Ret
00BF43  1               @Cont:
00BF43  1               ;        LDA #CR
00BF43  1  20 4A BE             JSR Imprint
00BF46  1  0D 20 20 20          .byte CR,"                                      ",CR,0
00BF4A  1  20 20 20 20  
00BF4E  1  20 20 20 20  
00BF6F  1               ;        JSR PrintChar
00BF6F  1  18                   CLC
00BF70  1  68                   PLA                     ; restore registers
00BF71  1  A8                   TAY
00BF72  1  68                   PLA
00BF73  1  AA                   TAX
00BF74  1  68                   PLA
00BF75  1  60                   RTS
00BF76  1               
00BF76  1               @Ret:
00BF76  1  20 13 BE             JSR PrintCR
00BF79  1  68                   PLA                     ; restore registers
00BF7A  1  A8                   TAY
00BF7B  1  68                   PLA
00BF7C  1  AA                   TAX
00BF7D  1  68                   PLA
00BF7E  1  60                   RTS
00BF7F  1               
00BF7F  1               ; Delay. Calls routine WAIT using delay constant in OWDELAY.
00BF7F  1               ;DELAY:
00BF7F  1               ;        LDA OWDELAY
00BF7F  1               ;        BEQ NODELAY
00BF7F  1               ;        JMP WAIT
00BF7F  1               ;NODELAY:
00BF7F  1               ;        RTS
00BF7F  1               
00BF7F  1               ; Check if start address in SH/SL is less than or equal to end address
00BF7F  1               ; in EH/EL. If so, return with carry clear. If not, print error
00BF7F  1               ; message and return with carry set.
00BF7F  1               RequireStartNotAfterEnd:
00BF7F  1               ; Check that start address <= end address
00BF7F  1  A5 33                LDA SH
00BF81  1  C5 35                CMP EH
00BF83  1  90 39                BCC @rangeOkay
00BF85  1  D0 08                BNE @rangeInvalid
00BF87  1  A5 32                LDA SL
00BF89  1  C5 34                CMP EL
00BF8B  1  90 31                BCC @rangeOkay
00BF8D  1  F0 2F                BEQ @rangeOkay
00BF8F  1               @rangeInvalid:
00BF8F  1  20 4A BE             JSR Imprint
00BF92  1  45 72 72 6F          .byte "Error: Range's START must be before END", CR, LF, 0
00BF96  1  72 3A 20 52  
00BF9A  1  61 6E 67 65  
00BFBC  1  38                   SEC
00BFBD  1  60                   RTS
00BFBE  1               @rangeOkay:
00BFBE  1  18                   CLC
00BFBF  1  60                   RTS
00BFC0  1               
00BFC0  1               ; Option picker. Adapted from "Assembly Cookbook for the Apple II/IIe" by Don Lancaster.
00BFC0  1               ; Call with command letter in A.
00BFC0  1               ; Registers affected: X
00BFC0  1               OPICK:
00BFC0  1  A8                   TAY                     ; save A
00BFC1  1               ; Convert to upper case so that lowercase commands are accepted
00BFC1  1  20 E3 C0             JSR ToUpper
00BFC4  1  A2 10                LDX #MATCHN             ; Get legal number of matches
00BFC6  1  DD DC BF     SCAN:   CMP MATCHFL,X           ; Search for a match
00BFC9  1  F0 03                BEQ GOTMCH              ; Found
00BFCB  1  CA                   DEX                     ; Try next
00BFCC  1  10 F8                BPL SCAN
00BFCE  1               
00BFCE  1  E8           GOTMCH: INX                     ; Makes zero a miss
00BFCF  1  8A                   TXA                     ; Get jump vector
00BFD0  1  0A                   ASL A                   ; Double pointer
00BFD1  1  AA                   TAX
00BFD2  1  BD EE BF             LDA JMPFL+1,X           ; Get page address first!
00BFD5  1  48                   PHA                     ; and force on stack
00BFD6  1  BD ED BF             LDA JMPFL,X             ; Get position address
00BFD9  1  48                   PHA                     ; and force on stack
00BFDA  1  98                   TYA                     ; restore A
00BFDB  1  60                   RTS                     ; Jump via forced subroutine return
00BFDC  1               
00BFDC  1               ; Matchn holds the number of matches less one.
00BFDC  1               ; Matchfl holds the legal characters.
00BFDC  1               ; JMPFL holds the jump vectors (minus 1).
00BFDC  1               
00BFDC  1                       MATCHN = JMPFL-MATCHFL-1
00BFDC  1               
00BFDC  1               MATCHFL:
00BFDC  1               .if .defined(APPLE1)
00BFDC  1                       .byte "$?"
00BFDC  1               .ifdef MINIASM
00BFDC  1                       .byte "A"
00BFDC  1               .endif
00BFDC  1                       .byte "BCDEFGHIJKMNORSUVW:=."
00BFDC  1               .elseif .defined(APPLE2)
00BFDC  1                       .byte "$?"
00BFDC  1               .ifdef MINIASM
00BFDC  1                       .byte "A"
00BFDC  1               .endif
00BFDC  1                       .byte "BCDFGHIJKNORSUVW:=."
00BFDC  1               .elseif .defined(OSI)
00BFDC  1                       .byte "$?"
00BFDC  1               .ifdef MINIASM
00BFDC  1                       .byte "A"
00BFDC  1               .endif
00BFDC  1                       .byte "BCDFGHIJKNORSUVW:=."
00BFDC  1               .elseif .defined(KIM1)
00BFDC  1  24 3F                .byte "$?"
00BFDE  1               .ifdef MINIASM
00BFDE  1  41                   .byte "A"
00BFDF  1               .endif
00BFDF  1  42 43 44 46          .byte "BCDFGHLKNRSUW."
00BFE3  1  47 48 4C 4B  
00BFE7  1  4E 52 53 55  
00BFED  1               .elseif .defined(SBC)
00BFED  1                       .byte "$?"
00BFED  1               .ifdef MINIASM
00BFED  1                       .byte "A"
00BFED  1               .endif
00BFED  1                       .byte "BCDFGHIJKNORSUVW:=."
00BFED  1               .endif
00BFED  1               
00BFED  1               JMPFL:
00BFED  1  4A B4                .word Invalid-1
00BFEF  1  8A B4                .word Monitor-1
00BFF1  1  76 B4                .word Help-1
00BFF3  1               .ifdef MINIASM
00BFF3  1  8D B4                 .word Assemble-1
00BFF5  1               .endif
00BFF5  1  A0 B4                .word Breakpoint-1
00BFF7  1  25 B5                .word Copy-1
00BFF9  1  70 B6                .word Dump-1
00BFFB  1               .ifdef APPLE1
00BFFB  1                       .word ACIFW-1
00BFFB  1               .endif
00BFFB  1  BD B6                .word Fill-1
00BFFD  1  D9 B4                .word Go-1
00BFFF  1  B8 BB                .word Writer-1
00C001  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(OSI) .or .defined(SBC)
00C001  1                       .word Basic-1
00C001  1               .endif
00C001  1  C9 BA                .word Load-1
00C003  1  72 BA                .word Checksum-1
00C005  1               .ifdef APPLE1
00C005  1                       .word CFFA1-1
00C005  1               .endif
00C005  1  95 D3                .word Info-1
00C007  1               ;        .word Options-1
00C007  1  1A B9                .word Registers-1
00C009  1  C1 B5                .word Search-1
00C00B  1               ;       .word Test-1
00C00B  1  9B B6                .word Unassemble-1
00C00D  1               ;        .word Verify-1
00C00D  1  D7 B8                .word Memory-1
00C00F  1               ;        .word Math-1
00C00F  1  5D D1                .word Trace-1
00C011  1               
00C011  1               ; String input routine.
00C011  1               ; Enter characters from the keyboard terminated in <Return> or <ESC>.
00C011  1               ; Characters are echoed.
00C011  1               ; Can be up to 127 characters.
00C011  1               ; Returns:
00C011  1               ;   Length stored at IN (doesn't include zero byte).
00C011  1               ;   Characters stored starting at IN+1
00C011  1               ;   String is terminated in a 0 byte.
00C011  1               ;   Carry set if user hit <Esc>, clear if used <Enter> or max string length reached.
00C011  1               ; Registers changed: A, X
00C011  1               
00C011  1               ; List of characters to accept. First byte is the length of the list.
00C011  1               FilterChars:
00C011  1  1E 30 31 32          .byte 30, "0123456789ABCDEFabcdef#(),XYxy"
00C015  1  33 34 35 36  
00C019  1  37 38 39 41  
00C030  1               
00C030  1               GetLine:
00C030  1  A2 00                LDX #0                  ; Initialize index into buffer
00C032  1               loop:
00C032  1  20 D9 BC             JSR GetKey              ; Get character from keyboard
00C035  1  C9 0D                CMP #CR                 ; <Enter> key pressed?
00C037  1  F0 1E                BEQ EnterPressed        ; If so, handle it
00C039  1  C9 1B                CMP #ESC                ; <Esc> key pressed?
00C03B  1  F0 1B                BEQ EscapePressed       ; If so, handle it
00C03D  1               
00C03D  1               ; Make sure character is included in the set of filter characters,
00C03D  1               ; otherwise ignore it.
00C03D  1               
00C03D  1  AC 11 C0             LDY FilterChars         ; Get length of filter chars list
00C040  1               Filter:
00C040  1  D9 11 C0             CMP FilterChars,Y       ; Compare character from filter list with entered character
00C043  1  F0 05                BEQ CharOkay            ; If it matched, accept character
00C045  1  88                   DEY                     ; Move to next character in filter list
00C046  1  D0 F8                BNE Filter              ; Try next filter char until done
00C048  1  F0 E8                BEQ loop                ; End reached, ignore the character
00C04A  1               
00C04A  1               CharOkay:
00C04A  1               .ifdef ECHO
00C04A  1  20 8E BE             JSR PrintChar           ; Echo the key pressed
00C04D  1               .endif
00C04D  1  9D 01 02             STA IN+1,X              ; Store character in buffer (skip first length byte)
00C050  1  E8                   INX                     ; Advance index into buffer
00C051  1  E0 7E                CPX #$7E                ; Buffer full?
00C053  1  F0 02                BEQ EnterPressed        ; If so, return as if <Enter> was pressed
00C055  1  D0 DB                BNE loop                ; Always taken
00C057  1               EnterPressed:
00C057  1  18                   CLC                     ; Clear carry to indicate <Enter> pressed and fall through
00C058  1               EscapePressed:
00C058  1  A9 00                LDA #0
00C05A  1  9D 01 02             STA IN+1,X              ; Store 0 at end of buffer
00C05D  1  8E 00 02             STX IN                  ; Store length of string
00C060  1  60                   RTS                     ; Return
00C061  1               
00C061  1               ; Variable length hex number input routine.
00C061  1               ; Enter hex bytes from the keyboard terminated in <Return> or <ESC>.
00C061  1               ; Characters are echoed.
00C061  1               ; Can be up to 127 bytes.
00C061  1               ; Returns:
00C061  1               ;   Length stored at IN.
00C061  1               ;   Characters stored starting at IN+1
00C061  1               ; Registers changed: A, X
00C061  1               
00C061  1               GetHexBytes:
00C061  1  A9 01                LDA #1
00C063  1  8D 80 17             STA RETOK               ; Set flag to accept <Return> key
00C066  1  8D A2 17             STA CHAROK              ; Set flag to accept character input
00C069  1  A2 00                LDX #0                  ; Initialize index into buffer
00C06B  1               @loop:
00C06B  1  20 65 BD             JSR GetByte             ; get hex number from keyboard (byte)
00C06E  1  B0 0B                BCS @Return             ; Branch if key was <Return>
00C070  1  9D 01 02             STA IN+1,X              ; Store character in buffer (skip first length byte)
00C073  1  E8                   INX                     ; Advance index into buffer
00C074  1  20 20 BE             JSR PrintSpace          ; Space things out a bit W4JBM
00C077  1  E0 7E                CPX #$7E                ; Buffer full?
00C079  1  D0 F0                BNE @loop               ; If not, go back and get more input
00C07B  1               @Return:
00C07B  1  8E 00 02             STX IN                  ; Store length of string
00C07E  1  A9 00                LDA #0
00C080  1  8D 80 17             STA RETOK               ; Clear flag to accept <Return> key
00C083  1  8D A2 17             STA CHAROK              ; Clear flag to accept character input
00C086  1  60                   RTS                     ; Return
00C087  1               
00C087  1               ; Below came from
00C087  1               ; http://www.6502.org/source/integers/hex2dec-more.htm
00C087  1               ; Convert a 16 bit binary value to BCD
00C087  1               ;
00C087  1               ; This function converts a 16 bit binary value into a 24 bit BCD. It
00C087  1               ; works by transferring one bit a time from the source and adding it
00C087  1               ; into a BCD value that is being doubled on each iteration. As all the
00C087  1               ; arithmetic is being done in BCD the result is a binary to decimal
00C087  1               ; conversion. All conversions take 915 clock cycles.
00C087  1               ;
00C087  1               ; See BINBCD8 for more details of its operation.
00C087  1               ;
00C087  1               ; Andrew Jacobs, 28-Feb-2004
00C087  1  F8           BINBCD16:    SED                ; Switch to decimal mode
00C088  1  A9 00                LDA #0                  ; Ensure the result is clear
00C08A  1  8D 83 17             STA BCD+0
00C08D  1  8D 84 17             STA BCD+1
00C090  1  8D 85 17             STA BCD+2
00C093  1  A2 10                LDX #16                 ; The number of source bits
00C095  1  0E 81 17     CNVBIT: ASL BIN+0               ; Shift out one bit
00C098  1  2E 82 17             ROL BIN+1
00C09B  1  AD 83 17             LDA BCD+0               ; And add into result
00C09E  1  6D 83 17             ADC BCD+0
00C0A1  1  8D 83 17             STA BCD+0
00C0A4  1  AD 84 17             LDA BCD+1               ; propagating any carry
00C0A7  1  6D 84 17             ADC BCD+1
00C0AA  1  8D 84 17             STA BCD+1
00C0AD  1  AD 85 17             LDA BCD+2               ; ... thru whole result
00C0B0  1  6D 85 17             ADC BCD+2
00C0B3  1  8D 85 17             STA BCD+2
00C0B6  1  CA                   DEX                     ; And repeat for next bit
00C0B7  1  D0 DC                BNE CNVBIT
00C0B9  1  D8                   CLD                     ; Back to binary
00C0BA  1  60                   RTS                     ; All Done.
00C0BB  1               
00C0BB  1               ; Display processor flags
00C0BB  1               ; Based on code at http://6502org.wikidot.com/software-output-flags
00C0BB  1               
00C0BB  1               OUTP:
00C0BB  1  AD 9C 17             LDA SAVE_P
00C0BE  1  A2 07        P1:     LDX #7
00C0C0  1  0A           @1:     ASL
00C0C1  1  48                   PHA
00C0C2  1  BD DB C0             LDA @3,X
00C0C5  1  B0 0C                BCS @2
00C0C7  1               
00C0C7  1               ; Check if lowercase support is enabled or not. If enabled we show
00C0C7  1               ; unset bits as lowercase. If no lowercase support, show as a dot.
00C0C7  1               
00C0C7  1  2C A4 17             BIT OUPPER
00C0CA  1  30 05                BMI @Dot
00C0CC  1  09 20                ORA #%00100000              ; Toggle letter case
00C0CE  1  4C D3 C0             JMP @2
00C0D1  1  A9 2E        @Dot:   LDA #'.'
00C0D3  1               
00C0D3  1  20 8E BE     @2:     JSR PrintChar
00C0D6  1  68                   PLA
00C0D7  1  CA                   DEX
00C0D8  1  10 E6                BPL @1
00C0DA  1  60                   RTS
00C0DB  1  43 5A 49 44  @3: .byte "CZIDB-VN"
00C0DF  1  42 2D 56 4E  
00C0E3  1               
00C0E3  1               
00C0E3  1               ; Determines if an ACI (Apple Cassette Interface) card is present.
00C0E3  1               ; Reads the first two bytes of the ROM.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               .ifdef APPLE1
00C0E3  1               ACIPresent:
00C0E3  1                       LDA ACI                 ; First firmware byte
00C0E3  1                       CMP #$A9                ; Should contain $A9
00C0E3  1                       BNE @NoACI
00C0E3  1                       LDA ACI+1               ; Second firmware byte
00C0E3  1                       CMP #$AA                ; Should contain $AA
00C0E3  1                       BNE @NoACI
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoACI:
00C0E3  1                       LDA #0
00C0E3  1                       RTS
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Determines if a CFFA1 (Compact Flash) card is present.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               ; The documented way to check for a CFFA1 is to check for two ID bytes.
00C0E3  1               ; The documentation says it is addresses $AFFC and $AFFD but the firmware
00C0E3  1               ; actually uses addresses $AFDC and $AFDD. Further, my CFFA1 board did
00C0E3  1               ; not have these locations programmed even though firmware on CD-ROM did.
00C0E3  1               ; I manually wrote these bytes to my EEPROM.
00C0E3  1               
00C0E3  1               .ifdef APPLE1
00C0E3  1               CFFA1Present:
00C0E3  1                       LDA $AFDC               ; First CFFA1 ID byte
00C0E3  1                       CMP #$CF                ; Should contain $CF
00C0E3  1                       BNE @NoCFFA1
00C0E3  1                       LDA $AFDD               ; First CFFA1 ID byte
00C0E3  1                       CMP #$FA                ; Should contain $FA
00C0E3  1                       BNE @NoCFFA1
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoCFFA1:
00C0E3  1                       LDA #0
00C0E3  1                       RTS
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Determines if a Replica 1 Multi I/O card is present.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               ; Method is to check the first few 6551 and 6522 registers.
00C0E3  1               ; This may need some tweaking to work reliably.
00C0E3  1               ; 6522 checks may only work after a hardware reset.
00C0E3  1               ;
00C0E3  1               ; To test for the 6551:
00C0E3  1               ; Write $00 to $C302, should read back
00C0E3  1               ; Write $FF to $C302, should read back
00C0E3  1               ; Write $00 to $C303, should read back
00C0E3  1               ; Write $FF to $C303, should read back
00C0E3  1               ; Write $XX to $C301 for programmed reset
00C0E3  1               ; $C301 should read XXXXX0XX
00C0E3  1               ; $C302 should read XXX00000
00C0E3  1               ; To test for the 6522:
00C0E3  1               ; Write $FF to $C202, should read back
00C0E3  1               ; Write $00 to $C202, should read back
00C0E3  1               ; Write $FF to $C203, should read back
00C0E3  1               ; Write $00 to $C203, should read back
00C0E3  1               ; Write $AA to $C201, should read back different
00C0E3  1               ; Write $AA to $C200, should read back different
00C0E3  1               ; Read $C204 (timer). Read again and data should be different.
00C0E3  1               
00C0E3  1               .ifdef APPLE1
00C0E3  1               MultiIOPresent:
00C0E3  1                       LDA #$00
00C0E3  1                       STA $C302
00C0E3  1                       CMP $C302
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$FF
00C0E3  1                       STA $C302
00C0E3  1                       CMP $C302
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$00
00C0E3  1                       STA $C303
00C0E3  1                       CMP $C303
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$FF
00C0E3  1                       STA $C303
00C0E3  1                       CMP $C303
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       STA $C301
00C0E3  1                       LDA $C301
00C0E3  1                       AND #%00000100
00C0E3  1                       CMP #$00
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA $C302
00C0E3  1                       AND #%00011111
00C0E3  1                       CMP #$00
00C0E3  1                       BNE @NoMultiIO
00C0E3  1               
00C0E3  1                       LDA #$FF
00C0E3  1                       STA $C202
00C0E3  1                       CMP $C202
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$00
00C0E3  1                       STA $C202
00C0E3  1                       CMP $C202
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$FF
00C0E3  1                       STA $C203
00C0E3  1                       CMP $C203
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$00
00C0E3  1                       STA $C203
00C0E3  1                       CMP $C203
00C0E3  1                       BNE @NoMultiIO
00C0E3  1                       LDA #$AA
00C0E3  1                       STA $C201
00C0E3  1                       CMP $C201
00C0E3  1                       BEQ @NoMultiIO
00C0E3  1                       LDA #$AA
00C0E3  1                       STA $C200
00C0E3  1                       CMP $C200
00C0E3  1                       BEQ @NoMultiIO
00C0E3  1                       LDA $C204
00C0E3  1                       CMP $C204
00C0E3  1                       BEQ @NoMultiIO
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoMultiIO:
00C0E3  1                       LDA #0
00C0E3  1                       RTS
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Determines if an Apple II serial port is is present.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               ; Method is to check the first few 6551 registers.
00C0E3  1               .ifdef APPLE2
00C0E3  1               SerialPresent:
00C0E3  1                       LDA #$00
00C0E3  1                       STA $C09A
00C0E3  1                       CMP $C09A
00C0E3  1                       BNE @NoSerial
00C0E3  1                       LDA #$FF
00C0E3  1                       STA $C09A
00C0E3  1                       CMP $C09A
00C0E3  1                       BNE @NoSerial
00C0E3  1                       LDA #$00
00C0E3  1                       STA $C09B
00C0E3  1                       CMP $C09B
00C0E3  1                       BNE @NoSerial
00C0E3  1                       LDA #$FF
00C0E3  1                       STA $C09B
00C0E3  1                       CMP $C09B
00C0E3  1                       BNE @NoSerial
00C0E3  1                       STA $C099
00C0E3  1                       LDA $C099
00C0E3  1                       AND #%00000100
00C0E3  1                       CMP #$00
00C0E3  1                       BNE @NoSerial
00C0E3  1                       LDA $C09A
00C0E3  1                       AND #%00011111
00C0E3  1                       CMP #$00
00C0E3  1                       BNE @NoSerial
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoSerial:
00C0E3  1                       LDA #0
00C0E3  1                       RTS
00C0E3  1               
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Determines if BASIC ROM is present.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               ; Looks for the first three bytes of ROM.
00C0E3  1               ; It is unlikely but it could possibly not be present (e.g. when running in an Emulator)
00C0E3  1               
00C0E3  1               .if .defined(APPLE1)
00C0E3  1                 BASIC0 = $4C
00C0E3  1                 BASIC1 = $B0
00C0E3  1                 BASIC2 = $E2
00C0E3  1               .elseif .defined(APPLE2)
00C0E3  1                 BASIC0 = $4C
00C0E3  1                 BASIC1 = $28
00C0E3  1                 BASIC2 = $F1
00C0E3  1               .elseif .defined(OSI) .or .defined(SBC)
00C0E3  1                 BASIC0 = $A2
00C0E3  1                 BASIC1 = $FF
00C0E3  1                 BASIC2 = $86
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(OSI) .or .defined(SBC)
00C0E3  1               
00C0E3  1               BASICPresent:
00C0E3  1                       LDA BASIC               ; First firmware byte
00C0E3  1                       CMP #BASIC0
00C0E3  1                       BNE @NoBasic
00C0E3  1                       LDA BASIC+1             ; Second firmware byte
00C0E3  1                       CMP #BASIC1
00C0E3  1                       BNE @NoBasic
00C0E3  1                       LDA BASIC+2             ; Third firmware byte
00C0E3  1                       CMP #BASIC2
00C0E3  1                       BNE @NoBasic
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoBasic:
00C0E3  1                       LDA #0
00C0E3  1                       RTS
00C0E3  1               
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Determines if Krusader ROM present.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               ; Looks for the first thee bytes of ROM.
00C0E3  1               .ifdef APPLE1
00C0E3  1               KrusaderPresent:
00C0E3  1                       LDA $F000
00C0E3  1                       CMP #$A9
00C0E3  1                       BNE @NoKrusader
00C0E3  1                       LDA $F001
00C0E3  1                       CMP #$03
00C0E3  1                       BNE @NoKrusader
00C0E3  1                       LDA $F002
00C0E3  1                       CMP #$85
00C0E3  1                       BNE @NoKrusader
00C0E3  1                  LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoKrusader:
00C0E3  1                       LDA #0
00C0E3  1                       RTS
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Determines if Woz Mon is present.
00C0E3  1               ; Returns in A 1 if present, 0 if not.
00C0E3  1               ; Looks for the first two bytes of ROM.
00C0E3  1               .ifdef APPLE1
00C0E3  1               WozMonPresent:
00C0E3  1                       LDA WOZMON
00C0E3  1                       CMP #$D8
00C0E3  1                       BNE @NoWozMon
00C0E3  1                       LDA WOZMON+1
00C0E3  1                       CMP #$58
00C0E3  1                       BNE @NoWozMon
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               @NoWozMon:
00C0E3  1                       LDA #1
00C0E3  1                       RTS
00C0E3  1               .endif
00C0E3  1               
00C0E3  1               ; Convert A to uppercase if it is a lowercase letter.
00C0E3  1               ToUpper:
00C0E3  1  C9 61                CMP #'a'                ; Is it 'a' or higher?
00C0E5  1  30 06                BMI @NotLower
00C0E7  1  C9 7B                CMP #'z'+1              ; Is it 'z' or lower?
00C0E9  1  10 02                BPL @NotLower
00C0EB  1  29 DF                AND #%11011111          ; Convert to upper case by clearing bit 5
00C0ED  1               @NotLower:
00C0ED  1  60                   RTS
00C0EE  1               
00C0EE  1               ; Strings
00C0EE  1               
00C0EE  1               WelcomeMessage:
00C0EE  1  0D 50 42 55          .byte CR,"PBUG for the PAL-1", CR, LF, 0
00C0F2  1  47 20 66 6F  
00C0F6  1  72 20 74 68  
00C104  1               
00C104  1               HelpString:
00C104  1  0D 0A 44 65          .byte CR,LF,"Derived from JMON (C) by J.Tranter",CR,LF
00C108  1  72 69 76 65  
00C10C  1  64 20 66 72  
00C12A  1  50 41 4C 2D          .byte "PAL-1 hardware by Liu Ganning",CR,LF
00C12E  1  31 20 68 61  
00C132  1  72 64 77 61  
00C149  1  41 64 61 70          .byte "Adaptation by Jim McClanahan W4JBM",CR,LF,CR,LF
00C14D  1  74 61 74 69  
00C151  1  6F 6E 20 62  
00C16F  1               .ifdef MINIASM
00C16F  1  41 73 73 65          .byte "Assemble    A <address>", CR, LF
00C173  1  6D 62 6C 65  
00C177  1  20 20 20 20  
00C188  1               .endif
00C188  1  42 72 65 61          .byte "Breakpoint  B <n or ?> <address>", CR, LF
00C18C  1  6B 70 6F 69  
00C190  1  6E 74 20 20  
00C1AA  1  43 6F 70 79          .byte "Copy        C <start> <end> <dest>", CR, LF
00C1AE  1  20 20 20 20  
00C1B2  1  20 20 20 20  
00C1CE  1  44 75 6D 70          .byte "Dump        D <start>", CR, LF
00C1D2  1  20 20 20 20  
00C1D6  1  20 20 20 20  
00C1E5  1  46 69 6C 6C          .byte "Fill        F <start> <end> <data>...", CR, LF
00C1E9  1  20 20 20 20  
00C1ED  1  20 20 20 20  
00C20C  1  47 6F 20 20          .byte "Go          G <address>", CR, LF
00C210  1  20 20 20 20  
00C214  1  20 20 20 20  
00C225  1  57 72 69 74          .byte "Write Hex   H <start> <end>", CR, LF
00C229  1  65 20 48 65  
00C22D  1  78 20 20 20  
00C242  1  43 68 65 63          .byte "Checksum    K <start> <end>",CR, LF
00C246  1  6B 73 75 6D  
00C24A  1  20 20 20 20  
00C25F  1  4C 6F 61 64          .byte "Load Hex    L", CR, LF
00C263  1  20 48 65 78  
00C267  1  20 20 20 20  
00C26E  1  49 6E 66 6F          .byte "Info        N", CR, LF
00C272  1  20 20 20 20  
00C276  1  20 20 20 20  
00C27D  1  52 65 67 69          .byte "Registers   R", CR, LF
00C281  1  73 74 65 72  
00C285  1  73 20 20 20  
00C28C  1  53 65 61 72          .byte "Search      S <start> <end> <data>...", CR, LF
00C290  1  63 68 20 20  
00C294  1  20 20 20 20  
00C2B3  1  55 6E 61 73          .byte "Unassemble  U <start>", CR, LF
00C2B7  1  73 65 6D 62  
00C2BB  1  6C 65 20 20  
00C2CA  1               ;        .byte "Verify      V <start> <end> <dest>", CR, LF
00C2CA  1               ;        .byte "Write S rec W <start> <end> <go>",CR, LF
00C2CA  1  57 72 69 74          .byte "Write       W <address> <data>...", CR, LF
00C2CE  1  65 20 20 20  
00C2D2  1  20 20 20 20  
00C2ED  1  4D 6F 6E 69          .byte "Monitor     $", CR, LF
00C2F1  1  74 6F 72 20  
00C2F5  1  20 20 20 20  
00C2FC  1  54 72 61 63          .byte "Trace       .", CR, LF
00C300  1  65 20 20 20  
00C304  1  20 20 20 20  
00C30B  1  48 65 6C 70          .byte "Help        ?", CR, LF
00C30F  1  20 20 20 20  
00C313  1  20 20 20 20  
00C31A  1  00                   .byte 0
00C31B  1               
00C31B  1               
00C31B  1               KnownBPString1:
00C31B  1  42 72 65 61    .asciiz "Breakpoint "
00C31F  1  6B 70 6F 69  
00C323  1  6E 74 20 00  
00C327  1               
00C327  1               KnownBPString2:
00C327  1  20 61 74 20    .asciiz " at $"
00C32B  1  24 00        
00C32D  1               
00C32D  1               Type6502String:
00C32D  1  36 35 30 32          .asciiz "6502"
00C331  1  00           
00C332  1               
00C332  1               Type65C02String:
00C332  1  36 35 43 30          .asciiz "65C02"
00C336  1  32 00        
00C338  1               
00C338  1               Type65816String:
00C338  1  36 35 38 31          .asciiz "65816"
00C33C  1  36 00        
00C33E  1               
00C33E  1               TypeKim1String:
00C33E  1  50 41 4C 2D          .asciiz "PAL-1/KIM-1"
00C342  1  31 2F 4B 49  
00C346  1  4D 2D 31 00  
00C34A  1               
00C34A  1               SInvalidRecord:
00C34A  1  49 6E 76 61          .asciiz "Invalid record"
00C34E  1  6C 69 64 20  
00C352  1  72 65 63 6F  
00C359  1               SChecksumError:
00C359  1  43 68 65 63          .asciiz "Checksum error"
00C35D  1  6B 73 75 6D  
00C361  1  20 65 72 72  
00C368  1               SLoading:
00C368  1  4C 6F 61 64          .asciiz "Loading"
00C36C  1  69 6E 67 00  
00C370  1               SLoaded:
00C370  1  4C 6F 61 64          .asciiz "Loaded"
00C374  1  65 64 00     
00C377  1               ;S0String:
00C377  1               ;        .byte   CR, LF, "S0030000FC", CR, LF, 0
00C377  1  20 4C 4F 52          .asciiz " LORI<3 "
00C37B  1  49 3C 33 20  
00C37F  1  00           
00C380  1               
00C380  1                 .include "disasm.s"
00C380  2               ;
00C380  2               ; 6502/65C02/65816 Disassembler
00C380  2               ;
00C380  2               ; Copyright (C) 2012-2020 by Jeff Tranter <tranter@pobox.com>
00C380  2               ;
00C380  2               ; Licensed under the Apache License, Version 2.0 (the "License");
00C380  2               ; you may not use this file except in compliance with the License.
00C380  2               ; You may obtain a copy of the License at
00C380  2               ;
00C380  2               ;   http://www.apache.org/licenses/LICENSE-2.0
00C380  2               ;
00C380  2               ; Unless required by applicable law or agreed to in writing, software
00C380  2               ; distributed under the License is distributed on an "AS IS" BASIS,
00C380  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
00C380  2               ; See the License for the specific language governing permissions and
00C380  2               ; limitations under the License.
00C380  2               ;
00C380  2               ; Revision History
00C380  2               ; Version Date         Comments
00C380  2               ; 0.0     25-Mar-2012  First version started
00C380  2               ; 0.9     28-Mar-2012  First public beta version
00C380  2               ; 1.0     03-Jul-2012  Added 65816 support
00C380  2               
00C380  2               ; *** ASSEMBLY TIME OPTIONS ***
00C380  2               
00C380  2               ; Uncomment this if you don't want instructions that operate on the
00C380  2               ; accumulator like ASL to be shown as "ASL A" but instead just "ASL".
00C380  2               ; NOACCUMULATOR = 1
00C380  2               
00C380  2               ; Uncomment this if you want the output to include source code only
00C380  2               ; and not the data bytes in memory. This allows the output to be fed
00C380  2               ; back to an assembler.
00C380  2               ; SOURCEONLY = 1
00C380  2               
00C380  2               ; Define this if you want 65816 instructions to be disassembled.
00C380  2               ; D65816 = 1
00C380  2               
00C380  2               ; Define this if you want 65C02 instructions to be disassembled.
00C380  2               D65C02 = 1
00C380  2               
00C380  2               ; Define this if you want the WDC and Rockwell-specific bit instructions
00C380  2               ; to be disassembled (BBR, BBS, RMB, SMB). This is mutually exclusive
00C380  2               ; with the 65816 option.
00C380  2               ; ROCKWELL = 1
00C380  2               
00C380  2               ; Uncomment next line to link with start address of $A000 for Multi I/0 Board EEPROM.
00C380  2               ; .org $A000
00C380  2               
00C380  2               .if .defined(ROCKWELL) .and .defined(D65816)
00C380  2               .error "The 65816 and ROCKWELL options are mutually exclusive."
00C380  2               .endif
00C380  2               
00C380  2               ; Instructions. Match indexes into entries in table MNEMONICS1/MENMONICS2.
00C380  2                OP_INV = $00
00C380  2                OP_ADC = $01
00C380  2                OP_AND = $02
00C380  2                OP_ASL = $03
00C380  2                OP_BCC = $04
00C380  2                OP_BCS = $05
00C380  2                OP_BEQ = $06
00C380  2                OP_BIT = $07
00C380  2                OP_BMI = $08
00C380  2                OP_BNE = $09
00C380  2                OP_BPL = $0A
00C380  2                OP_BRK = $0B
00C380  2                OP_BVC = $0C
00C380  2                OP_BVS = $0D
00C380  2                OP_CLC = $0E
00C380  2                OP_CLD = $0F
00C380  2                OP_CLI = $10
00C380  2                OP_CLV = $11
00C380  2                OP_CMP = $12
00C380  2                OP_CPX = $13
00C380  2                OP_CPY = $14
00C380  2                OP_DEC = $15
00C380  2                OP_DEX = $16
00C380  2                OP_DEY = $17
00C380  2                OP_EOR = $18
00C380  2                OP_INC = $19
00C380  2                OP_INX = $1A
00C380  2                OP_INY = $1B
00C380  2                OP_JMP = $1C
00C380  2                OP_JSR = $1D
00C380  2                OP_LDA = $1E
00C380  2                OP_LDX = $1F
00C380  2                OP_LDY = $20
00C380  2                OP_LSR = $21
00C380  2                OP_NOP = $22
00C380  2                OP_ORA = $23
00C380  2                OP_PHA = $24
00C380  2                OP_PHP = $25
00C380  2                OP_PLA = $26
00C380  2                OP_PLP = $27
00C380  2                OP_ROL = $28
00C380  2                OP_ROR = $29
00C380  2                OP_RTI = $2A
00C380  2                OP_RTS = $2B
00C380  2                OP_SBC = $2C
00C380  2                OP_SEC = $2D
00C380  2                OP_SED = $2E
00C380  2                OP_SEI = $2F
00C380  2                OP_STA = $30
00C380  2                OP_STX = $31
00C380  2                OP_STY = $32
00C380  2                OP_TAX = $33
00C380  2                OP_TAY = $34
00C380  2                OP_TSX = $35
00C380  2                OP_TXA = $36
00C380  2                OP_TXS = $37
00C380  2                OP_TYA = $38
00C380  2                OP_BBR = $39 ; [65C02 only]
00C380  2                OP_BBS = $3A ; [65C02 only]
00C380  2                OP_BRA = $3B ; [65C02 only]
00C380  2                OP_PHX = $3C ; [65C02 only]
00C380  2                OP_PHY = $3D ; [65C02 only]
00C380  2                OP_PLX = $3E ; [65C02 only]
00C380  2                OP_PLY = $3F ; [65C02 only]
00C380  2                OP_RMB = $40 ; [65C02 only]
00C380  2                OP_SMB = $41 ; [65C02 only]
00C380  2                OP_STZ = $42 ; [65C02 only]
00C380  2                OP_TRB = $43 ; [65C02 only]
00C380  2                OP_TSB = $44 ; [65C02 only]
00C380  2                OP_STP = $45 ; [WDC 65C02 and 65816 only]
00C380  2                OP_WAI = $46 ; [WDC 65C02 and 65816 only]
00C380  2                OP_BRL = $47 ; [WDC 65816 only]
00C380  2                OP_COP = $48 ; [WDC 65816 only]
00C380  2                OP_JML = $49 ; [WDC 65816 only]
00C380  2                OP_JSL = $4A ; [WDC 65816 only]
00C380  2                OP_MVN = $4B ; [WDC 65816 only]
00C380  2                OP_MVP = $4C ; [WDC 65816 only]
00C380  2                OP_PEA = $4D ; [WDC 65816 only]
00C380  2                OP_PEI = $4E ; [WDC 65816 only]
00C380  2                OP_PER = $4F ; [WDC 65816 only]
00C380  2                OP_PHB = $50 ; [WDC 65816 only]
00C380  2                OP_PHD = $51 ; [WDC 65816 only]
00C380  2                OP_PHK = $52 ; [WDC 65816 only]
00C380  2                OP_PLB = $53 ; [WDC 65816 only]
00C380  2                OP_PLD = $54 ; [WDC 65816 only]
00C380  2                OP_REP = $56 ; [WDC 65816 only]
00C380  2                OP_RTL = $57 ; [WDC 65816 only]
00C380  2                OP_SEP = $58 ; [WDC 65816 only]
00C380  2                OP_TCD = $59 ; [WDC 65816 only]
00C380  2                OP_TCS = $5A ; [WDC 65816 only]
00C380  2                OP_TDC = $5B ; [WDC 65816 only]
00C380  2                OP_TSC = $5C ; [WDC 65816 only]
00C380  2                OP_TXY = $5D ; [WDC 65816 only]
00C380  2                OP_TYX = $5E ; [WDC 65816 only]
00C380  2                OP_WDM = $5F ; [WDC 65816 only]
00C380  2                OP_XBA = $60 ; [WDC 65816 only]
00C380  2                OP_XCE = $61 ; [WDC 65816 only]
00C380  2               
00C380  2               ; Addressing Modes. OPCODES1/OPCODES2 tables list these for each instruction. LENGTHS lists the instruction length for each addressing mode.
00C380  2                AM_INVALID = 0                    ; example:
00C380  2                AM_IMPLICIT = 1                   ; RTS
00C380  2                AM_ACCUMULATOR = 2                ; ASL A
00C380  2                AM_IMMEDIATE = 3                  ; LDA #$12
00C380  2                AM_ZEROPAGE = 4                   ; LDA $12
00C380  2                AM_ZEROPAGE_X = 5                 ; LDA $12,X
00C380  2                AM_ZEROPAGE_Y = 6                 ; LDA $12,Y
00C380  2                AM_RELATIVE = 7                   ; BNE $FD
00C380  2                AM_ABSOLUTE = 8                   ; JSR $1234
00C380  2                AM_ABSOLUTE_X = 9                 ; STA $1234,X
00C380  2                AM_ABSOLUTE_Y = 10                ; STA $1234,Y
00C380  2                AM_INDIRECT = 11                  ; JMP ($1234)
00C380  2                AM_INDEXED_INDIRECT = 12          ; LDA ($12,X)
00C380  2                AM_INDIRECT_INDEXED = 13          ; LDA ($12),Y
00C380  2                AM_INDIRECT_ZEROPAGE = 14         ; LDA ($12) [65C02 only]
00C380  2                AM_ABSOLUTE_INDEXED_INDIRECT = 15 ; JMP ($1234,X) [65C02 only]
00C380  2                AM_STACK_RELATIVE = 16            ; LDA 3,S [65816 only]
00C380  2                AM_DIRECT_PAGE_INDIRECT_LONG = 17 ; LDA [$55] [65816 only]
00C380  2                AM_ABSOLUTE_LONG = 18             ; LDA $02F000 [65816 only]
00C380  2                AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y = 19 ; LDA (5,S),Y [65816 only]
00C380  2                AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y = 20 ; LDA [$55],Y [65816 only]
00C380  2                AM_ABSOLUTE_LONG_INDEXED_WITH_X = 21 ; LDA $12D080,X [65816 only]
00C380  2                AM_BLOCK_MOVE = 22                ; MVP 0,0 [65816 only]
00C380  2                AM_PROGRAM_COUNTER_RELATIVE_LONG = 23 ; BRL JMPLABEL [65816 only]
00C380  2                AM_ABSOLUTE_INDIRECT_LONG = 24    ; JMP [$2000] [65816 only]
00C380  2               
00C380  2               ; *** CODE ***
00C380  2               
00C380  2               ; Disassemble instruction at address ADDR (low) / ADDR+1 (high). On
00C380  2               ; return ADDR/ADDR+1 points to next instruction so it can be called
00C380  2               ; again.
00C380  2               DISASM:
00C380  2  A2 00          LDX #0
00C382  2  A1 38          LDA (ADDR,X)          ; get instruction op code
00C384  2  8D 88 17       STA OPCODE
00C387  2  30 12          BMI UPPER             ; if bit 7 set, in upper half of table
00C389  2  0A             ASL A                 ; double it since table is two bytes per entry
00C38A  2  AA             TAX
00C38B  2  BD 76 C9       LDA OPCODES1,X        ; get the instruction type (e.g. OP_LDA)
00C38E  2  8D 89 17       STA OP                ; store it
00C391  2  E8             INX
00C392  2  BD 76 C9       LDA OPCODES1,X        ; get addressing mode
00C395  2  8D 8A 17       STA AM                ; store it
00C398  2  4C AA C3       JMP AROUND
00C39B  2               UPPER:
00C39B  2  0A             ASL A                 ; double it since table is two bytes per entry
00C39C  2  AA             TAX
00C39D  2  BD 76 CA       LDA OPCODES2,X        ; get the instruction type (e.g. OP_LDA)
00C3A0  2  8D 89 17       STA OP                ; store it
00C3A3  2  E8             INX
00C3A4  2  BD 76 CA       LDA OPCODES2,X        ; get addressing mode
00C3A7  2  8D 8A 17       STA AM                ; store it
00C3AA  2               AROUND:
00C3AA  2  AA             TAX                   ; put addressing mode in X
00C3AB  2  BD 5D C9       LDA LENGTHS,X         ; get instruction length given addressing mode
00C3AE  2  8D 8B 17       STA LEN               ; store it
00C3B1  2               
00C3B1  2               ; Handle 16-bit modes of 65816
00C3B1  2               ; When M=0 (16-bit accumulator) the following instructions take an extra byte:
00C3B1  2               ; 09 29 49 69 89 A9 C9 E9
00C3B1  2               ; When X=0 (16-bit index) the following instructions take an extra byte:
00C3B1  2               ; A0 A2 C0 E0
00C3B1  2               
00C3B1  2  AD A7 17       LDA MBIT              ; Is M bit zero?
00C3B4  2  D0 2B          BNE TRYX              ; If not, skip adjustment.
00C3B6  2  AD 88 17       LDA OPCODE            ; See if the opcode is one that needs to be adjusted
00C3B9  2  C9 09          CMP #$09
00C3BB  2  F0 1E          BEQ ADJUST
00C3BD  2  C9 29          CMP #$29
00C3BF  2  F0 1A          BEQ ADJUST
00C3C1  2  C9 49          CMP #$49
00C3C3  2  F0 16          BEQ ADJUST
00C3C5  2  C9 69          CMP #$69
00C3C7  2  F0 12          BEQ ADJUST
00C3C9  2  C9 89          CMP #$89
00C3CB  2  F0 0E          BEQ ADJUST
00C3CD  2  C9 A9          CMP #$A9
00C3CF  2  F0 0A          BEQ ADJUST
00C3D1  2  C9 C9          CMP #$C9
00C3D3  2  F0 06          BEQ ADJUST
00C3D5  2  C9 E9          CMP #$E9
00C3D7  2  F0 02          BEQ ADJUST
00C3D9  2  D0 06          BNE TRYX
00C3DB  2               ADJUST:
00C3DB  2  EE 8B 17       INC LEN               ; Increment length by one
00C3DE  2  4C F9 C3       JMP REPSEP
00C3E1  2               
00C3E1  2               TRYX:
00C3E1  2  AD A8 17       LDA XBIT              ; Is X bit zero?
00C3E4  2  D0 13          BNE REPSEP            ; If not, skip adjustment.
00C3E6  2  AD 88 17       LDA OPCODE            ; See if the opcode is one that needs to be adjusted
00C3E9  2  C9 A0          CMP #$A0
00C3EB  2  F0 EE          BEQ ADJUST
00C3ED  2  C9 A2          CMP #$A2
00C3EF  2  F0 EA          BEQ ADJUST
00C3F1  2  C9 C0          CMP #$C0
00C3F3  2  F0 E6          BEQ ADJUST
00C3F5  2  C9 E0          CMP #$E0
00C3F7  2  F0 E2          BEQ ADJUST
00C3F9  2               
00C3F9  2               ; Special check for REP and SEP instructions.
00C3F9  2               ; These set or clear the M and X bits which change the length of some instructions.
00C3F9  2               
00C3F9  2               REPSEP:
00C3F9  2  AD 88 17       LDA OPCODE
00C3FC  2  C9 C2          CMP #$C2              ; Is it REP?
00C3FE  2  D0 20          BNE TRYSEP
00C400  2  A0 01          LDY #1
00C402  2  B1 38          LDA (ADDR),Y          ; get operand
00C404  2  49 FF          EOR #$FF              ; Complement the bits
00C406  2  29 20          AND #%00100000        ; Mask out M bit
00C408  2  4A             LSR                   ; Shift into bit 0
00C409  2  4A             LSR
00C40A  2  4A             LSR
00C40B  2  4A             LSR
00C40C  2  4A             LSR
00C40D  2  8D A7 17       STA MBIT              ; Store it
00C410  2  B1 38          LDA (ADDR),Y          ; get operand again
00C412  2  49 FF          EOR #$FF              ; Complement the bits
00C414  2  29 10          AND #%00010000        ; Mask out X bit
00C416  2  4A             LSR                   ; Shift into bit 0
00C417  2  4A             LSR
00C418  2  4A             LSR
00C419  2  4A             LSR
00C41A  2  8D A8 17       STA XBIT              ; Store it
00C41D  2  4C 3D C4       JMP PRADDR
00C420  2               
00C420  2               TRYSEP:
00C420  2  C9 E2          CMP #$E2              ; Is it SEP?
00C422  2  D0 19          BNE PRADDR
00C424  2  A0 01          LDY #1
00C426  2  B1 38          LDA (ADDR),Y          ; get operand
00C428  2  29 20          AND #%00100000        ; Mask out M bit
00C42A  2  4A             LSR                   ; Shift into bit 0
00C42B  2  4A             LSR
00C42C  2  4A             LSR
00C42D  2  4A             LSR
00C42E  2  4A             LSR
00C42F  2  8D A7 17       STA MBIT              ; Store it
00C432  2  B1 38          LDA (ADDR),Y          ; get operand again
00C434  2  29 10          AND #%00010000        ; Mask out X bit
00C436  2  4A             LSR                   ; Shift into bit 0
00C437  2  4A             LSR
00C438  2  4A             LSR
00C439  2  4A             LSR
00C43A  2  8D A8 17       STA XBIT              ; Store it
00C43D  2               
00C43D  2               PRADDR:
00C43D  2  A6 38          LDX ADDR
00C43F  2  A4 39          LDY ADDR+1
00C441  2                 .ifndef SOURCEONLY
00C441  2  20 AF BD       JSR PrintAddress      ; print address
00C444  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C444  2  A2 03          LDX #3
00C446  2  20 F7 BE       JSR PrintSpaces       ; then three spaces
00C449  2               .elseif .defined(OSI)
00C449  2                 JSR PrintSpace
00C449  2               .endif
00C449  2  AD 88 17       LDA OPCODE            ; get instruction op code
00C44C  2  20 7B BE       JSR PrintByte         ; display the opcode byte
00C44F  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C44F  2  20 20 BE       JSR PrintSpace
00C452  2               .endif
00C452  2  AD 8B 17       LDA LEN               ; how many bytes in the instruction?
00C455  2  C9 04          CMP #4
00C457  2  F0 33          BEQ FOUR
00C459  2  C9 03          CMP #3
00C45B  2  F0 1B          BEQ THREE
00C45D  2  C9 02          CMP #2
00C45F  2  F0 08          BEQ TWO
00C461  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C461  2  A2 05          LDX #5
00C463  2               .elseif .defined(OSI)
00C463  2                 LDX #4
00C463  2               .endif
00C463  2  20 F7 BE       JSR PrintSpaces
00C466  2  4C AB C4       JMP ONE
00C469  2               TWO:
00C469  2  A0 01          LDY #1
00C46B  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
00C46D  2  20 7B BE       JSR PrintByte         ; display it
00C470  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C470  2  A2 03          LDX #3
00C472  2               .elseif .defined(OSI)
00C472  2                 LDX #2
00C472  2               .endif
00C472  2  20 F7 BE       JSR PrintSpaces
00C475  2  4C AB C4       JMP ONE
00C478  2               THREE:
00C478  2  A0 01          LDY #1
00C47A  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
00C47C  2  20 7B BE       JSR PrintByte         ; display it
00C47F  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C47F  2  20 20 BE       JSR PrintSpace
00C482  2               .endif
00C482  2  A0 02          LDY #2
00C484  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00C486  2  20 7B BE       JSR PrintByte         ; display it
00C489  2  4C AB C4       JMP ONE
00C48C  2               FOUR:
00C48C  2  A0 01          LDY #1
00C48E  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
00C490  2  20 7B BE       JSR PrintByte         ; display it
00C493  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C493  2  20 20 BE       JSR PrintSpace
00C496  2               .endif
00C496  2  A0 02          LDY #2
00C498  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00C49A  2  20 7B BE       JSR PrintByte         ; display it
00C49D  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C49D  2  20 20 BE       JSR PrintSpace
00C4A0  2               .endif
00C4A0  2  A0 03          LDY #3
00C4A2  2  B1 38          LDA (ADDR),Y          ; get 3nd operand byte
00C4A4  2  20 7B BE       JSR PrintByte         ; display it
00C4A7  2  A2 01          LDX #1
00C4A9  2  D0 02          BNE SPC
00C4AB  2               ONE:
00C4AB  2                 .endif                ; .ifndef SOURCEONLY
00C4AB  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C4AB  2  A2 04          LDX #4
00C4AD  2               .elseif .defined(OSI)
00C4AD  2                 LDX #1
00C4AD  2               .endif
00C4AD  2               SPC:
00C4AD  2  20 F7 BE       JSR PrintSpaces
00C4B0  2  AD 89 17       LDA OP                ; get the op code
00C4B3  2  C9 55          CMP #$55              ; Is it in the first half of the table?
00C4B5  2  30 14          BMI LOWERM
00C4B7  2               
00C4B7  2  0A             ASL A                 ; multiply by 2
00C4B8  2  18             CLC
00C4B9  2  6D 89 17       ADC OP                ; add one more to multiply by 3 since table is three bytes per entry
00C4BC  2  A0 03          LDY #3                ; going to loop 3 times
00C4BE  2  AA             TAX                   ; save index into table
00C4BF  2               MNEM2:
00C4BF  2  BD 37 C9       LDA MNEMONICS2+1,X    ; print three chars of mnemonic
00C4C2  2  20 8E BE       JSR PrintChar
00C4C5  2  E8             INX
00C4C6  2  88             DEY
00C4C7  2  D0 F6          BNE MNEM2
00C4C9  2  F0 12          BEQ AMODE
00C4CB  2               
00C4CB  2               LOWERM:
00C4CB  2  0A             ASL A                 ; multiply by 2
00C4CC  2  18             CLC
00C4CD  2  6D 89 17       ADC OP                ; add one more to multiply by 3 since table is three bytes per entry
00C4D0  2  A0 03          LDY #3                ; going to loop 3 times
00C4D2  2  AA             TAX                   ; save index into table
00C4D3  2               MNEM1:
00C4D3  2  BD 37 C8       LDA MNEMONICS1,X      ; print three chars of mnemonic
00C4D6  2  20 8E BE       JSR PrintChar
00C4D9  2  E8             INX
00C4DA  2  88             DEY
00C4DB  2  D0 F6          BNE MNEM1
00C4DD  2               
00C4DD  2               ; Display any operands based on addressing mode
00C4DD  2               AMODE:
00C4DD  2  AD 89 17       LDA OP                ; is it RMB or SMB?
00C4E0  2  C9 40          CMP #OP_RMB
00C4E2  2  F0 04          BEQ DOMB
00C4E4  2  C9 41          CMP #OP_SMB
00C4E6  2  D0 1E          BNE TRYBB
00C4E8  2               DOMB:
00C4E8  2  AD 88 17       LDA OPCODE            ; get the op code
00C4EB  2  29 70          AND #$70              ; Upper 3 bits is the bit number
00C4ED  2  4A             LSR
00C4EE  2  4A             LSR
00C4EF  2  4A             LSR
00C4F0  2  4A             LSR
00C4F1  2  20 84 BE       JSR PRHEX
00C4F4  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C4F4  2  A2 02          LDX #2
00C4F6  2               .elseif .defined(OSI)
00C4F6  2                 LDX #1
00C4F6  2               .endif
00C4F6  2  20 F7 BE       JSR PrintSpaces
00C4F9  2  20 9E BE       JSR PrintDollar
00C4FC  2  A0 01          LDY #1
00C4FE  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C500  2  20 7B BE       JSR PrintByte         ; display it
00C503  2  4C 25 C8       JMP DONEOPS
00C506  2               TRYBB:
00C506  2  AD 89 17       LDA OP                ; is it BBR or BBS?
00C509  2  C9 39          CMP #OP_BBR
00C50B  2  F0 04          BEQ DOBB
00C50D  2  C9 3A          CMP #OP_BBS
00C50F  2  D0 63          BNE TRYIMP
00C511  2               DOBB:                   ; handle special BBRn and BBSn instructions
00C511  2  AD 88 17       LDA OPCODE            ; get the op code
00C514  2  29 70          AND #$70              ; Upper 3 bits is the bit number
00C516  2  4A             LSR
00C517  2  4A             LSR
00C518  2  4A             LSR
00C519  2  4A             LSR
00C51A  2  20 84 BE       JSR PRHEX
00C51D  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C51D  2  A2 02          LDX #2
00C51F  2               .elseif .defined(OSI)
00C51F  2                 LDX #1
00C51F  2               .endif
00C51F  2  20 F7 BE       JSR PrintSpaces
00C522  2  20 9E BE       JSR PrintDollar
00C525  2  A0 01          LDY #1
00C527  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
00C529  2  20 7B BE       JSR PrintByte         ; display it
00C52C  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C52C  2  A9 2C          LDA #','
00C52E  2  20 8E BE       JSR PrintChar
00C531  2  20 9E BE       JSR PrintDollar
00C534  2               .endif
00C534  2               ; Handle relative addressing
00C534  2               ; Destination address is Current address + relative (sign extended so upper byte is $00 or $FF) + 3
00C534  2  A0 02          LDY #2
00C536  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (relative branch offset)
00C538  2  8D 8C 17       STA REL               ; save low byte of offset
00C53B  2  30 04          BMI @NEG              ; if negative, need to sign extend
00C53D  2  A9 00          LDA #0                ; high byte is zero
00C53F  2  F0 02          BEQ @ADD
00C541  2               @NEG:
00C541  2  A9 FF          LDA #$FF              ; negative offset, high byte if $FF
00C543  2               @ADD:
00C543  2  8D 8D 17       STA REL+1             ; save offset high byte
00C546  2  A5 38          LDA ADDR              ; take adresss
00C548  2  18             CLC
00C549  2  6D 8C 17       ADC REL               ; add offset
00C54C  2  8D 8E 17       STA DEZT              ; and store
00C54F  2  A5 39          LDA ADDR+1            ; also high byte (including carry)
00C551  2  6D 8D 17       ADC REL+1
00C554  2  8D 8F 17       STA DEZT+1
00C557  2  AD 8E 17       LDA DEZT              ; now need to add 3 more to the address
00C55A  2  18             CLC
00C55B  2  69 03          ADC #3
00C55D  2  8D 8E 17       STA DEZT
00C560  2  AD 8F 17       LDA DEZT+1
00C563  2  69 00          ADC #0                ; add any carry
00C565  2  8D 8F 17       STA DEZT+1
00C568  2  20 7B BE       JSR PrintByte         ; display high byte
00C56B  2  AD 8E 17       LDA DEZT
00C56E  2  20 7B BE       JSR PrintByte         ; display low byte
00C571  2  4C 25 C8       JMP DONEOPS
00C574  2               TRYIMP:
00C574  2  AD 8A 17       LDA AM
00C577  2  C9 01          CMP #AM_IMPLICIT
00C579  2  D0 03          BNE TRYINV
00C57B  2  4C 25 C8       JMP DONEOPS           ; no operands
00C57E  2               TRYINV:
00C57E  2  C9 00          CMP #AM_INVALID
00C580  2  D0 03          BNE TRYACC
00C582  2  4C 25 C8       JMP DONEOPS           ; no operands
00C585  2               TRYACC:
00C585  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00C585  2  A2 03          LDX #3
00C587  2               .elseif .defined(OSI)
00C587  2                 LDX #1
00C587  2               .endif
00C587  2  20 F7 BE       JSR PrintSpaces
00C58A  2  C9 02          CMP #AM_ACCUMULATOR
00C58C  2  D0 08          BNE TRYIMM
00C58E  2                .ifndef NOACCUMULATOR
00C58E  2  A9 41          LDA #'A'
00C590  2  20 8E BE       JSR PrintChar
00C593  2                .endif                 ; .ifndef NOACCUMULATOR
00C593  2  4C 25 C8       JMP DONEOPS
00C596  2               TRYIMM:
00C596  2  C9 03          CMP #AM_IMMEDIATE
00C598  2  D0 2A          BNE TRYZP
00C59A  2  A9 23          LDA #'#'
00C59C  2  20 8E BE       JSR PrintChar
00C59F  2  20 9E BE       JSR PrintDollar
00C5A2  2  AD 8B 17       LDA LEN               ; Operand could be 8 or 16-bits
00C5A5  2  C9 03          CMP #3                ; 16-bit?
00C5A7  2  F0 0A          BEQ IM16              ; Branch if so, otherwise it is 8-bit
00C5A9  2  A0 01          LDY #1
00C5AB  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C5AD  2  20 7B BE       JSR PrintByte         ; display it
00C5B0  2  4C 25 C8       JMP DONEOPS
00C5B3  2               IM16:
00C5B3  2  A0 02          LDY #2
00C5B5  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C5B7  2  20 7B BE       JSR PrintByte         ; display it
00C5BA  2  A0 01          LDY #1
00C5BC  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C5BE  2  20 7B BE       JSR PrintByte         ; display it
00C5C1  2  4C 25 C8       JMP DONEOPS
00C5C4  2               
00C5C4  2               TRYZP:
00C5C4  2  C9 04          CMP #AM_ZEROPAGE
00C5C6  2  D0 0D          BNE TRYZPX
00C5C8  2  20 9E BE       JSR PrintDollar
00C5CB  2  A0 01          LDY #1
00C5CD  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C5CF  2  20 7B BE       JSR PrintByte         ; display it
00C5D2  2  4C 25 C8       JMP DONEOPS
00C5D5  2               TRYZPX:
00C5D5  2  C9 05          CMP #AM_ZEROPAGE_X
00C5D7  2  D0 10          BNE TRYZPY
00C5D9  2  A0 01          LDY #1
00C5DB  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
00C5DD  2  20 9E BE       JSR PrintDollar
00C5E0  2  20 7B BE       JSR PrintByte         ; display it
00C5E3  2  20 A6 BE       JSR PrintCommaX
00C5E6  2  4C 25 C8       JMP DONEOPS
00C5E9  2               TRYZPY:
00C5E9  2  C9 06          CMP #AM_ZEROPAGE_Y
00C5EB  2  D0 10          BNE TRYREL
00C5ED  2  A0 01          LDY #1
00C5EF  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
00C5F1  2  20 9E BE       JSR PrintDollar
00C5F4  2  20 7B BE       JSR PrintByte         ; display it
00C5F7  2  20 B3 BE       JSR PrintCommaY
00C5FA  2  4C 25 C8       JMP DONEOPS
00C5FD  2               TRYREL:
00C5FD  2  C9 07          CMP #AM_RELATIVE
00C5FF  2  D0 43          BNE TRYABS
00C601  2  20 9E BE       JSR PrintDollar
00C604  2               ; Handle relative addressing
00C604  2               ; Destination address is Current address + relative (sign extended so upper byte is $00 or $FF) + 2
00C604  2  A0 01          LDY #1
00C606  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (relative branch offset)
00C608  2  8D 8C 17       STA REL               ; save low byte of offset
00C60B  2  30 04          BMI NEG               ; if negative, need to sign extend
00C60D  2  A9 00          LDA #0                ; high byte is zero
00C60F  2  F0 02          BEQ ADD
00C611  2               NEG:
00C611  2  A9 FF          LDA #$FF              ; negative offset, high byte if $FF
00C613  2               ADD:
00C613  2  8D 8D 17       STA REL+1             ; save offset high byte
00C616  2  A5 38          LDA ADDR              ; take adresss
00C618  2  18             CLC
00C619  2  6D 8C 17       ADC REL               ; add offset
00C61C  2  8D 8E 17       STA DEZT              ; and store
00C61F  2  A5 39          LDA ADDR+1            ; also high byte (including carry)
00C621  2  6D 8D 17       ADC REL+1
00C624  2  8D 8F 17       STA DEZT+1
00C627  2  AD 8E 17       LDA DEZT              ; now need to add 2 more to the address
00C62A  2  18             CLC
00C62B  2  69 02          ADC #2
00C62D  2  8D 8E 17       STA DEZT
00C630  2  AD 8F 17       LDA DEZT+1
00C633  2  69 00          ADC #0                ; add any carry
00C635  2  8D 8F 17       STA DEZT+1
00C638  2  20 7B BE       JSR PrintByte         ; display high byte
00C63B  2  AD 8E 17       LDA DEZT
00C63E  2  20 7B BE       JSR PrintByte         ; display low byte
00C641  2  4C 25 C8       JMP DONEOPS
00C644  2               TRYABS:
00C644  2  C9 08          CMP #AM_ABSOLUTE
00C646  2  D0 14          BNE TRYABSX
00C648  2  20 9E BE       JSR PrintDollar
00C64B  2  A0 02          LDY #2
00C64D  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C64F  2  20 7B BE       JSR PrintByte         ; display it
00C652  2  A0 01          LDY #1
00C654  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C656  2  20 7B BE       JSR PrintByte         ; display it
00C659  2  4C 25 C8       JMP DONEOPS
00C65C  2               TRYABSX:
00C65C  2  C9 09          CMP #AM_ABSOLUTE_X
00C65E  2  D0 17          BNE TRYABSY
00C660  2  20 9E BE       JSR PrintDollar
00C663  2  A0 02          LDY #2
00C665  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C667  2  20 7B BE       JSR PrintByte         ; display it
00C66A  2  A0 01          LDY #1
00C66C  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C66E  2  20 7B BE       JSR PrintByte         ; display it
00C671  2  20 A6 BE       JSR PrintCommaX
00C674  2  4C 25 C8       JMP DONEOPS
00C677  2               TRYABSY:
00C677  2  C9 0A          CMP #AM_ABSOLUTE_Y
00C679  2  D0 17          BNE TRYIND
00C67B  2  20 9E BE       JSR PrintDollar
00C67E  2  A0 02          LDY #2
00C680  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C682  2  20 7B BE       JSR PrintByte         ; display it
00C685  2  A0 01          LDY #1
00C687  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C689  2  20 7B BE       JSR PrintByte         ; display it
00C68C  2  20 B3 BE       JSR PrintCommaY
00C68F  2  4C 25 C8       JMP DONEOPS
00C692  2               TRYIND:
00C692  2  C9 0B          CMP #AM_INDIRECT
00C694  2  D0 17          BNE TRYINDXIND
00C696  2  20 CD BE       JSR PrintLParenDollar
00C699  2  A0 02          LDY #2
00C69B  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C69D  2  20 7B BE       JSR PrintByte         ; display it
00C6A0  2  A0 01          LDY #1
00C6A2  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C6A4  2  20 7B BE       JSR PrintByte         ; display it
00C6A7  2  20 E7 BE       JSR PrintRParen
00C6AA  2  4C 25 C8       JMP DONEOPS
00C6AD  2               
00C6AD  2               TRYINDXIND:
00C6AD  2  C9 0C          CMP #AM_INDEXED_INDIRECT
00C6AF  2  D0 13          BNE TRYINDINDX
00C6B1  2  20 CD BE       JSR PrintLParenDollar
00C6B4  2  A0 01          LDY #1
00C6B6  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C6B8  2  20 7B BE       JSR PrintByte         ; display it
00C6BB  2  20 A6 BE       JSR PrintCommaX
00C6BE  2  20 E7 BE       JSR PrintRParen
00C6C1  2  4C 25 C8       JMP DONEOPS
00C6C4  2               TRYINDINDX:
00C6C4  2  C9 0D          CMP #AM_INDIRECT_INDEXED
00C6C6  2  D0 13          BNE TRYINDZ
00C6C8  2  20 CD BE       JSR PrintLParenDollar
00C6CB  2  A0 01          LDY #1
00C6CD  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C6CF  2  20 7B BE       JSR PrintByte         ; display it
00C6D2  2  20 E7 BE       JSR PrintRParen
00C6D5  2  20 B3 BE       JSR PrintCommaY
00C6D8  2  4C 25 C8       JMP DONEOPS
00C6DB  2               TRYINDZ:
00C6DB  2  C9 0E          CMP #AM_INDIRECT_ZEROPAGE ; [65C02 only]
00C6DD  2  D0 10          BNE TRYABINDIND
00C6DF  2  20 CD BE       JSR PrintLParenDollar
00C6E2  2  A0 01          LDY #1
00C6E4  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C6E6  2  20 7B BE       JSR PrintByte         ; display it
00C6E9  2  20 E7 BE       JSR PrintRParen
00C6EC  2  4C 25 C8       JMP DONEOPS
00C6EF  2               TRYABINDIND:
00C6EF  2  C9 0F          CMP #AM_ABSOLUTE_INDEXED_INDIRECT ; [65C02 only]
00C6F1  2  D0 1A          BNE TRYSTACKREL
00C6F3  2  20 CD BE       JSR PrintLParenDollar
00C6F6  2  A0 02          LDY #2
00C6F8  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C6FA  2  20 7B BE       JSR PrintByte         ; display it
00C6FD  2  A0 01          LDY #1
00C6FF  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C701  2  20 7B BE       JSR PrintByte         ; display it
00C704  2  20 A6 BE       JSR PrintCommaX
00C707  2  20 E7 BE       JSR PrintRParen
00C70A  2  4C 25 C8       JMP DONEOPS
00C70D  2               
00C70D  2               TRYSTACKREL:
00C70D  2  C9 10          CMP #AM_STACK_RELATIVE ; [WDC 65816 only]
00C70F  2  D0 10          BNE TRYDPIL
00C711  2  A0 01          LDY #1
00C713  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (address)
00C715  2  20 9E BE       JSR PrintDollar
00C718  2  20 7B BE       JSR PrintByte         ; display it
00C71B  2  20 C0 BE       JSR PrintCommaS
00C71E  2  4C 25 C8       JMP DONEOPS
00C721  2               
00C721  2               TRYDPIL:
00C721  2  C9 11          CMP #AM_DIRECT_PAGE_INDIRECT_LONG ; [WDC 65816 only]
00C723  2  D0 10          BNE TRYABSLONG
00C725  2  20 DA BE       JSR PrintLBraceDollar
00C728  2  A0 01          LDY #1
00C72A  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C72C  2  20 7B BE       JSR PrintByte         ; display it
00C72F  2  20 EF BE       JSR PrintRBrace
00C732  2  4C 25 C8       JMP DONEOPS
00C735  2               
00C735  2               TRYABSLONG:
00C735  2  C9 12          CMP #AM_ABSOLUTE_LONG ; [WDC 65816 only]
00C737  2  D0 1B          BNE SRIIY
00C739  2  20 9E BE       JSR PrintDollar
00C73C  2  A0 03          LDY #3
00C73E  2  B1 38          LDA (ADDR),Y          ; get 3nd operand byte (bank address)
00C740  2  20 7B BE       JSR PrintByte         ; display it
00C743  2  A0 02          LDY #2
00C745  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C747  2  20 7B BE       JSR PrintByte         ; display it
00C74A  2  A0 01          LDY #1
00C74C  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C74E  2  20 7B BE       JSR PrintByte         ; display it
00C751  2  4C 25 C8       JMP DONEOPS
00C754  2               
00C754  2               SRIIY:
00C754  2  C9 13          CMP #AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; [WDC 65816 only]
00C756  2  D0 16          BNE DPILIY
00C758  2  20 CD BE       JSR PrintLParenDollar
00C75B  2  A0 01          LDY #1
00C75D  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C75F  2  20 7B BE       JSR PrintByte         ; display it
00C762  2  20 C0 BE       JSR PrintCommaS
00C765  2  20 E7 BE       JSR PrintRParen
00C768  2  20 B3 BE       JSR PrintCommaY
00C76B  2  4C 25 C8       JMP DONEOPS
00C76E  2               
00C76E  2               DPILIY:
00C76E  2  C9 14          CMP #AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; [WDC 65816 only]
00C770  2  D0 13          BNE ALIX
00C772  2  20 DA BE       JSR PrintLBraceDollar
00C775  2  A0 01          LDY #1
00C777  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C779  2  20 7B BE       JSR PrintByte         ; display it
00C77C  2  20 EF BE       JSR PrintRBrace
00C77F  2  20 B3 BE       JSR PrintCommaY
00C782  2  4C 25 C8       JMP DONEOPS
00C785  2               
00C785  2               ALIX:
00C785  2  C9 15          CMP #AM_ABSOLUTE_LONG_INDEXED_WITH_X ; [WDC 65816 only]
00C787  2  D0 1E          BNE BLOCKMOVE
00C789  2  20 9E BE       JSR PrintDollar
00C78C  2  A0 03          LDY #3
00C78E  2  B1 38          LDA (ADDR),Y          ; get 3nd operand byte (bank address)
00C790  2  20 7B BE       JSR PrintByte         ; display it
00C793  2  A0 02          LDY #2
00C795  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C797  2  20 7B BE       JSR PrintByte         ; display it
00C79A  2  A0 01          LDY #1
00C79C  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C79E  2  20 7B BE       JSR PrintByte         ; display it
00C7A1  2  20 A6 BE       JSR PrintCommaX
00C7A4  2  4C 25 C8       JMP DONEOPS
00C7A7  2               
00C7A7  2               BLOCKMOVE:
00C7A7  2  C9 16          CMP #AM_BLOCK_MOVE ; [WDC 65816 only]
00C7A9  2  D0 1C          BNE PCRL
00C7AB  2  20 9E BE       JSR PrintDollar
00C7AE  2  A0 01          LDY #1
00C7B0  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
00C7B2  2  20 7B BE       JSR PrintByte         ; display it
00C7B5  2  A9 2C          LDA #','
00C7B7  2  20 8E BE       JSR PrintChar
00C7BA  2  20 9E BE       JSR PrintDollar
00C7BD  2  A0 02          LDY #2
00C7BF  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00C7C1  2  20 7B BE       JSR PrintByte         ; display it
00C7C4  2  4C 25 C8       JMP DONEOPS
00C7C7  2               
00C7C7  2               PCRL:
00C7C7  2  C9 17          CMP #AM_PROGRAM_COUNTER_RELATIVE_LONG ; [WDC 65816 only]
00C7C9  2  D0 3F          BNE AIL
00C7CB  2  20 9E BE       JSR PrintDollar
00C7CE  2               ; Handle relative addressing
00C7CE  2               ; Destination address is current address + relative + 3
00C7CE  2  A0 01          LDY #1
00C7D0  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte
00C7D2  2  8D 8C 17       STA REL               ; save low byte of offset
00C7D5  2  A0 02          LDY #2
00C7D7  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte
00C7D9  2  8D 8D 17       STA REL+1             ; save offset high byte
00C7DC  2  A5 38          LDA ADDR              ; take adresss
00C7DE  2  18             CLC
00C7DF  2  6D 8C 17       ADC REL               ; add offset
00C7E2  2  8D 8E 17       STA DEZT              ; and store
00C7E5  2  A5 39          LDA ADDR+1            ; also high byte (including carry)
00C7E7  2  6D 8D 17       ADC REL+1
00C7EA  2  8D 8F 17       STA DEZT+1
00C7ED  2  AD 8E 17       LDA DEZT              ; now need to add 3 more to the address
00C7F0  2  18             CLC
00C7F1  2  69 03          ADC #3
00C7F3  2  8D 8E 17       STA DEZT
00C7F6  2  AD 8F 17       LDA DEZT+1
00C7F9  2  69 00          ADC #0                ; add any carry
00C7FB  2  8D 8F 17       STA DEZT+1
00C7FE  2  20 7B BE       JSR PrintByte         ; display high byte
00C801  2  AD 8E 17       LDA DEZT
00C804  2  20 7B BE       JSR PrintByte         ; display low byte
00C807  2  4C 25 C8       JMP DONEOPS
00C80A  2               
00C80A  2               AIL:
00C80A  2  C9 18          CMP #AM_ABSOLUTE_INDIRECT_LONG ; [WDC 65816 only]
00C80C  2  D0 17          BNE DONEOPS
00C80E  2  20 DA BE       JSR PrintLBraceDollar
00C811  2  A0 02          LDY #2
00C813  2  B1 38          LDA (ADDR),Y          ; get 2nd operand byte (high address)
00C815  2  20 7B BE       JSR PrintByte         ; display it
00C818  2  A0 01          LDY #1
00C81A  2  B1 38          LDA (ADDR),Y          ; get 1st operand byte (low address)
00C81C  2  20 7B BE       JSR PrintByte         ; display it
00C81F  2  20 EF BE       JSR PrintRBrace
00C822  2  4C 25 C8       JMP DONEOPS
00C825  2               
00C825  2               DONEOPS:
00C825  2  20 13 BE       JSR PrintCR           ; print a final CR
00C828  2  A5 38          LDA ADDR              ; update address to next instruction
00C82A  2  18             CLC
00C82B  2  6D 8B 17       ADC LEN
00C82E  2  85 38          STA ADDR
00C830  2  A5 39          LDA ADDR+1
00C832  2  69 00          ADC #0                ; to add carry
00C834  2  85 39          STA ADDR+1
00C836  2  60             RTS
00C837  2               
00C837  2               ; DATA
00C837  2               
00C837  2               ; Table of instruction strings. 3 bytes per table entry
00C837  2                .export MNEMONICS1
00C837  2               MNEMONICS:
00C837  2               MNEMONICS1:
00C837  2  3F 3F 3F      .byte "???" ; $00
00C83A  2  41 44 43      .byte "ADC" ; $01
00C83D  2  41 4E 44      .byte "AND" ; $02
00C840  2  41 53 4C      .byte "ASL" ; $03
00C843  2  42 43 43      .byte "BCC" ; $04
00C846  2  42 43 53      .byte "BCS" ; $05
00C849  2  42 45 51      .byte "BEQ" ; $06
00C84C  2  42 49 54      .byte "BIT" ; $07
00C84F  2  42 4D 49      .byte "BMI" ; $08
00C852  2  42 4E 45      .byte "BNE" ; $09
00C855  2  42 50 4C      .byte "BPL" ; $0A
00C858  2  42 52 4B      .byte "BRK" ; $0B
00C85B  2  42 56 43      .byte "BVC" ; $0C
00C85E  2  42 56 53      .byte "BVS" ; $0D
00C861  2  43 4C 43      .byte "CLC" ; $0E
00C864  2  43 4C 44      .byte "CLD" ; $0F
00C867  2  43 4C 49      .byte "CLI" ; $10
00C86A  2  43 4C 56      .byte "CLV" ; $11
00C86D  2  43 4D 50      .byte "CMP" ; $12
00C870  2  43 50 58      .byte "CPX" ; $13
00C873  2  43 50 59      .byte "CPY" ; $14
00C876  2  44 45 43      .byte "DEC" ; $15
00C879  2  44 45 58      .byte "DEX" ; $16
00C87C  2  44 45 59      .byte "DEY" ; $17
00C87F  2  45 4F 52      .byte "EOR" ; $18
00C882  2  49 4E 43      .byte "INC" ; $19
00C885  2  49 4E 58      .byte "INX" ; $1A
00C888  2  49 4E 59      .byte "INY" ; $1B
00C88B  2  4A 4D 50      .byte "JMP" ; $1C
00C88E  2  4A 53 52      .byte "JSR" ; $1D
00C891  2  4C 44 41      .byte "LDA" ; $1E
00C894  2  4C 44 58      .byte "LDX" ; $1F
00C897  2  4C 44 59      .byte "LDY" ; $20
00C89A  2  4C 53 52      .byte "LSR" ; $21
00C89D  2  4E 4F 50      .byte "NOP" ; $22
00C8A0  2  4F 52 41      .byte "ORA" ; $23
00C8A3  2  50 48 41      .byte "PHA" ; $24
00C8A6  2  50 48 50      .byte "PHP" ; $25
00C8A9  2  50 4C 41      .byte "PLA" ; $26
00C8AC  2  50 4C 50      .byte "PLP" ; $27
00C8AF  2  52 4F 4C      .byte "ROL" ; $28
00C8B2  2  52 4F 52      .byte "ROR" ; $29
00C8B5  2  52 54 49      .byte "RTI" ; $2A
00C8B8  2  52 54 53      .byte "RTS" ; $2B
00C8BB  2  53 42 43      .byte "SBC" ; $2C
00C8BE  2  53 45 43      .byte "SEC" ; $2D
00C8C1  2  53 45 44      .byte "SED" ; $2E
00C8C4  2  53 45 49      .byte "SEI" ; $2F
00C8C7  2  53 54 41      .byte "STA" ; $30
00C8CA  2  53 54 58      .byte "STX" ; $31
00C8CD  2  53 54 59      .byte "STY" ; $32
00C8D0  2  54 41 58      .byte "TAX" ; $33
00C8D3  2  54 41 59      .byte "TAY" ; $34
00C8D6  2  54 53 58      .byte "TSX" ; $35
00C8D9  2  54 58 41      .byte "TXA" ; $36
00C8DC  2  54 58 53      .byte "TXS" ; $37
00C8DF  2  54 59 41      .byte "TYA" ; $38
00C8E2  2  42 42 52      .byte "BBR" ; $39 [65C02 only]
00C8E5  2  42 42 53      .byte "BBS" ; $3A [65C02 only]
00C8E8  2  42 52 41      .byte "BRA" ; $3B [65C02 only]
00C8EB  2  50 48 58      .byte "PHX" ; $3C [65C02 only]
00C8EE  2  50 48 59      .byte "PHY" ; $3D [65C02 only]
00C8F1  2  50 4C 58      .byte "PLX" ; $3E [65C02 only]
00C8F4  2  50 4C 59      .byte "PLY" ; $3F [65C02 only]
00C8F7  2  52 4D 42      .byte "RMB" ; $40 [65C02 only]
00C8FA  2  53 4D 42      .byte "SMB" ; $41 [65C02 only]
00C8FD  2  53 54 5A      .byte "STZ" ; $42 [65C02 only]
00C900  2  54 52 42      .byte "TRB" ; $43 [65C02 only]
00C903  2  54 53 42      .byte "TSB" ; $44 [65C02 only]
00C906  2  53 54 50      .byte "STP" ; $45 [WDC 65C02 and 65816 only]
00C909  2  57 41 49      .byte "WAI" ; $46 [WDC 65C02 and 65816 only]
00C90C  2  42 52 4C      .byte "BRL" ; $47 [WDC 65816 only]
00C90F  2  43 4F 50      .byte "COP" ; $48 [WDC 65816 only]
00C912  2  4A 4D 50      .byte "JMP" ; $49 [WDC 65816 only]
00C915  2  4A 53 4C      .byte "JSL" ; $4A [WDC 65816 only]
00C918  2  4D 56 4E      .byte "MVN" ; $4B [WDC 65816 only]
00C91B  2  4D 56 50      .byte "MVP" ; $4C [WDC 65816 only]
00C91E  2  50 45 41      .byte "PEA" ; $4D [WDC 65816 only]
00C921  2  50 45 49      .byte "PEI" ; $4E [WDC 65816 only]
00C924  2  50 45 52      .byte "PER" ; $4F [WDC 65816 only]
00C927  2  50 48 42      .byte "PHB" ; $50 [WDC 65816 only]
00C92A  2  50 48 44      .byte "PHD" ; $51 [WDC 65816 only]
00C92D  2  50 48 4B      .byte "PHK" ; $52 [WDC 65816 only]
00C930  2  50 4C 42      .byte "PLB" ; $53 [WDC 65816 only]
00C933  2  50 4C 44      .byte "PLD" ; $54 [WDC 65816 only]
00C936  2               MNEMONICS2:
00C936  2  3F 3F 3F      .byte "???" ; $55 Unused because index is $FF
00C939  2  52 45 50      .byte "REP" ; $56 [WDC 65816 only]
00C93C  2  52 54 4C      .byte "RTL" ; $57 [WDC 65816 only]
00C93F  2  53 45 50      .byte "SEP" ; $58 [WDC 65816 only]
00C942  2  54 43 44      .byte "TCD" ; $59 [WDC 65816 only]
00C945  2  54 43 53      .byte "TCS" ; $5A [WDC 65816 only]
00C948  2  54 44 43      .byte "TDC" ; $5B [WDC 65816 only]
00C94B  2  54 53 43      .byte "TSC" ; $5C [WDC 65816 only]
00C94E  2  54 58 59      .byte "TXY" ; $5D [WDC 65816 only]
00C951  2  54 59 58      .byte "TYX" ; $5E [WDC 65816 only]
00C954  2  57 44 4D      .byte "WDM" ; $5F [WDC 65816 only]
00C957  2  58 42 41      .byte "XBA" ; $60 [WDC 65816 only]
00C95A  2  58 43 45      .byte "XCE" ; $61 [WDC 65816 only]
00C95D  2               MNEMONICSEND: ; address of the end of the table
00C95D  2               
00C95D  2               ; Lengths of instructions given an addressing mode. Matches values of AM_*
00C95D  2               ; Assumes 65816 is in 8-bit mode.
00C95D  2               LENGTHS:
00C95D  2  01 01 01 02   .byte 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 4, 2, 2, 4, 3, 3, 3
00C961  2  02 02 02 02  
00C965  2  03 03 03 03  
00C976  2               
00C976  2               ; Opcodes. Listed in order. Defines the mnemonic and addressing mode.
00C976  2               ; 2 bytes per table entry
00C976  2                .export OPCODES1
00C976  2               OPCODES:
00C976  2               OPCODES1:
00C976  2  0B 01         .byte OP_BRK, AM_IMPLICIT           ; $00
00C978  2               
00C978  2  23 0C         .byte OP_ORA, AM_INDEXED_INDIRECT   ; $01
00C97A  2               
00C97A  2               .ifdef D65816
00C97A  2                .byte OP_COP, AM_ZEROPAGE           ; $02 [WDC 65816 only]
00C97A  2               .else
00C97A  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $02
00C97C  2               .endif
00C97C  2               
00C97C  2               .ifdef D65816
00C97C  2                .byte OP_ORA, AM_STACK_RELATIVE     ; $03 [WDC 65816 only]
00C97C  2               .else
00C97C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $03
00C97E  2               .endif
00C97E  2               
00C97E  2               .ifdef D65C02
00C97E  2  44 04         .byte OP_TSB, AM_ZEROPAGE           ; $04 [65C02 only]
00C980  2               .else
00C980  2                .byte OP_INV, AM_IMPLICIT           ; $04
00C980  2               .endif
00C980  2               
00C980  2  23 04         .byte OP_ORA, AM_ZEROPAGE           ; $05
00C982  2               
00C982  2  03 04         .byte OP_ASL, AM_ZEROPAGE           ; $06
00C984  2               
00C984  2               .ifdef ROCKWELL
00C984  2                .byte OP_RMB, AM_ZEROPAGE           ; $07 [65C02 only]
00C984  2               .elseif .defined(D65816)
00C984  2                .byte OP_ORA, AM_DIRECT_PAGE_INDIRECT_LONG ; $07 [WDC 65816 only]
00C984  2               .else
00C984  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $07
00C986  2               .endif
00C986  2               
00C986  2  25 01         .byte OP_PHP, AM_IMPLICIT           ; $08
00C988  2               
00C988  2  23 03         .byte OP_ORA, AM_IMMEDIATE          ; $09
00C98A  2               
00C98A  2  03 02         .byte OP_ASL, AM_ACCUMULATOR        ; $0A
00C98C  2               
00C98C  2               .ifdef D65816
00C98C  2                .byte OP_PHD, AM_IMPLICIT           ; $0B [WDC 65816 only]
00C98C  2               .else
00C98C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $0B
00C98E  2               .endif
00C98E  2               
00C98E  2               .ifdef D65C02
00C98E  2  44 08         .byte OP_TSB, AM_ABSOLUTE           ; $0C [65C02 only]
00C990  2               .else
00C990  2                .byte OP_INV, AM_IMPLICIT           ; $0C
00C990  2               .endif
00C990  2               
00C990  2  23 08         .byte OP_ORA, AM_ABSOLUTE           ; $0D
00C992  2               
00C992  2  03 08         .byte OP_ASL, AM_ABSOLUTE           ; $0E
00C994  2               
00C994  2               .ifdef ROCKWELL
00C994  2                .byte OP_BBR, AM_ABSOLUTE           ; $0F [65C02 only]
00C994  2               .elseif .defined(D65816)
00C994  2                .byte OP_ORA, AM_ABSOLUTE_LONG      ; $0F [WDC 65816 only]
00C994  2               .else
00C994  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $0F
00C996  2               .endif
00C996  2               
00C996  2  0A 07         .byte OP_BPL, AM_RELATIVE           ; $10
00C998  2               
00C998  2  23 0D         .byte OP_ORA, AM_INDIRECT_INDEXED   ; $11
00C99A  2               
00C99A  2               .ifdef D65C02
00C99A  2  23 0E         .byte OP_ORA, AM_INDIRECT_ZEROPAGE  ; $12 [65C02 only]
00C99C  2               .else
00C99C  2                .byte OP_INV, AM_IMPLICIT           ; $12
00C99C  2               .endif
00C99C  2               
00C99C  2               .ifdef D65816
00C99C  2                .byte OP_ORA, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $13 [WDC 65816 only]
00C99C  2               .else
00C99C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $12
00C99E  2               .endif
00C99E  2               
00C99E  2               .ifdef D65C02
00C99E  2  43 04         .byte OP_TRB, AM_ZEROPAGE           ; $14 [65C02 only]
00C9A0  2               .else
00C9A0  2                .byte OP_INV, AM_IMPLICIT           ; $12
00C9A0  2               .endif
00C9A0  2               
00C9A0  2  23 05         .byte OP_ORA, AM_ZEROPAGE_X         ; $15
00C9A2  2               
00C9A2  2  03 05         .byte OP_ASL, AM_ZEROPAGE_X         ; $16
00C9A4  2               
00C9A4  2               .ifdef ROCKWELL
00C9A4  2                .byte OP_RMB, AM_ZEROPAGE           ; $17 [65C02 only]
00C9A4  2               .elseif .defined(D65816)
00C9A4  2                .byte OP_ORA, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $17 [WDC 65816 only]
00C9A4  2               .else
00C9A4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $17
00C9A6  2               .endif
00C9A6  2               
00C9A6  2  0E 01         .byte OP_CLC, AM_IMPLICIT           ; $18
00C9A8  2               
00C9A8  2  23 0A         .byte OP_ORA, AM_ABSOLUTE_Y         ; $19
00C9AA  2               
00C9AA  2               .ifdef D65C02
00C9AA  2  19 02         .byte OP_INC, AM_ACCUMULATOR        ; $1A [65C02 only]
00C9AC  2               .else
00C9AC  2                .byte OP_INV, AM_IMPLICIT           ; $1A
00C9AC  2               .endif
00C9AC  2               
00C9AC  2               .ifdef D65816
00C9AC  2                .byte OP_TCS, AM_IMPLICIT           ; $1B [WDC 65816 only]
00C9AC  2               .else
00C9AC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $1B
00C9AE  2               .endif
00C9AE  2               
00C9AE  2               .ifdef D65C02
00C9AE  2  43 08         .byte OP_TRB, AM_ABSOLUTE           ; $1C [65C02 only]
00C9B0  2               .else
00C9B0  2                .byte OP_INV, AM_IMPLICIT           ; $1C
00C9B0  2               .endif
00C9B0  2               
00C9B0  2  23 09         .byte OP_ORA, AM_ABSOLUTE_X         ; $1D
00C9B2  2               
00C9B2  2  03 09         .byte OP_ASL, AM_ABSOLUTE_X         ; $1E
00C9B4  2               
00C9B4  2               .ifdef ROCKWELL
00C9B4  2                .byte OP_BBR, AM_ABSOLUTE           ; $1F [65C02 only]
00C9B4  2               .elseif .defined(D65816)
00C9B4  2                .byte OP_ORA, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $1F [WDC 65816 only]
00C9B4  2               .else
00C9B4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $1F
00C9B6  2               .endif
00C9B6  2               
00C9B6  2  1D 08         .byte OP_JSR, AM_ABSOLUTE           ; $20
00C9B8  2               
00C9B8  2  02 0C         .byte OP_AND, AM_INDEXED_INDIRECT   ; $21
00C9BA  2               
00C9BA  2  1D 12         .byte OP_JSR, AM_ABSOLUTE_LONG      ; $22
00C9BC  2               
00C9BC  2  02 10         .byte OP_AND, AM_STACK_RELATIVE     ; $23
00C9BE  2               
00C9BE  2  07 04         .byte OP_BIT, AM_ZEROPAGE           ; $24
00C9C0  2               
00C9C0  2  02 04         .byte OP_AND, AM_ZEROPAGE           ; $25
00C9C2  2               
00C9C2  2  28 04         .byte OP_ROL, AM_ZEROPAGE           ; $26
00C9C4  2               
00C9C4  2               .ifdef ROCKWELL
00C9C4  2                .byte OP_RMB, AM_ZEROPAGE           ; $27 [65C02 only]
00C9C4  2               .elseif .defined (D65816)
00C9C4  2                .byte OP_AND, AM_DIRECT_PAGE_INDIRECT_LONG ; $27 [WDC 65816 only]
00C9C4  2               .else
00C9C4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $27
00C9C6  2               .endif
00C9C6  2               
00C9C6  2  27 01         .byte OP_PLP, AM_IMPLICIT           ; $28
00C9C8  2               
00C9C8  2  02 03         .byte OP_AND, AM_IMMEDIATE          ; $29
00C9CA  2               
00C9CA  2  28 02         .byte OP_ROL, AM_ACCUMULATOR        ; $2A
00C9CC  2               
00C9CC  2               .ifdef D65816
00C9CC  2                .byte OP_PLD, AM_IMPLICIT           ; $2B [WDC 65816 only]
00C9CC  2               .else
00C9CC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $2B
00C9CE  2               .endif
00C9CE  2               
00C9CE  2  07 08         .byte OP_BIT, AM_ABSOLUTE           ; $2C
00C9D0  2               
00C9D0  2  02 08         .byte OP_AND, AM_ABSOLUTE           ; $2D
00C9D2  2               
00C9D2  2  28 08         .byte OP_ROL, AM_ABSOLUTE           ; $2E
00C9D4  2               
00C9D4  2               .ifdef ROCKWELL
00C9D4  2                .byte OP_BBR, AM_ABSOLUTE           ; $2F [65C02 only]
00C9D4  2               .elseif .defined (D65816)
00C9D4  2                .byte OP_AND, AM_ABSOLUTE_LONG      ; $2F [WDC 65816 only]
00C9D4  2               .else
00C9D4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $2F
00C9D6  2               .endif
00C9D6  2               
00C9D6  2  08 07         .byte OP_BMI, AM_RELATIVE           ; $30
00C9D8  2               
00C9D8  2               .ifdef D65C02
00C9D8  2  02 0D         .byte OP_AND, AM_INDIRECT_INDEXED   ; $31 [65C02 only]
00C9DA  2               .else
00C9DA  2                .byte OP_INV, AM_IMPLICIT           ; $31
00C9DA  2               .endif
00C9DA  2               
00C9DA  2               .ifdef D65C02
00C9DA  2  02 0E         .byte OP_AND, AM_INDIRECT_ZEROPAGE  ; $32 [65C02 only]
00C9DC  2               .else
00C9DC  2                .byte OP_INV, AM_IMPLICIT           ; $32
00C9DC  2               .endif
00C9DC  2               
00C9DC  2               .ifdef D65816
00C9DC  2                .byte OP_AND, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $33 [WDC 65816 only]
00C9DC  2               .else
00C9DC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $33
00C9DE  2               .endif
00C9DE  2               
00C9DE  2               .ifdef D65C02
00C9DE  2  07 05         .byte OP_BIT, AM_ZEROPAGE_X         ; $34 [65C02 only]
00C9E0  2               .else
00C9E0  2                .byte OP_INV, AM_IMPLICIT           ; $34
00C9E0  2               .endif
00C9E0  2               
00C9E0  2  02 05         .byte OP_AND, AM_ZEROPAGE_X         ; $35
00C9E2  2               
00C9E2  2  28 05         .byte OP_ROL, AM_ZEROPAGE_X         ; $36
00C9E4  2               
00C9E4  2               .ifdef ROCKWELL
00C9E4  2                .byte OP_RMB, AM_ZEROPAGE           ; $37 [65C02 only]
00C9E4  2               .elseif .defined(D65816)
00C9E4  2                .byte OP_AND, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $37 [WDC 65816 only]
00C9E4  2               .else
00C9E4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $37
00C9E6  2               .endif
00C9E6  2               
00C9E6  2  2D 01         .byte OP_SEC, AM_IMPLICIT           ; $38
00C9E8  2               
00C9E8  2  02 0A         .byte OP_AND, AM_ABSOLUTE_Y         ; $39
00C9EA  2               
00C9EA  2               .ifdef D65C02
00C9EA  2  15 02         .byte OP_DEC, AM_ACCUMULATOR        ; $3A [65C02 only]
00C9EC  2               .else
00C9EC  2                .byte OP_INV, AM_IMPLICIT           ; $3A
00C9EC  2               .endif
00C9EC  2               
00C9EC  2               .ifdef D65816
00C9EC  2                .byte OP_TSC, AM_IMPLICIT           ; $3B [WDC 65816 only]
00C9EC  2               .else
00C9EC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $3B
00C9EE  2               .endif
00C9EE  2               
00C9EE  2               .ifdef D65C02
00C9EE  2  07 09         .byte OP_BIT, AM_ABSOLUTE_X         ; $3C [65C02 only]
00C9F0  2               .else
00C9F0  2                .byte OP_INV, AM_IMPLICIT           ; $3C
00C9F0  2               .endif
00C9F0  2               
00C9F0  2  02 09         .byte OP_AND, AM_ABSOLUTE_X         ; $3D
00C9F2  2               
00C9F2  2  28 09         .byte OP_ROL, AM_ABSOLUTE_X         ; $3E
00C9F4  2               
00C9F4  2               .ifdef ROCKWELL
00C9F4  2                .byte OP_BBR, AM_ABSOLUTE           ; $3F [65C02 only]
00C9F4  2               .elseif .defined(D65816)
00C9F4  2                .byte OP_AND, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $3F [WDC 65816 only]
00C9F4  2               .else
00C9F4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $3F
00C9F6  2               .endif
00C9F6  2               
00C9F6  2  2A 01         .byte OP_RTI, AM_IMPLICIT           ; $40
00C9F8  2               
00C9F8  2  18 0C         .byte OP_EOR, AM_INDEXED_INDIRECT   ; $41
00C9FA  2               
00C9FA  2               .ifdef D65816
00C9FA  2                .byte OP_WDM, AM_ZEROPAGE           ; $42 [WDC 65816 only]
00C9FA  2               .else
00C9FA  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $42
00C9FC  2               .endif
00C9FC  2               
00C9FC  2               .ifdef D65816
00C9FC  2                .byte OP_EOR, AM_STACK_RELATIVE     ; $43 [WDC 65816 only]
00C9FC  2               .else
00C9FC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $43
00C9FE  2               .endif
00C9FE  2               
00C9FE  2               .ifdef D65816
00C9FE  2                .byte OP_MVP, AM_BLOCK_MOVE         ; $44 [WDC 65816 only]
00C9FE  2               .else
00C9FE  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $44
00CA00  2               .endif
00CA00  2               
00CA00  2  18 04         .byte OP_EOR, AM_ZEROPAGE           ; $45
00CA02  2               
00CA02  2  21 04         .byte OP_LSR, AM_ZEROPAGE           ; $46
00CA04  2               
00CA04  2               .ifdef ROCKWELL
00CA04  2                .byte OP_RMB, AM_ZEROPAGE           ; $47 [65C02 only]
00CA04  2               .elseif .defined(D65816)
00CA04  2                .byte OP_EOR, AM_DIRECT_PAGE_INDIRECT_LONG ; $47 [WDC 65816 only]
00CA04  2               .else
00CA04  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $47
00CA06  2               .endif
00CA06  2               
00CA06  2  24 01         .byte OP_PHA, AM_IMPLICIT           ; $48
00CA08  2               
00CA08  2  18 03         .byte OP_EOR, AM_IMMEDIATE          ; $49
00CA0A  2               
00CA0A  2  21 02         .byte OP_LSR, AM_ACCUMULATOR        ; $4A
00CA0C  2               
00CA0C  2               .ifdef D65816
00CA0C  2                .byte OP_PHK, AM_IMPLICIT           ; $4B [WDC 65816 only]
00CA0C  2               .else
00CA0C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4B
00CA0E  2               .endif
00CA0E  2               
00CA0E  2  1C 08         .byte OP_JMP, AM_ABSOLUTE           ; $4C
00CA10  2               
00CA10  2  18 08         .byte OP_EOR, AM_ABSOLUTE           ; $4D
00CA12  2               
00CA12  2  21 08         .byte OP_LSR, AM_ABSOLUTE           ; $4E
00CA14  2               
00CA14  2               .ifdef ROCKWELL
00CA14  2                .byte OP_BBR, AM_ABSOLUTE           ; $4F [65C02 only]
00CA14  2               .elseif .defined(D65816)
00CA14  2                .byte OP_EOR, AM_ABSOLUTE_LONG      ; $4F [WDC 65816 only]
00CA14  2               .else
00CA14  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA16  2               .endif
00CA16  2               
00CA16  2  0C 07         .byte OP_BVC, AM_RELATIVE           ; $50
00CA18  2               
00CA18  2  18 0D         .byte OP_EOR, AM_INDIRECT_INDEXED   ; $51
00CA1A  2               
00CA1A  2               .ifdef D65C02
00CA1A  2  18 0E         .byte OP_EOR, AM_INDIRECT_ZEROPAGE  ; $52 [65C02 only]
00CA1C  2               .else
00CA1C  2                .byte OP_INV, AM_IMPLICIT           ; $52
00CA1C  2               .endif
00CA1C  2               
00CA1C  2               .ifdef D65816
00CA1C  2                .byte OP_EOR, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $53 [WDC 65816 only]
00CA1C  2               .else
00CA1C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA1E  2               .endif
00CA1E  2               
00CA1E  2               .ifdef D65816
00CA1E  2                .byte OP_MVN, AM_BLOCK_MOVE         ; $54 [WDC 65816 only]
00CA1E  2               .else
00CA1E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA20  2               .endif
00CA20  2               
00CA20  2  18 05         .byte OP_EOR, AM_ZEROPAGE_X         ; $55
00CA22  2               
00CA22  2  21 05         .byte OP_LSR, AM_ZEROPAGE_X         ; $56
00CA24  2               
00CA24  2               .ifdef ROCKWELL
00CA24  2                .byte OP_RMB, AM_ZEROPAGE           ; $57 [65C02 only]
00CA24  2               .elseif .defined(D65816)
00CA24  2                .byte OP_EOR, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $57 [WDC 65816 only]
00CA24  2               .else
00CA24  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $57
00CA26  2               .endif
00CA26  2               
00CA26  2  10 01         .byte OP_CLI, AM_IMPLICIT           ; $58
00CA28  2               
00CA28  2  18 0A         .byte OP_EOR, AM_ABSOLUTE_Y         ; $59
00CA2A  2               
00CA2A  2               .ifdef D65C02
00CA2A  2  3D 01         .byte OP_PHY, AM_IMPLICIT           ; $5A [65C02 only]
00CA2C  2               .else
00CA2C  2                .byte OP_INV, AM_IMPLICIT           ; $5A
00CA2C  2               .endif
00CA2C  2               
00CA2C  2               .ifdef D65816
00CA2C  2                .byte OP_TCD, AM_IMPLICIT           ; $5B [WDC 65816 only]
00CA2C  2               .else
00CA2C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA2E  2               .endif
00CA2E  2               
00CA2E  2               .ifdef D65816
00CA2E  2                .byte OP_JML, AM_ABSOLUTE_LONG      ; $5C [WDC 65816 only]
00CA2E  2               .else
00CA2E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA30  2               .endif
00CA30  2               
00CA30  2  18 09         .byte OP_EOR, AM_ABSOLUTE_X         ; $5D
00CA32  2               
00CA32  2  21 09         .byte OP_LSR, AM_ABSOLUTE_X         ; $5E
00CA34  2               
00CA34  2               .ifdef ROCKWELL
00CA34  2                .byte OP_BBR, AM_ABSOLUTE           ; $5F [65C02 only]
00CA34  2               .elseif .defined(D65816)
00CA34  2                .byte OP_EOR, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $5F [WDC 65816 only]
00CA34  2               .else
00CA34  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $5F
00CA36  2               .endif
00CA36  2               
00CA36  2  2B 01         .byte OP_RTS, AM_IMPLICIT           ; $60
00CA38  2               
00CA38  2  01 0C         .byte OP_ADC, AM_INDEXED_INDIRECT   ; $61
00CA3A  2               
00CA3A  2               .ifdef D65816
00CA3A  2                .byte OP_PER, AM_PROGRAM_COUNTER_RELATIVE_LONG ; $62 [WDC 65816 only]
00CA3A  2               .else
00CA3A  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA3C  2               .endif
00CA3C  2               
00CA3C  2               .ifdef D65816
00CA3C  2                .byte OP_ADC, AM_STACK_RELATIVE     ; $63 [WDC 65816 only]
00CA3C  2               .else
00CA3C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA3E  2               .endif
00CA3E  2               
00CA3E  2               .ifdef D65C02
00CA3E  2  42 04         .byte OP_STZ, AM_ZEROPAGE           ; $64 [65C02 only]
00CA40  2               .else
00CA40  2                .byte OP_INV, AM_IMPLICIT           ; $64
00CA40  2               .endif
00CA40  2               
00CA40  2  01 04         .byte OP_ADC, AM_ZEROPAGE           ; $65
00CA42  2               
00CA42  2  29 04         .byte OP_ROR, AM_ZEROPAGE           ; $66
00CA44  2               
00CA44  2               .ifdef ROCKWELL
00CA44  2                .byte OP_RMB, AM_ZEROPAGE           ; $67 [65C02 only]
00CA44  2               .elseif .defined(D65816)
00CA44  2                .byte OP_ADC, AM_DIRECT_PAGE_INDIRECT_LONG ; $67 [WDC 65816 only]
00CA44  2               .else
00CA44  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $67
00CA46  2               .endif
00CA46  2               
00CA46  2  26 01         .byte OP_PLA, AM_IMPLICIT           ; $68
00CA48  2               
00CA48  2  01 03         .byte OP_ADC, AM_IMMEDIATE          ; $69
00CA4A  2               
00CA4A  2  29 02         .byte OP_ROR, AM_ACCUMULATOR        ; $6A
00CA4C  2               
00CA4C  2               .ifdef D65816
00CA4C  2                .byte OP_RTL, AM_IMPLICIT           ; $6B [WDC 65816 only]
00CA4C  2               .else
00CA4C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA4E  2               .endif
00CA4E  2               
00CA4E  2  1C 0B         .byte OP_JMP, AM_INDIRECT           ; $6C
00CA50  2               
00CA50  2  01 08         .byte OP_ADC, AM_ABSOLUTE           ; $6D
00CA52  2               
00CA52  2  29 08         .byte OP_ROR, AM_ABSOLUTE           ; $6E
00CA54  2               
00CA54  2               .ifdef ROCKWELL
00CA54  2                .byte OP_BBR, AM_ABSOLUTE           ; $6F [65C02 only]
00CA54  2               .elseif .defined(D65816)
00CA54  2                .byte OP_ADC, AM_ABSOLUTE_LONG      ; $6F [WDC 65816 only]
00CA54  2               .else
00CA54  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $6F
00CA56  2               .endif
00CA56  2               
00CA56  2  0D 07         .byte OP_BVS, AM_RELATIVE           ; $70
00CA58  2               
00CA58  2  01 0D         .byte OP_ADC, AM_INDIRECT_INDEXED   ; $71
00CA5A  2               
00CA5A  2               .ifdef D65C02
00CA5A  2  01 0E         .byte OP_ADC, AM_INDIRECT_ZEROPAGE  ; $72 [65C02 only]
00CA5C  2               .else
00CA5C  2                .byte OP_INV, AM_IMPLICIT           ; $4F
00CA5C  2               .endif
00CA5C  2               
00CA5C  2               .ifdef D65816
00CA5C  2                .byte OP_ADC, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $73 [WDC 65816 only]
00CA5C  2               .else
00CA5C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA5E  2               .endif
00CA5E  2               
00CA5E  2               .ifdef D65C02
00CA5E  2  42 05         .byte OP_STZ, AM_ZEROPAGE_X         ; $74 [65C02 only]
00CA60  2               .else
00CA60  2                .byte OP_INV, AM_IMPLICIT           ; $74
00CA60  2               .endif
00CA60  2               
00CA60  2  01 05         .byte OP_ADC, AM_ZEROPAGE_X         ; $75
00CA62  2               
00CA62  2  29 05         .byte OP_ROR, AM_ZEROPAGE_X         ; $76
00CA64  2               
00CA64  2               .ifdef ROCKWELL
00CA64  2                .byte OP_RMB, AM_ZEROPAGE           ; $77 [65C02 only]
00CA64  2               .elseif .defined(D65816)
00CA64  2                .byte OP_ADC, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $77 [WDC 65816 only]
00CA64  2               .else
00CA64  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $77
00CA66  2               .endif
00CA66  2               
00CA66  2  2F 01         .byte OP_SEI, AM_IMPLICIT           ; $78
00CA68  2               
00CA68  2  01 0A         .byte OP_ADC, AM_ABSOLUTE_Y         ; $79
00CA6A  2               
00CA6A  2               .ifdef D65C02
00CA6A  2  3F 01         .byte OP_PLY, AM_IMPLICIT           ; $7A [65C02 only]
00CA6C  2               .else
00CA6C  2                .byte OP_INV, AM_IMPLICIT           ; $7A
00CA6C  2               .endif
00CA6C  2               
00CA6C  2               .ifdef D65816
00CA6C  2                .byte OP_TDC, AM_IMPLICIT           ; $7B [WDC 65816 only]
00CA6C  2               .else
00CA6C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA6E  2               .endif
00CA6E  2               
00CA6E  2               .ifdef D65C02
00CA6E  2  1C 0F         .byte OP_JMP, AM_ABSOLUTE_INDEXED_INDIRECT ; $7C [65C02 only]
00CA70  2               .else
00CA70  2                .byte OP_INV, AM_IMPLICIT           ; $7C
00CA70  2               .endif
00CA70  2               
00CA70  2  01 09         .byte OP_ADC, AM_ABSOLUTE_X         ; $7D
00CA72  2               
00CA72  2  29 09         .byte OP_ROR, AM_ABSOLUTE_X         ; $7E
00CA74  2               
00CA74  2               .ifdef ROCKWELL
00CA74  2                .byte OP_BBR, AM_ABSOLUTE           ; $7F [65C02 only]
00CA74  2               .elseif .defined(D65816)
00CA74  2                .byte OP_ADC, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $7F [WDC 65816 only]
00CA74  2               .else
00CA74  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $7F
00CA76  2               .endif
00CA76  2               
00CA76  2                .export OPCODES2
00CA76  2               
00CA76  2               OPCODES2:
00CA76  2               
00CA76  2               .ifdef D65C02
00CA76  2  3B 07         .byte OP_BRA, AM_RELATIVE           ; $80 [65C02 only]
00CA78  2               .else
00CA78  2                .byte OP_INV, AM_IMPLICIT           ; $80
00CA78  2               .endif
00CA78  2               
00CA78  2  30 0C         .byte OP_STA, AM_INDEXED_INDIRECT   ; $81
00CA7A  2               
00CA7A  2               .ifdef D65816
00CA7A  2                .byte OP_BRL, AM_PROGRAM_COUNTER_RELATIVE_LONG ; $82 [WDC 65816 only]
00CA7A  2               .else
00CA7A  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA7C  2               .endif
00CA7C  2               
00CA7C  2               .ifdef D65816
00CA7C  2                .byte OP_STA, AM_STACK_RELATIVE     ; $83 [WDC 65816 only]
00CA7C  2               .else
00CA7C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA7E  2               .endif
00CA7E  2               
00CA7E  2  32 04         .byte OP_STY, AM_ZEROPAGE           ; $84
00CA80  2               
00CA80  2  30 04         .byte OP_STA, AM_ZEROPAGE           ; $85
00CA82  2               
00CA82  2  31 04         .byte OP_STX, AM_ZEROPAGE           ; $86
00CA84  2               
00CA84  2               .ifdef ROCKWELL
00CA84  2                .byte OP_SMB, AM_ZEROPAGE           ; $87 [65C02 only]
00CA84  2               .elseif .defined(D65816)
00CA84  2                .byte OP_STA, AM_DIRECT_PAGE_INDIRECT_LONG ; $87 [WDC 65816 only]
00CA84  2               .else
00CA84  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $87
00CA86  2               .endif
00CA86  2               
00CA86  2  17 01         .byte OP_DEY, AM_IMPLICIT           ; $88
00CA88  2               
00CA88  2               .ifdef D65C02
00CA88  2  07 03         .byte OP_BIT, AM_IMMEDIATE          ; $89 [65C02 only]
00CA8A  2               .else
00CA8A  2                .byte OP_INV, AM_IMPLICIT           ; $89
00CA8A  2               .endif
00CA8A  2               
00CA8A  2  36 01         .byte OP_TXA, AM_IMPLICIT           ; $8A
00CA8C  2               
00CA8C  2               .ifdef D65816
00CA8C  2                .byte OP_PHB, AM_IMPLICIT           ; $8B [WDC 65816 only]
00CA8C  2               .else
00CA8C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA8E  2               .endif
00CA8E  2               
00CA8E  2  32 08         .byte OP_STY, AM_ABSOLUTE           ; $8C
00CA90  2               
00CA90  2  30 08         .byte OP_STA, AM_ABSOLUTE           ; $8D
00CA92  2               
00CA92  2  31 08         .byte OP_STX, AM_ABSOLUTE           ; $8E
00CA94  2               
00CA94  2               .ifdef ROCKWELL
00CA94  2                .byte OP_BBS, AM_ABSOLUTE           ; $8F [65C02 only]
00CA94  2               .elseif .defined(D65816)
00CA94  2                .byte OP_STA, AM_ABSOLUTE_LONG      ; $8F [WDC 65816 only]
00CA94  2               .else
00CA94  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $8F
00CA96  2               .endif
00CA96  2               
00CA96  2  04 07         .byte OP_BCC, AM_RELATIVE           ; $90
00CA98  2               
00CA98  2  30 0D         .byte OP_STA, AM_INDIRECT_INDEXED   ; $91
00CA9A  2               
00CA9A  2               .ifdef D65C02
00CA9A  2  30 0E         .byte OP_STA, AM_INDIRECT_ZEROPAGE  ; $92 [65C02 only]
00CA9C  2               .else
00CA9C  2                .byte OP_INV, AM_IMPLICIT           ; $92
00CA9C  2               .endif
00CA9C  2               
00CA9C  2               .ifdef D65816
00CA9C  2                .byte OP_STA, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $93 [WDC 65816 only]
00CA9C  2               .else
00CA9C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CA9E  2               .endif
00CA9E  2               
00CA9E  2  32 05         .byte OP_STY, AM_ZEROPAGE_X         ; $94
00CAA0  2               
00CAA0  2  30 05         .byte OP_STA, AM_ZEROPAGE_X         ; $95
00CAA2  2               
00CAA2  2  31 06         .byte OP_STX, AM_ZEROPAGE_Y         ; $96
00CAA4  2               
00CAA4  2               .ifdef ROCKWELL
00CAA4  2                .byte OP_SMB, AM_ZEROPAGE           ; $97 [65C02 only]
00CAA4  2               .elseif .defined(D65816)
00CAA4  2                .byte OP_STA, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $97 [WDC 65816 only]
00CAA4  2               .else
00CAA4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $97
00CAA6  2               .endif
00CAA6  2               
00CAA6  2  38 01         .byte OP_TYA, AM_IMPLICIT           ; $98
00CAA8  2               
00CAA8  2  30 0A         .byte OP_STA, AM_ABSOLUTE_Y         ; $99
00CAAA  2               
00CAAA  2  37 01         .byte OP_TXS, AM_IMPLICIT           ; $9A
00CAAC  2               
00CAAC  2               .ifdef D65816
00CAAC  2                .byte OP_TXY, AM_IMPLICIT           ; $9B [WDC 65816 only]
00CAAC  2               .else
00CAAC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CAAE  2               .endif
00CAAE  2               
00CAAE  2               .ifdef D65C02
00CAAE  2  42 08         .byte OP_STZ, AM_ABSOLUTE           ; $9C [65C02 only]
00CAB0  2               .else
00CAB0  2                .byte OP_INV, AM_IMPLICIT           ; $9c
00CAB0  2               .endif
00CAB0  2               
00CAB0  2  30 09         .byte OP_STA, AM_ABSOLUTE_X         ; $9D
00CAB2  2               
00CAB2  2               .ifdef D65C02
00CAB2  2  42 09         .byte OP_STZ, AM_ABSOLUTE_X         ; $9E [65C02 only]
00CAB4  2               .else
00CAB4  2                .byte OP_INV, AM_IMPLICIT           ; $9E
00CAB4  2               .endif
00CAB4  2               
00CAB4  2               .ifdef ROCKWELL
00CAB4  2                .byte OP_BBS, AM_ABSOLUTE           ; $9F [65C02 only]
00CAB4  2               .elseif .defined(D65816)
00CAB4  2                .byte OP_STA, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $9F [WDC 65816 only]
00CAB4  2               .else
00CAB4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CAB6  2               .endif
00CAB6  2               
00CAB6  2  20 03         .byte OP_LDY, AM_IMMEDIATE          ; $A0
00CAB8  2               
00CAB8  2  1E 0C         .byte OP_LDA, AM_INDEXED_INDIRECT   ; $A1
00CABA  2               
00CABA  2  1F 03         .byte OP_LDX, AM_IMMEDIATE          ; $A2
00CABC  2               
00CABC  2               .ifdef D65816
00CABC  2                .byte OP_LDA, AM_STACK_RELATIVE     ; $A3 [WDC 65816 only]
00CABC  2               .else
00CABC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CABE  2               .endif
00CABE  2               
00CABE  2  20 04         .byte OP_LDY, AM_ZEROPAGE           ; $A4
00CAC0  2               
00CAC0  2  1E 04         .byte OP_LDA, AM_ZEROPAGE           ; $A5
00CAC2  2               
00CAC2  2  1F 04         .byte OP_LDX, AM_ZEROPAGE           ; $A6
00CAC4  2               
00CAC4  2               .ifdef ROCKWELL
00CAC4  2                .byte OP_SMB, AM_ZEROPAGE           ; $A7 [65C02 only]
00CAC4  2               .elseif .defined(D65816)
00CAC4  2                .byte OP_LDA, AM_DIRECT_PAGE_INDIRECT_LONG ; $A7 [WDC 65816 only]
00CAC4  2               .else
00CAC4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $A7
00CAC6  2               .endif
00CAC6  2               
00CAC6  2  34 01         .byte OP_TAY, AM_IMPLICIT           ; $A8
00CAC8  2               
00CAC8  2  1E 03         .byte OP_LDA, AM_IMMEDIATE          ; $A9
00CACA  2               
00CACA  2  33 01         .byte OP_TAX, AM_IMPLICIT           ; $AA
00CACC  2               
00CACC  2               .ifdef D65816
00CACC  2                .byte OP_PLB, AM_IMPLICIT           ; $AB [WDC 65816 only]
00CACC  2               .else
00CACC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CACE  2               .endif
00CACE  2               
00CACE  2  20 08         .byte OP_LDY, AM_ABSOLUTE           ; $AC
00CAD0  2               
00CAD0  2  1E 08         .byte OP_LDA, AM_ABSOLUTE           ; $AD
00CAD2  2               
00CAD2  2  1F 08         .byte OP_LDX, AM_ABSOLUTE           ; $AE
00CAD4  2               
00CAD4  2               .ifdef ROCKWELL
00CAD4  2                .byte OP_BBS, AM_ABSOLUTE           ; $AF [65C02 only]
00CAD4  2               .elseif .defined(D65816)
00CAD4  2                .byte OP_LDA, AM_ABSOLUTE_LONG      ; $AF [WDC 65816 only]
00CAD4  2               .else
00CAD4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CAD6  2               .endif
00CAD6  2               
00CAD6  2  05 07         .byte OP_BCS, AM_RELATIVE           ; $B0
00CAD8  2               
00CAD8  2  1E 0D         .byte OP_LDA, AM_INDIRECT_INDEXED   ; $B1
00CADA  2               
00CADA  2               .ifdef D65C02
00CADA  2  1E 0E         .byte OP_LDA, AM_INDIRECT_ZEROPAGE  ; $B2 [65C02 only]
00CADC  2               .else
00CADC  2                .byte OP_INV, AM_IMPLICIT           ; $B2
00CADC  2               .endif
00CADC  2               
00CADC  2               .ifdef D65816
00CADC  2                .byte OP_LDA, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $B3 [WDC 65816 only]
00CADC  2               .else
00CADC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CADE  2               .endif
00CADE  2               
00CADE  2  20 05         .byte OP_LDY, AM_ZEROPAGE_X         ; $B4
00CAE0  2               
00CAE0  2  1E 05         .byte OP_LDA, AM_ZEROPAGE_X         ; $B5
00CAE2  2               
00CAE2  2  1F 06         .byte OP_LDX, AM_ZEROPAGE_Y         ; $B6
00CAE4  2               
00CAE4  2               .ifdef ROCKWELL
00CAE4  2                .byte OP_SMB, AM_ZEROPAGE           ; $B7 [65C02 only]
00CAE4  2               .elseif .defined(D65816)
00CAE4  2                .byte OP_LDA, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $B7 [WDC 65816 only]
00CAE4  2               .else
00CAE4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $B7
00CAE6  2               .endif
00CAE6  2               
00CAE6  2  11 01         .byte OP_CLV, AM_IMPLICIT           ; $B8
00CAE8  2               
00CAE8  2  1E 0A         .byte OP_LDA, AM_ABSOLUTE_Y         ; $B9
00CAEA  2               
00CAEA  2  35 01         .byte OP_TSX, AM_IMPLICIT           ; $BA
00CAEC  2               
00CAEC  2               .ifdef D65816
00CAEC  2                .byte OP_TYX, AM_IMPLICIT           ; $BB [WDC 65816 only]
00CAEC  2               .else
00CAEC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CAEE  2               .endif
00CAEE  2               
00CAEE  2  20 09         .byte OP_LDY, AM_ABSOLUTE_X         ; $BC
00CAF0  2               
00CAF0  2  1E 09         .byte OP_LDA, AM_ABSOLUTE_X         ; $BD
00CAF2  2               
00CAF2  2  1F 0A         .byte OP_LDX, AM_ABSOLUTE_Y         ; $BE
00CAF4  2               
00CAF4  2               .ifdef ROCKWELL
00CAF4  2                .byte OP_BBS, AM_ABSOLUTE           ; $BF [65C02 only]
00CAF4  2               .elseif .defined(D65816)
00CAF4  2                .byte OP_LDA, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $BF [WDC 65816 only]
00CAF4  2               .else
00CAF4  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $BF
00CAF6  2               .endif
00CAF6  2               
00CAF6  2  14 03         .byte OP_CPY, AM_IMMEDIATE          ; $C0
00CAF8  2               
00CAF8  2  12 0C         .byte OP_CMP, AM_INDEXED_INDIRECT   ; $C1
00CAFA  2               
00CAFA  2               .ifdef D65816
00CAFA  2                .byte OP_REP, AM_IMMEDIATE          ; $C2 [WDC 65816 only]
00CAFA  2               .else
00CAFA  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CAFC  2               .endif
00CAFC  2               
00CAFC  2               .ifdef D65816
00CAFC  2                .byte OP_CMP, AM_STACK_RELATIVE     ; $C3 [WDC 65816 only]
00CAFC  2               .else
00CAFC  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CAFE  2               .endif
00CAFE  2               
00CAFE  2  14 04         .byte OP_CPY, AM_ZEROPAGE           ; $C4
00CB00  2               
00CB00  2  12 04         .byte OP_CMP, AM_ZEROPAGE           ; $C5
00CB02  2               
00CB02  2  15 04         .byte OP_DEC, AM_ZEROPAGE           ; $C6
00CB04  2               
00CB04  2               .ifdef ROCKWELL
00CB04  2                .byte OP_SMB, AM_ZEROPAGE           ; $C7 [65C02 only]
00CB04  2               .elseif .defined(D65816)
00CB04  2                .byte OP_CMP, AM_DIRECT_PAGE_INDIRECT_LONG ; $C7 [WDC 65816 only]
00CB04  2               .else
00CB04  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $C7
00CB06  2               .endif
00CB06  2               
00CB06  2  1B 01         .byte OP_INY, AM_IMPLICIT           ; $C8
00CB08  2               
00CB08  2  12 03         .byte OP_CMP, AM_IMMEDIATE          ; $C9
00CB0A  2               
00CB0A  2  16 01         .byte OP_DEX, AM_IMPLICIT           ; $CA
00CB0C  2               
00CB0C  2               .if .defined(D65C02) .or .defined(D65816)
00CB0C  2  46 01         .byte OP_WAI, AM_IMPLICIT           ; $CB [WDC 65C02 and 65816 only]
00CB0E  2               .else
00CB0E  2                .byte OP_INV, AM_IMPLICIT           ; $CB
00CB0E  2               .endif
00CB0E  2               
00CB0E  2  14 08         .byte OP_CPY, AM_ABSOLUTE           ; $CC
00CB10  2               
00CB10  2  12 08         .byte OP_CMP, AM_ABSOLUTE           ; $CD
00CB12  2               
00CB12  2  15 08         .byte OP_DEC, AM_ABSOLUTE           ; $CE
00CB14  2               
00CB14  2               .ifdef ROCKWELL
00CB14  2                .byte OP_BBS, AM_ABSOLUTE           ; $CF [65C02 only]
00CB14  2               .elseif .defined(D65816)
00CB14  2                .byte OP_CMP, AM_ABSOLUTE_LONG      ; $CF [WDC 65816 only]
00CB14  2               .else
00CB14  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $CF
00CB16  2               .endif
00CB16  2               
00CB16  2  09 07         .byte OP_BNE, AM_RELATIVE           ; $D0
00CB18  2               
00CB18  2  12 0D         .byte OP_CMP, AM_INDIRECT_INDEXED   ; $D1
00CB1A  2               
00CB1A  2               .ifdef D65C02
00CB1A  2  12 0E         .byte OP_CMP, AM_INDIRECT_ZEROPAGE  ; $D2 [65C02 only]
00CB1C  2               .else
00CB1C  2                .byte OP_INV, AM_IMPLICIT           ; $D2
00CB1C  2               .endif
00CB1C  2               
00CB1C  2               .ifdef D65816
00CB1C  2                .byte OP_CMP, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $D3 [WDC 65816 only]
00CB1C  2               .else
00CB1C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB1E  2               .endif
00CB1E  2               
00CB1E  2               .ifdef D65816
00CB1E  2                .byte OP_PEI, AM_INDIRECT_ZEROPAGE  ; $D4 [WDC 65816 only]
00CB1E  2               .else
00CB1E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB20  2               .endif
00CB20  2               
00CB20  2  12 05         .byte OP_CMP, AM_ZEROPAGE_X         ; $D5
00CB22  2               
00CB22  2  15 05         .byte OP_DEC, AM_ZEROPAGE_X         ; $D6
00CB24  2               
00CB24  2               .ifdef ROCKWELL
00CB24  2                .byte OP_SMB, AM_ZEROPAGE           ; $D7 [65C02 only]
00CB24  2               .elseif .defined(D65816)
00CB24  2                .byte OP_CMP, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $D7 [WDC 65816 only]
00CB24  2               .else
00CB24  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $D7
00CB26  2               .endif
00CB26  2               
00CB26  2  0F 01         .byte OP_CLD, AM_IMPLICIT           ; $D8
00CB28  2               
00CB28  2  12 0A         .byte OP_CMP, AM_ABSOLUTE_Y         ; $D9
00CB2A  2               
00CB2A  2               .ifdef D65C02
00CB2A  2  3C 01         .byte OP_PHX, AM_IMPLICIT           ; $DA [65C02 only]
00CB2C  2               .else
00CB2C  2                .byte OP_INV, AM_IMPLICIT           ; $CF
00CB2C  2               .endif
00CB2C  2               
00CB2C  2               .if .defined(D65C02) .or .defined(D65816)
00CB2C  2  45 01         .byte OP_STP, AM_IMPLICIT           ; $DB [WDC 65C02 and 65816 only]
00CB2E  2               .else
00CB2E  2                .byte OP_INV, AM_IMPLICIT           ; $DB
00CB2E  2               .endif
00CB2E  2               
00CB2E  2               .ifdef D65816
00CB2E  2                .byte OP_JML, AM_ABSOLUTE_INDIRECT_LONG ; $DC [WDC 65816 only]
00CB2E  2               .else
00CB2E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB30  2               .endif
00CB30  2               
00CB30  2  12 09         .byte OP_CMP, AM_ABSOLUTE_X         ; $DD
00CB32  2               
00CB32  2  15 09         .byte OP_DEC, AM_ABSOLUTE_X         ; $DE
00CB34  2               
00CB34  2               .ifdef ROCKWELL
00CB34  2                .byte OP_BBS, AM_ABSOLUTE           ; $DF [65C02 only]
00CB34  2               .elseif .defined(D65816)
00CB34  2                .byte OP_CMP, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $DF [WDC 65816 only]
00CB34  2               .else
00CB34  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $DF
00CB36  2               .endif
00CB36  2               
00CB36  2  13 03         .byte OP_CPX, AM_IMMEDIATE          ; $E0
00CB38  2               
00CB38  2  2C 0C         .byte OP_SBC, AM_INDEXED_INDIRECT   ; $E1
00CB3A  2               
00CB3A  2               .ifdef D65816
00CB3A  2                .byte OP_SEP, AM_IMMEDIATE          ; $E2 [WDC 65816 only]
00CB3A  2               .else
00CB3A  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB3C  2               .endif
00CB3C  2               
00CB3C  2               .ifdef D65816
00CB3C  2                .byte OP_SBC, AM_STACK_RELATIVE     ; $E3 [WDC 65816 only]
00CB3C  2               .else
00CB3C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB3E  2               .endif
00CB3E  2               
00CB3E  2  13 04         .byte OP_CPX, AM_ZEROPAGE           ; $E4
00CB40  2               
00CB40  2  2C 04         .byte OP_SBC, AM_ZEROPAGE           ; $E5
00CB42  2               
00CB42  2  19 04         .byte OP_INC, AM_ZEROPAGE           ; $E6
00CB44  2               
00CB44  2               .ifdef ROCKWELL
00CB44  2                .byte OP_SMB, AM_ZEROPAGE           ; $E7 [65C02 only]
00CB44  2               .elseif .defined(D65816)
00CB44  2                .byte OP_SBC, AM_DIRECT_PAGE_INDIRECT_LONG ; $E7 [WDC 65816 only]
00CB44  2               .else
00CB44  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $E7
00CB46  2               .endif
00CB46  2               
00CB46  2  1A 01         .byte OP_INX, AM_IMPLICIT           ; $E8
00CB48  2               
00CB48  2  2C 03         .byte OP_SBC, AM_IMMEDIATE          ; $E9
00CB4A  2               
00CB4A  2  22 01         .byte OP_NOP, AM_IMPLICIT           ; $EA
00CB4C  2               
00CB4C  2               .ifdef D65816
00CB4C  2                .byte OP_XBA, AM_IMPLICIT           ; $EB [WDC 65816 only]
00CB4C  2               .else
00CB4C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB4E  2               .endif
00CB4E  2               
00CB4E  2  13 08         .byte OP_CPX, AM_ABSOLUTE           ; $EC
00CB50  2               
00CB50  2  2C 08         .byte OP_SBC, AM_ABSOLUTE           ; $ED
00CB52  2               
00CB52  2  19 08         .byte OP_INC, AM_ABSOLUTE           ; $EE
00CB54  2               
00CB54  2               .ifdef ROCKWELL
00CB54  2                .byte OP_BBS, AM_ABSOLUTE           ; $EF [65C02 only]
00CB54  2               .elseif .defined(D65816)
00CB54  2                .byte OP_SBC, AM_ABSOLUTE_LONG      ; $EF [WDC 65816 only]
00CB54  2               .else
00CB54  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $EF
00CB56  2               .endif
00CB56  2               
00CB56  2  06 07         .byte OP_BEQ, AM_RELATIVE           ; $F0
00CB58  2               
00CB58  2  2C 0D         .byte OP_SBC, AM_INDIRECT_INDEXED   ; $F1
00CB5A  2               
00CB5A  2               .ifdef D65C02
00CB5A  2  2C 0E         .byte OP_SBC, AM_INDIRECT_ZEROPAGE  ; $F2 [65C02 only]
00CB5C  2               .else
00CB5C  2                .byte OP_INV, AM_IMPLICIT           ; $F2
00CB5C  2               .endif
00CB5C  2               
00CB5C  2               .ifdef D65816
00CB5C  2                .byte OP_SBC, AM_STACK_RELATIVE_INDIRECT_INDEXED_WITH_Y ; $F3 [WDC 65816 only]
00CB5C  2               .else
00CB5C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB5E  2               .endif
00CB5E  2               
00CB5E  2               .ifdef D65816
00CB5E  2                .byte OP_PEA, AM_ABSOLUTE           ; $F4 [WDC 65816 only]
00CB5E  2               .else
00CB5E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB60  2               .endif
00CB60  2               
00CB60  2  2C 05         .byte OP_SBC, AM_ZEROPAGE_X         ; $F5
00CB62  2               
00CB62  2  19 05         .byte OP_INC, AM_ZEROPAGE_X         ; $F6
00CB64  2               
00CB64  2               .ifdef ROCKWELL
00CB64  2                .byte OP_SMB, AM_ZEROPAGE           ; $F7 [65C02 only]
00CB64  2               .elseif .defined(D65816)
00CB64  2                .byte OP_SBC, AM_DIRECT_PAGE_INDIRECT_LONG_INDEXED_WITH_Y ; $F7 [WDC 65816 only]
00CB64  2               .else
00CB64  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $F7
00CB66  2               .endif
00CB66  2               
00CB66  2  2E 01         .byte OP_SED, AM_IMPLICIT           ; $F8
00CB68  2               
00CB68  2  2C 0A         .byte OP_SBC, AM_ABSOLUTE_Y         ; $F9
00CB6A  2               
00CB6A  2               .ifdef D65C02
00CB6A  2  3E 01         .byte OP_PLX, AM_IMPLICIT           ; $FA [65C02 only]
00CB6C  2               .else
00CB6C  2                .byte OP_INV, AM_IMPLICIT           ; $FA
00CB6C  2               .endif
00CB6C  2               
00CB6C  2               .ifdef D65816
00CB6C  2                .byte OP_XCE, AM_IMPLICIT           ; $FB [WDC 65816 only]
00CB6C  2               .else
00CB6C  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB6E  2               .endif
00CB6E  2               
00CB6E  2               .ifdef D65816
00CB6E  2                .byte OP_JSR, AM_ABSOLUTE_INDEXED_INDIRECT ; $FC [WDC 65816 only]
00CB6E  2               .else
00CB6E  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $4F
00CB70  2               .endif
00CB70  2               
00CB70  2  2C 09         .byte OP_SBC, AM_ABSOLUTE_X         ; $FD
00CB72  2               
00CB72  2  19 09         .byte OP_INC, AM_ABSOLUTE_X         ; $FE
00CB74  2               
00CB74  2               .ifdef ROCKWELL
00CB74  2                .byte OP_BBS, AM_ABSOLUTE           ; $FF [65C02 only]
00CB74  2               .elseif .defined(D65816)
00CB74  2                .byte OP_SBC, AM_ABSOLUTE_LONG_INDEXED_WITH_X ; $FF [WDC 65816 only]
00CB74  2               .else
00CB74  2  00 01         .byte OP_INV, AM_IMPLICIT           ; $FF
00CB76  2               .endif
00CB76  2               
00CB76  1               .ifdef MINIASM
00CB76  1                 .include "miniasm.s"
00CB76  2               ;
00CB76  2               ; 6502/65C02 Mini Assembler
00CB76  2               ;
00CB76  2               ; Copyright (C) 2012-2016 by Jeff Tranter <tranter@pobox.com>
00CB76  2               ;
00CB76  2               ; Licensed under the Apache License, Version 2.0 (the "License");
00CB76  2               ; you may not use this file except in compliance with the License.
00CB76  2               ; You may obtain a copy of the License at
00CB76  2               ;
00CB76  2               ;   http://www.apache.org/licenses/LICENSE-2.0
00CB76  2               ;
00CB76  2               ; Unless required by applicable law or agreed to in writing, software
00CB76  2               ; distributed under the License is distributed on an "AS IS" BASIS,
00CB76  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
00CB76  2               ; See the License for the specific language governing permissions and
00CB76  2               ; limitations under the License.
00CB76  2               ;
00CB76  2               
00CB76  2               ; Mini assembler syntax format:
00CB76  2               ;
00CB76  2               ; A <address>
00CB76  2               ; XXXX: instruction
00CB76  2               ; XXXX: instruction
00CB76  2               ; XXXX: <Esc>
00CB76  2               ;
00CB76  2               ; example:
00CB76  2               ;
00CB76  2               ; A 6000
00CB76  2               ; 6000: NOP
00CB76  2               ; 6001: LDX #0A
00CB76  2               ; 6003: JSR FFEF
00CB76  2               ; 6006: DEX
00CB76  2               ; 6007: BNE 6003
00CB76  2               ; 6009: <Esc>
00CB76  2               ;
00CB76  2               ; Restrictions:
00CB76  2               ; - no symbols or labels
00CB76  2               ; - all values in hex, 2 or 4 digits
00CB76  2               ; - no backspace or other editing features
00CB76  2               ;
00CB76  2               
00CB76  2               ; Variables used (defined in jmon.s)
00CB76  2               ; ADDR - instruction address
00CB76  2               ; OPCODE - instruction op code
00CB76  2               ; OP - instruction type (OP_*)
00CB76  2               ; LEN -length of instruction
00CB76  2               ; IN - input buffer holding operands
00CB76  2               ; AM - addressing mode (AM_*)
00CB76  2               ; MNEM - hold three letter mnemonic string used by assembler
00CB76  2               ; OPERAND - Holds any operands for assembled instruction (2 bytes)
00CB76  2               
00CB76  2               
00CB76  2               ; Assemble code entered a line at a time.
00CB76  2               ; On entry ADDR contains start address of code.
00CB76  2               ; Registers changed: A, X, Y.
00CB76  2               
00CB76  2               AssembleLine:
00CB76  2  A6 38                LDX ADDR                ; output address
00CB78  2  A4 39                LDY ADDR+1
00CB7A  2  20 AF BD             JSR PrintAddress
00CB7D  2  A9 3A                LDA #':'                ; Output colon
00CB7F  2  20 8E BE             JSR PrintChar
00CB82  2  20 20 BE             JSR PrintSpace          ; And space
00CB85  2               
00CB85  2               ; Input three letter for mnemonic (filter for valid alphabetic characters). Esc will terminate.
00CB85  2               
00CB85  2  A2 00                LDX #0                  ; Index into MNEM
00CB87  2               GetMnem:
00CB87  2  20 D9 BC             JSR GetKey              ; Get a character
00CB8A  2  C9 1B                CMP #ESC                ; <Esc> key?
00CB8C  2  F0 3A                BEQ EscPressed          ; If so, handle it
00CB8E  2  20 E3 C0             JSR ToUpper
00CB91  2  C9 41                CMP #'A'
00CB93  2  30 F2                BMI GetMnem             ; Ignore if less than 'A'
00CB95  2  C9 5B                CMP #'Z'+1
00CB97  2  10 EE                BPL GetMnem             ; or greater than 'Z'
00CB99  2  9D A9 17             STA MNEM,X              ; Valid, so store it.
00CB9C  2               .ifdef ECHO
00CB9C  2  20 8E BE             JSR PrintChar           ; Echo it
00CB9F  2               .endif
00CB9F  2  E8                   INX                     ; Advance index
00CBA0  2  E0 03                CPX #3                  ; Done?
00CBA2  2  D0 E3                BNE GetMnem             ; If not, continue until we get 3 chars
00CBA4  2               
00CBA4  2  20 A5 D0             JSR LookupMnemonic      ; Look up mnemonic to see if it is valid
00CBA7  2  AD 89 17             LDA OP                  ; Get the returned opcode
00CBAA  2  C9 00                CMP #OP_INV             ; Not valid?
00CBAC  2  D0 1D                BNE OpOk                ; Branch if okay
00CBAE  2               
00CBAE  2  20 13 BE             JSR PrintCR
00CBB1  2  20 4A BE             JSR Imprint            ; Not a valid mnemonic
00CBB4  2  49 6E 76 61          .byte "Invalid instruction", 0
00CBB8  2  6C 69 64 20  
00CBBC  2  69 6E 73 74  
00CBC8  2               
00CBC8  2               EscPressed:
00CBC8  2  4C 13 BE             JMP PrintCR             ; Return via caller
00CBCB  2               
00CBCB  2               ; Mnemonic is valid. Does instruction use implicit addressing mode (i.e. no operand needed)?
00CBCB  2               
00CBCB  2               OpOk:
00CBCB  2  A9 01                LDA #AM_IMPLICIT
00CBCD  2  8D 8A 17             STA AM
00CBD0  2  20 EC D0             JSR CheckAddressingModeValid
00CBD3  2  F0 03                BEQ GetOperands
00CBD5  2  4C 78 CF             JMP GenerateCode                ; It is implicit, so we can jump to generating the code
00CBD8  2               
00CBD8  2               ; Not implicit addressing mode. Need to get operand from user.
00CBD8  2               
00CBD8  2               GetOperands:
00CBD8  2  20 20 BE             JSR PrintSpace          ; Output a space
00CBDB  2  20 30 C0             JSR GetLine             ; Get line of input for operand(s)
00CBDE  2  B0 E8                BCS EscPressed          ; Check if cancelled by Esc key
00CBE0  2               
00CBE0  2               ; Check for addressing mode. Have already checked for implicit.
00CBE0  2               
00CBE0  2               ; AM_ACCUMULATOR, e.g. LSR A
00CBE0  2               ; Operand is just "A"
00CBE0  2  AD 00 02             LDA IN                        ; Get length
00CBE3  2  C9 01                CMP #1                        ; Is it 1?
00CBE5  2  D0 12                BNE TryImm
00CBE7  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CBEA  2  20 E3 C0             JSR ToUpper
00CBED  2  C9 41                CMP #'A'                      ; Is it 'A'?
00CBEF  2  D0 08                BNE TryImm
00CBF1  2  A9 02                LDA #AM_ACCUMULATOR           ; Yes, is is accumulator mode
00CBF3  2  8D 8A 17             STA AM                        ; Save it
00CBF6  2  4C 78 CF             JMP GenerateCode
00CBF9  2               
00CBF9  2               ; AM_IMMEDIATE, e.g. LDA #nn
00CBF9  2               ; Operand is '#' followed by 2 hex digits.
00CBF9  2               TryImm:
00CBF9  2  AD 00 02             LDA IN                        ; Get length
00CBFC  2  C9 03                CMP #3                        ; Is it 3?
00CBFE  2  D0 2B                BNE TryZeroPage
00CC00  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CC03  2  C9 23                CMP #'#'                      ; is it '#'?
00CC05  2  D0 24                BNE TryZeroPage
00CC07  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CC0A  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC0D  2  F0 1C                BEQ TryZeroPage
00CC0F  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CC12  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC15  2  F0 14                BEQ TryZeroPage
00CC17  2  A9 03                LDA #AM_IMMEDIATE             ; Yes, this is immediate mode
00CC19  2  8D 8A 17             STA AM                        ; Save it
00CC1C  2  AE 02 02             LDX IN+2                      ; Get operand characters
00CC1F  2  AC 03 02             LDY IN+3
00CC22  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CC25  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CC28  2  4C 78 CF             JMP GenerateCode
00CC2B  2               
00CC2B  2               ; AM_ZEROPAGE e.g. LDA nn
00CC2B  2               ; Operand is 2 hex digits.
00CC2B  2               TryZeroPage:
00CC2B  2  AD 00 02             LDA IN                        ; Get length
00CC2E  2  C9 02                CMP #2                        ; Is it 2?
00CC30  2  D0 24                BNE TryAbsRel
00CC32  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CC35  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC38  2  F0 1C                BEQ TryAbsRel
00CC3A  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CC3D  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC40  2  F0 14                BEQ TryAbsRel
00CC42  2  A9 04                LDA #AM_ZEROPAGE              ; Yes, this is zero page
00CC44  2  8D 8A 17             STA AM                        ; Save it
00CC47  2  AE 01 02             LDX IN+1                      ; Get operand characters
00CC4A  2  AC 02 02             LDY IN+2
00CC4D  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CC50  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CC53  2  4C 78 CF             JMP GenerateCode
00CC56  2               
00CC56  2               ; AM_ABSOLUTE, e.g. LDA nnnn or AM_RELATIVE, e.g. BEQ nnnn
00CC56  2               ; Operand is 4 hex digits.
00CC56  2               
00CC56  2               TryAbsRel:
00CC56  2  AD 00 02             LDA IN                        ; Get length
00CC59  2  C9 04                CMP #4                        ; Is it 4?
00CC5B  2  D0 52                BNE TryZeroPageX
00CC5D  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CC60  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC63  2  F0 4A                BEQ TryZeroPageX
00CC65  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CC68  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC6B  2  F0 42                BEQ TryZeroPageX
00CC6D  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CC70  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC73  2  F0 3A                BEQ TryZeroPageX
00CC75  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CC78  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CC7B  2  F0 32                BEQ TryZeroPageX
00CC7D  2               
00CC7D  2               ; It could be absolute or relative, depending on the instruction.
00CC7D  2               ; Test both to see which one, if any, is valid.
00CC7D  2               
00CC7D  2  A9 08                LDA #AM_ABSOLUTE              ; Try absolute addressing mode
00CC7F  2  8D 8A 17             STA AM                        ; Save it
00CC82  2  20 EC D0             JSR CheckAddressingModeValid
00CC85  2  F0 1B                BEQ TryRelative               ; No, try relative
00CC87  2               
00CC87  2               Save2Operands:
00CC87  2  AE 01 02             LDX IN+1                      ; Get operand characters
00CC8A  2  AC 02 02             LDY IN+2
00CC8D  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CC90  2  8D AD 17             STA OPERAND+1                 ; Save it as the operand
00CC93  2  AE 03 02             LDX IN+3                      ; Get operand characters
00CC96  2  AC 04 02             LDY IN+4
00CC99  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CC9C  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CC9F  2  4C 78 CF             JMP GenerateCode
00CCA2  2               
00CCA2  2               TryRelative:
00CCA2  2  A9 07                LDA #AM_RELATIVE              ; Try relative addressing mode
00CCA4  2  8D 8A 17             STA AM                        ; Save it
00CCA7  2  20 EC D0             JSR CheckAddressingModeValid
00CCAA  2  F0 03                BEQ TryZeroPageX              ; No, try other modes
00CCAC  2  4C 87 CC             JMP Save2Operands
00CCAF  2               
00CCAF  2               ; AM_ZEROPAGE_X e.g. LDA nn,X
00CCAF  2               ; Operand is 2 hex digits followed by ,X
00CCAF  2               
00CCAF  2               TryZeroPageX:
00CCAF  2  AD 00 02             LDA IN                        ; Get length
00CCB2  2  C9 04                CMP #4                        ; Is it 4?
00CCB4  2  D0 35                BNE TryZeroPageY
00CCB6  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CCB9  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CCBC  2  F0 2D                BEQ TryZeroPageY
00CCBE  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CCC1  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CCC4  2  F0 25                BEQ TryZeroPageY
00CCC6  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CCC9  2  C9 2C                CMP #','                      ; Is it a comma?
00CCCB  2  D0 1E                BNE TryZeroPageY
00CCCD  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CCD0  2  20 E3 C0             JSR ToUpper
00CCD3  2  C9 58                CMP #'X'                      ; Is it an X?
00CCD5  2  D0 14                BNE TryZeroPageY
00CCD7  2  A9 05                LDA #AM_ZEROPAGE_X            ; Yes, this is zero page X
00CCD9  2  8D 8A 17             STA AM                        ; Save it
00CCDC  2  AE 01 02             LDX IN+1                      ; Get operand characters
00CCDF  2  AC 02 02             LDY IN+2
00CCE2  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CCE5  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CCE8  2  4C 78 CF             JMP GenerateCode
00CCEB  2               
00CCEB  2               ; AM_ZEROPAGE_Y e.g. LDA nn,Y
00CCEB  2               ; 2 hex digits followed by ,Y
00CCEB  2               TryZeroPageY:
00CCEB  2  AD 00 02             LDA IN                        ; Get length
00CCEE  2  C9 04                CMP #4                        ; Is it 4?
00CCF0  2  D0 35                BNE TryAbsoluteX
00CCF2  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CCF5  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CCF8  2  F0 2D                BEQ TryAbsoluteX
00CCFA  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CCFD  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD00  2  F0 25                BEQ TryAbsoluteX
00CD02  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CD05  2  C9 2C                CMP #','                      ; Is it a comma?
00CD07  2  D0 1E                BNE TryAbsoluteX
00CD09  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CD0C  2  20 E3 C0             JSR ToUpper
00CD0F  2  C9 59                CMP #'Y'                      ; Is it an Y?
00CD11  2  D0 14                BNE TryAbsoluteX
00CD13  2  A9 06                LDA #AM_ZEROPAGE_Y            ; Yes, this is zero page Y
00CD15  2  8D 8A 17             STA AM                        ; Save it
00CD18  2  AE 01 02             LDX IN+1                      ; Get operand characters
00CD1B  2  AC 02 02             LDY IN+2
00CD1E  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CD21  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CD24  2  4C 78 CF             JMP GenerateCode
00CD27  2               
00CD27  2               ; AM_ABSOLUTE_X, e.g. LDA nnnn,X
00CD27  2               ; 4 hex digits followed by ,X
00CD27  2               TryAbsoluteX:
00CD27  2  AD 00 02             LDA IN                        ; Get length
00CD2A  2  C9 06                CMP #6                        ; Is it 6?
00CD2C  2  D0 51                BNE TryAbsoluteY
00CD2E  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CD31  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD34  2  F0 49                BEQ TryAbsoluteY
00CD36  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CD39  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD3C  2  F0 41                BEQ TryAbsoluteY
00CD3E  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CD41  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD44  2  F0 39                BEQ TryAbsoluteY
00CD46  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CD49  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD4C  2  F0 31                BEQ TryAbsoluteY
00CD4E  2  AD 05 02             LDA IN+5
00CD51  2  C9 2C                CMP #','
00CD53  2  D0 2A                BNE TryAbsoluteY
00CD55  2  AD 06 02             LDA IN+6
00CD58  2  20 E3 C0             JSR ToUpper
00CD5B  2  C9 58                CMP #'X'
00CD5D  2  D0 20                BNE TryAbsoluteY
00CD5F  2  A9 09                LDA #AM_ABSOLUTE_X
00CD61  2  8D 8A 17             STA AM
00CD64  2  AE 01 02             LDX IN+1                      ; Get operand characters
00CD67  2  AC 02 02             LDY IN+2
00CD6A  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CD6D  2  8D AD 17             STA OPERAND+1                 ; Save it as the operand
00CD70  2  AE 03 02             LDX IN+3                      ; Get operand characters
00CD73  2  AC 04 02             LDY IN+4
00CD76  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CD79  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CD7C  2  4C 78 CF             JMP GenerateCode
00CD7F  2               
00CD7F  2               ; AM_ABSOLUTE_Y, e.g. LDA nnnn,Y
00CD7F  2               ; 4 hex digits followed by ,Y
00CD7F  2               TryAbsoluteY:
00CD7F  2  AD 00 02             LDA IN                        ; Get length
00CD82  2  C9 06                CMP #6                        ; Is it 6?
00CD84  2  D0 51                BNE TryIndexedIndirect
00CD86  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CD89  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD8C  2  F0 49                BEQ TryIndexedIndirect
00CD8E  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CD91  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD94  2  F0 41                BEQ TryIndexedIndirect
00CD96  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CD99  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CD9C  2  F0 39                BEQ TryIndexedIndirect
00CD9E  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CDA1  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CDA4  2  F0 31                BEQ TryIndexedIndirect
00CDA6  2  AD 05 02             LDA IN+5
00CDA9  2  C9 2C                CMP #','
00CDAB  2  D0 2A                BNE TryIndexedIndirect
00CDAD  2  AD 06 02             LDA IN+6
00CDB0  2  20 E3 C0             JSR ToUpper
00CDB3  2  C9 59                CMP #'Y'
00CDB5  2  D0 20                BNE TryIndexedIndirect
00CDB7  2  A9 0A                LDA #AM_ABSOLUTE_Y
00CDB9  2  8D 8A 17             STA AM
00CDBC  2  AE 01 02             LDX IN+1                      ; Get operand characters
00CDBF  2  AC 02 02             LDY IN+2
00CDC2  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CDC5  2  8D AD 17             STA OPERAND+1                 ; Save it as the operand
00CDC8  2  AE 03 02             LDX IN+3                      ; Get operand characters
00CDCB  2  AC 04 02             LDY IN+4
00CDCE  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CDD1  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CDD4  2  4C 78 CF             JMP GenerateCode
00CDD7  2               
00CDD7  2               ; AM_INDEXED_INDIRECT, e.g. LDA (nn,X)
00CDD7  2               TryIndexedIndirect:
00CDD7  2  AD 00 02             LDA IN                        ; Get length
00CDDA  2  C9 06                CMP #6                        ; Is it 6?
00CDDC  2  D0 43                BNE TryIndirectIndexed
00CDDE  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CDE1  2  C9 28                CMP #'('
00CDE3  2  D0 3C                BNE TryIndirectIndexed
00CDE5  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CDE8  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CDEB  2  F0 34                BEQ TryIndirectIndexed
00CDED  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CDF0  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CDF3  2  F0 2C                BEQ TryIndirectIndexed
00CDF5  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CDF8  2  C9 2C                CMP #','                      ; Is it a comma?
00CDFA  2  D0 25                BNE TryIndirectIndexed
00CDFC  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
00CDFF  2  20 E3 C0             JSR ToUpper
00CE02  2  C9 58                CMP #'X'                      ; Is it an X?
00CE04  2  D0 1B                BNE TryIndirectIndexed
00CE06  2  AD 06 02             LDA IN+6                      ; Get sixth char of operand
00CE09  2  C9 29                CMP #')'                      ; Is it an )?
00CE0B  2  D0 14                BNE TryIndirectIndexed
00CE0D  2  A9 0C                LDA #AM_INDEXED_INDIRECT      ; Yes, this is indexed indirect
00CE0F  2  8D 8A 17             STA AM                        ; Save it
00CE12  2  AE 02 02             LDX IN+2                      ; Get operand characters
00CE15  2  AC 03 02             LDY IN+3
00CE18  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CE1B  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CE1E  2  4C 78 CF             JMP GenerateCode
00CE21  2               
00CE21  2               ; AM_INDIRECT_INDEXED, e.g. LDA (nn),Y
00CE21  2               TryIndirectIndexed:
00CE21  2  AD 00 02             LDA IN                        ; Get length
00CE24  2  C9 06                CMP #6                        ; Is it 6?
00CE26  2  D0 43                BNE TryIndirect
00CE28  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CE2B  2  C9 28                CMP #'('
00CE2D  2  D0 3C                BNE TryIndirect
00CE2F  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CE32  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CE35  2  F0 34                BEQ TryIndirect
00CE37  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CE3A  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CE3D  2  F0 2C                BEQ TryIndirect
00CE3F  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CE42  2  C9 29                CMP #')'                      ; Is it a )?
00CE44  2  D0 25                BNE TryIndirect
00CE46  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
00CE49  2  C9 2C                CMP #','                      ; Is it a comma?
00CE4B  2  D0 1E                BNE TryIndirect
00CE4D  2  AD 06 02             LDA IN+6                      ; Get sixth char of operand
00CE50  2  20 E3 C0             JSR ToUpper
00CE53  2  C9 59                CMP #'Y'                      ; Is it a Y?
00CE55  2  D0 14                BNE TryIndirect
00CE57  2  A9 0D                LDA #AM_INDIRECT_INDEXED      ; Yes, this is indirect indexed
00CE59  2  8D 8A 17             STA AM                        ; Save it
00CE5C  2  AE 02 02             LDX IN+2                      ; Get operand characters
00CE5F  2  AC 03 02             LDY IN+3
00CE62  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CE65  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CE68  2  4C 78 CF             JMP GenerateCode
00CE6B  2               
00CE6B  2               ; AM_INDIRECT, e.g. JMP (nnnn)
00CE6B  2               ; l paren, 4 hex digits, r paren
00CE6B  2               TryIndirect:
00CE6B  2  AD 00 02             LDA IN                        ; Get length
00CE6E  2  C9 06                CMP #6                        ; Is it 6?
00CE70  2  D0 4E                BNE TryIndirectZP
00CE72  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CE75  2  C9 28                CMP #'('
00CE77  2  D0 47                BNE TryIndirectZP
00CE79  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CE7C  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CE7F  2  F0 3F                BEQ TryIndirectZP
00CE81  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CE84  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CE87  2  F0 37                BEQ TryIndirectZP
00CE89  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CE8C  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CE8F  2  F0 2F                BEQ TryIndirectZP
00CE91  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
00CE94  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CE97  2  F0 27                BEQ TryIndirectZP
00CE99  2  AD 06 02             LDA IN+6                      ; Get fourth char of operand
00CE9C  2  C9 29                CMP #')'                      ; Is it a )?
00CE9E  2  D0 20                BNE TryIndirectZP
00CEA0  2  A9 0B                LDA #AM_INDIRECT              ; Yes, this is indirect
00CEA2  2  8D 8A 17             STA AM                        ; Save it
00CEA5  2               
00CEA5  2  AE 02 02             LDX IN+2                      ; Get operand characters
00CEA8  2  AC 03 02             LDY IN+3
00CEAB  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CEAE  2  8D AD 17             STA OPERAND+1                 ; Save it as the operand
00CEB1  2  AE 04 02             LDX IN+4                      ; Get operand characters
00CEB4  2  AC 05 02             LDY IN+5
00CEB7  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CEBA  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CEBD  2  4C 78 CF             JMP GenerateCode
00CEC0  2               
00CEC0  2               ; AM_INDIRECT_ZEROPAGE, e.g. LDA (nn) [65C02 only]
00CEC0  2               TryIndirectZP:
00CEC0  2  AD 00 02             LDA IN                        ; Get length
00CEC3  2  C9 04                CMP #4                        ; Is it 4?
00CEC5  2  D0 32                BNE TryAbsIndInd
00CEC7  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CECA  2  C9 28                CMP #'('
00CECC  2  D0 2B                BNE TryAbsIndInd
00CECE  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CED1  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CED4  2  F0 23                BEQ TryAbsIndInd
00CED6  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CED9  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CEDC  2  F0 1B                BEQ TryAbsIndInd
00CEDE  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CEE1  2  C9 29                CMP #')'                      ; Is it a )?
00CEE3  2  D0 14                BNE TryAbsIndInd
00CEE5  2  A9 0E                LDA #AM_INDIRECT_ZEROPAGE     ; Yes, this is indirect zeropage
00CEE7  2  8D 8A 17             STA AM                        ; Save it
00CEEA  2               
00CEEA  2  AE 02 02             LDX IN+2                      ; Get operand characters
00CEED  2  AC 03 02             LDY IN+3
00CEF0  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CEF3  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CEF6  2  4C 78 CF             JMP GenerateCode
00CEF9  2               
00CEF9  2               ; AM_ABSOLUTE_INDEXED_INDIRECT, e.g. JMP (nnnn,X) [65C02 only]
00CEF9  2               TryAbsIndInd:
00CEF9  2  AD 00 02             LDA IN                        ; Get length
00CEFC  2  C9 08                CMP #8                        ; Is it 8?
00CEFE  2  D0 5F                BNE InvalidOp
00CF00  2  AD 01 02             LDA IN+1                      ; Get first char of operand
00CF03  2  C9 28                CMP #'('
00CF05  2  D0 58                BNE InvalidOp
00CF07  2  AD 02 02             LDA IN+2                      ; Get second char of operand
00CF0A  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CF0D  2  F0 50                BEQ InvalidOp
00CF0F  2  AD 03 02             LDA IN+3                      ; Get third char of operand
00CF12  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CF15  2  F0 48                BEQ InvalidOp
00CF17  2  AD 04 02             LDA IN+4                      ; Get fourth char of operand
00CF1A  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CF1D  2  F0 40                BEQ InvalidOp
00CF1F  2  AD 05 02             LDA IN+5                      ; Get fifth char of operand
00CF22  2  20 24 D1             JSR IsHexDigit                ; Is it a hex digit?
00CF25  2  F0 38                BEQ InvalidOp
00CF27  2  AD 06 02             LDA IN+6                      ; Get sixth char of operand
00CF2A  2  C9 2C                CMP #','                      ; Is it a ,?
00CF2C  2  D0 31                BNE InvalidOp
00CF2E  2  AD 07 02             LDA IN+7                      ; Get 7th char of operand
00CF31  2  20 E3 C0             JSR ToUpper
00CF34  2  C9 58                CMP #'X'                      ; Is it a X?
00CF36  2  D0 27                BNE InvalidOp
00CF38  2  AD 08 02             LDA IN+8                      ; Get 8th char of operand
00CF3B  2  C9 29                CMP #')'                      ; Is it a )?
00CF3D  2  D0 20                BNE InvalidOp
00CF3F  2  A9 0F                LDA #AM_ABSOLUTE_INDEXED_INDIRECT ; Yes, this is abolute indexed indirect
00CF41  2  8D 8A 17             STA AM                        ; Save it
00CF44  2               
00CF44  2  AE 02 02             LDX IN+2                      ; Get operand characters
00CF47  2  AC 03 02             LDY IN+3
00CF4A  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CF4D  2  8D AD 17             STA OPERAND+1                 ; Save it as the operand
00CF50  2  AE 04 02             LDX IN+4                      ; Get operand characters
00CF53  2  AC 05 02             LDY IN+5
00CF56  2  20 3D D1             JSR TwoCharsToBin             ; Convert to binary
00CF59  2  8D AC 17             STA OPERAND                   ; Save it as the operand
00CF5C  2  4C 78 CF             JMP GenerateCode
00CF5F  2               
00CF5F  2               ; If not any of the above, report "Invalid operand" and return.
00CF5F  2               
00CF5F  2               InvalidOp:
00CF5F  2  20 13 BE             JSR PrintCR
00CF62  2  20 4A BE             JSR Imprint
00CF65  2  49 6E 76 61          .byte "Invalid operand", 0
00CF69  2  6C 69 64 20  
00CF6D  2  6F 70 65 72  
00CF75  2  4C 13 BE             JMP PrintCR             ; Return via caller
00CF78  2               
00CF78  2               GenerateCode:
00CF78  2  20 13 BE             JSR PrintCR             ; Output newline
00CF7B  2               
00CF7B  2  20 EC D0             JSR CheckAddressingModeValid   ; See if addressing mode is valid
00CF7E  2  D0 1E                BNE OperandOkay
00CF80  2               
00CF80  2  20 4A BE             JSR Imprint             ; Not a valid addressing mode
00CF83  2  49 6E 76 61          .byte "Invalid addressing mode", 0
00CF87  2  6C 69 64 20  
00CF8B  2  61 64 64 72  
00CF9B  2               
00CF9B  2  4C 13 BE             JMP PrintCR             ; Return via caller
00CF9E  2               
00CF9E  2               OperandOkay:
00CF9E  2               
00CF9E  2               ; Look up instruction length based on addressing mode and save it
00CF9E  2               
00CF9E  2  AE 8A 17             LDX AM                   ; Addressing mode
00CFA1  2  BD 5D C9             LDA LENGTHS,X            ; Get instruction length for this addressing mode
00CFA4  2  8D 8B 17             STA LEN                  ; Save it
00CFA7  2               
00CFA7  2               ; Write the opcode to memory
00CFA7  2               
00CFA7  2  AD 88 17             LDA OPCODE               ; get opcode
00CFAA  2  A0 00                LDY #0
00CFAC  2  91 38                STA (ADDR),Y             ; store it
00CFAE  2               
00CFAE  2               ; Check that we can write it back (in case destination memory is not writable).
00CFAE  2               
00CFAE  2  D1 38                CMP (ADDR),Y             ; Do we read back what we wrote?
00CFB0  2  F0 22                BEQ WriteOperands        ; Yes, okay
00CFB2  2               
00CFB2  2               ; Memory is not writable for some reason, Report error and quit.
00CFB2  2               
00CFB2  2  20 4A BE             JSR Imprint              ; Print error message
00CFB5  2  55 6E 61 62          .byte "Unable to write to $", 0
00CFB9  2  6C 65 20 74  
00CFBD  2  6F 20 77 72  
00CFCA  2  A6 38                LDX ADDR
00CFCC  2  A4 39                LDY ADDR+1
00CFCE  2  20 AF BD             JSR PrintAddress
00CFD1  2  4C 13 BE             JMP PrintCR             ; Return via caller
00CFD4  2               
00CFD4  2               ; Generate code for operands
00CFD4  2               
00CFD4  2               WriteOperands:
00CFD4  2  AD 8A 17             LDA AM                  ; get addressing mode
00CFD7  2  C9 01                CMP #AM_IMPLICIT        ; These modes take no operands
00CFD9  2  D0 03                BNE TryAcc
00CFDB  2  4C 94 D0             JMP ZeroOperands
00CFDE  2               TryAcc:
00CFDE  2  C9 02                CMP #AM_ACCUMULATOR
00CFE0  2  D0 03                BNE TryImmed
00CFE2  2  4C 94 D0             JMP ZeroOperands
00CFE5  2               
00CFE5  2               TryImmed:
00CFE5  2  C9 03                CMP #AM_IMMEDIATE       ; These modes take one operand
00CFE7  2  D0 03                BNE TryZp
00CFE9  2  4C 7D D0             JMP OneOperand
00CFEC  2  C9 04        TryZp:  CMP #AM_ZEROPAGE
00CFEE  2  D0 03                BNE TryZpX
00CFF0  2  4C 7D D0             JMP OneOperand
00CFF3  2  C9 05        TryZpX: CMP #AM_ZEROPAGE_X
00CFF5  2  D0 03                BNE TryZpY
00CFF7  2  4C 7D D0             JMP OneOperand
00CFFA  2  C9 06        TryZpY: CMP #AM_ZEROPAGE_Y
00CFFC  2  F0 7F                BEQ OneOperand
00CFFE  2  C9 0C                CMP #AM_INDEXED_INDIRECT
00D000  2  F0 7B                BEQ OneOperand
00D002  2  C9 0D                CMP #AM_INDIRECT_INDEXED
00D004  2  F0 77                BEQ OneOperand
00D006  2  C9 0E                CMP #AM_INDIRECT_ZEROPAGE ; [65C02 only]
00D008  2  F0 73                BEQ OneOperand
00D00A  2               
00D00A  2  C9 08                CMP #AM_ABSOLUTE       ; These modes take two operands
00D00C  2  F0 79                BEQ TwoOperands
00D00E  2  C9 09                CMP #AM_ABSOLUTE_X
00D010  2  F0 75                BEQ TwoOperands
00D012  2  C9 0A                CMP #AM_ABSOLUTE_Y
00D014  2  F0 71                BEQ TwoOperands
00D016  2  C9 0B                CMP #AM_INDIRECT
00D018  2  F0 6D                BEQ TwoOperands
00D01A  2  C9 0F                CMP #AM_ABSOLUTE_INDEXED_INDIRECT
00D01C  2  F0 69                BEQ TwoOperands
00D01E  2               
00D01E  2  C9 07                CMP #AM_RELATIVE       ; Relative is special case
00D020  2  D0 72                BNE ZeroOperands
00D022  2               
00D022  2               ; BEQ nnnn        Relative
00D022  2               ; Write 1 byte calculated as destination - current address - instruction length
00D022  2               ; i.e. (OPERAND,OPERAND+1) - ADDR,ADDR+1 - 2
00D022  2               ; Report error if branch is out of 8-bit offset range.
00D022  2               
00D022  2               Relative:
00D022  2  AD AC 17              LDA OPERAND                 ; destination low byte
00D025  2  38                    SEC
00D026  2  E5 38                 SBC ADDR                    ; subtract address low byte
00D028  2  8D AC 17              STA OPERAND                 ; Save it
00D02B  2  AD AD 17              LDA OPERAND+1               ; destination high byte
00D02E  2  E5 39                 SBC ADDR+1                  ; subtract address high byte (with any borrow)
00D030  2  8D AD 17              STA OPERAND+1               ; store it
00D033  2               
00D033  2  AD AC 17              LDA OPERAND
00D036  2  38                    SEC
00D037  2  E9 02                 SBC #2                      ; subtract 2 more
00D039  2  8D AC 17              STA OPERAND                 ; store it
00D03C  2  AD AD 17              LDA OPERAND+1               ; destination high byte
00D03F  2  E9 00                 SBC #0                      ; subtract 0 (with any borrow)
00D041  2  8D AD 17              STA OPERAND+1               ; store it
00D044  2               
00D044  2               ; Report error if branch is out of 8-bit offset range.
00D044  2               ; Valid range is $0000 - $007F and $FF80 - $FFFF
00D044  2               
00D044  2  AD AD 17              LDA OPERAND+1              ; High byte
00D047  2  F0 27                 BEQ OkayZero               ; Should be $))
00D049  2  C9 FF                 CMP #$FF
00D04B  2  F0 2B                 BEQ OkayFF                 ; Or $FF
00D04D  2               OutOfRange:
00D04D  2  20 4A BE              JSR Imprint
00D050  2  52 65 6C 61           .byte "Relative branch out of range", 0
00D054  2  74 69 76 65  
00D058  2  20 62 72 61  
00D06D  2  4C 13 BE              JMP PrintCR                ; Return via caller
00D070  2               
00D070  2               OkayZero:
00D070  2  AD AC 17              LDA OPERAND                ; Low byte
00D073  2  30 D8                 BMI OutOfRange             ; must be $00-$7F (i.e. positive)
00D075  2  4C 7D D0              JMP OneOperand
00D078  2               
00D078  2               OkayFF:
00D078  2  AD AC 17              LDA OPERAND                ; Low byte
00D07B  2  10 D0                 BPL OutOfRange             ; must be $80-$FF (i.e. negative)
00D07D  2               
00D07D  2               ; Now fall through to one operand code
00D07D  2               
00D07D  2               OneOperand:
00D07D  2  AD AC 17             LDA OPERAND                  ; Get operand
00D080  2  A0 01                LDY #1                       ; Offset from instruction
00D082  2  91 38                STA (ADDR),Y                 ; write it
00D084  2  4C 94 D0             JMP ZeroOperands             ; done
00D087  2               
00D087  2               TwoOperands:
00D087  2  AD AC 17             LDA OPERAND                  ; Get operand low byte
00D08A  2  A0 01                LDY #1                       ; Offset from instruction
00D08C  2  91 38                STA (ADDR),Y                 ; write it
00D08E  2  C8                   INY
00D08F  2  AD AD 17             LDA OPERAND+1                ; Get operand high byte
00D092  2  91 38                STA (ADDR),Y                 ; write it
00D094  2               
00D094  2               ZeroOperands:                        ; Nothing to do
00D094  2               
00D094  2               ; Update current address with instruction length
00D094  2               
00D094  2  18                  CLC
00D095  2  A5 38               LDA ADDR                      ; Low byte
00D097  2  6D 8B 17            ADC LEN                       ; Add length
00D09A  2  85 38               STA ADDR                      ; Store it
00D09C  2  A5 39               LDA ADDR+1                    ; High byte
00D09E  2  69 00               ADC #0                        ; Add any carry
00D0A0  2  85 39               STA ADDR+1                    ; Store it
00D0A2  2  4C 76 CB            JMP AssembleLine              ; loop back to start of AssembleLine
00D0A5  2               
00D0A5  2               ; Look up three letter mnemonic, e.g. "NOP". On entry mnemonic is stored in MNEM.
00D0A5  2               ; Write index value, e.g. OP_NOP, to OP. Set sit to OP_INV if not found.
00D0A5  2               ; Registers changed: A, X, Y.
00D0A5  2               LookupMnemonic:
00D0A5  2  A2 00                LDX #0                  ; Holds current table index
00D0A7  2  A9 37                LDA #<MNEMONICS         ; Store address of start of table in T1 (L/H)
00D0A9  2  85 30                STA T1
00D0AB  2  A9 C8                LDA #>MNEMONICS
00D0AD  2  85 31                STA T1+1
00D0AF  2               Loop:
00D0AF  2  A0 00                LDY #0                  ; Holds offset of string in table entry
00D0B1  2  B9 A9 17             LDA MNEM,Y              ; Compare first char of mnemonic to table entry
00D0B4  2  D1 30                CMP (T1),Y
00D0B6  2  D0 14                BNE NextOp              ; If different, try next opcode
00D0B8  2  C8                   INY
00D0B9  2  B9 A9 17             LDA MNEM,Y              ; Compare second char of mnemonic to table entry
00D0BC  2  D1 30                CMP (T1),Y
00D0BE  2  D0 0C                BNE NextOp              ; If different, try next opcode
00D0C0  2  C8                   INY
00D0C1  2  B9 A9 17             LDA MNEM,Y              ; Compare third char of mnemonic to table entry
00D0C4  2  D1 30                CMP (T1),Y
00D0C6  2  D0 04                BNE NextOp              ; If different, try next opcode
00D0C8  2               
00D0C8  2                                               ; We found a match
00D0C8  2  8E 89 17             STX OP                  ; Store index in table (X) in OP
00D0CB  2  60                   RTS                     ; And return
00D0CC  2               
00D0CC  2               NextOp:
00D0CC  2  E8                   INX                     ; Increment table index
00D0CD  2  18                   CLC
00D0CE  2  A5 30                LDA T1                  ; Increment pointer to table entry (T1) as 16-bit value
00D0D0  2  69 03                ADC #3                  ; Adding three because each entry is 3 bytes
00D0D2  2  85 30                STA T1
00D0D4  2  A5 31                LDA T1+1                ; Add possible carry to high byte
00D0D6  2  69 00                ADC #0
00D0D8  2  85 31                STA T1+1
00D0DA  2               
00D0DA  2  A5 30                LDA T1                  ; Did we reach the last entry (MNEMONICSEND?)
00D0DC  2  C9 5D                CMP #<MNEMONICSEND      ; If not, keep searching
00D0DE  2  D0 CF                BNE Loop
00D0E0  2  A5 31                LDA T1+1
00D0E2  2  C9 C9                CMP #>MNEMONICSEND
00D0E4  2  D0 C9                BNE Loop
00D0E6  2               
00D0E6  2                                               ; End of table reached
00D0E6  2  A9 00                LDA #OP_INV             ; Value is not valid
00D0E8  2  8D 89 17             STA OP
00D0EB  2  60                   RTS
00D0EC  2               
00D0EC  2               ; Given an instruction and addressing mode, return if it is valid.
00D0EC  2               ; When called OP should contain instruction (e.g. OP_NOP) and
00D0EC  2               ; AM contain the addressing mode (e.g. AM_IMPLICIT).
00D0EC  2               ; If valid, sets OPCODE to the opcode (eg. $EA for NOP) and returns 1
00D0EC  2               ; in A. If not valid, returns 0 in A.
00D0EC  2               ; Registers changed: A, X, Y.
00D0EC  2               
00D0EC  2               CheckAddressingModeValid:
00D0EC  2  A2 00                LDX #0                  ; Holds current table index
00D0EE  2  A9 76                LDA #<OPCODES           ; Store address of start of table in T1 (L/H)
00D0F0  2  85 30                STA T1
00D0F2  2  A9 C9                LDA #>OPCODES
00D0F4  2  85 31                STA T1+1
00D0F6  2               OpLoop:
00D0F6  2  A0 00                LDY #0                  ; Holds offset into table entry
00D0F8  2  B1 30                LDA (T1),Y              ; Get a table entry (instruction)
00D0FA  2  CD 89 17             CMP OP                  ; Is it the instruction we are looking for?
00D0FD  2  D0 0F                BNE NextInst            ; If different, try next opcode
00D0FF  2                                               ; Instruction matched. Does the addressing mode match?
00D0FF  2  C8                   INY                     ; Want second byte of table entry (address mode)
00D100  2  B1 30                LDA (T1),Y              ; Get a table entry (address mode
00D102  2  CD 8A 17             CMP AM                  ; Is it the address mode we are looking for?
00D105  2  D0 07                BNE NextInst            ; If different, try next opcode
00D107  2                                               ; We found a match
00D107  2  8A                   TXA                     ; Get index in table (X), the opcode
00D108  2  8D 88 17             STA OPCODE              ; Store it
00D10B  2  A9 01                LDA #1                  ; Set true return value
00D10D  2  60                   RTS                     ; And return
00D10E  2               
00D10E  2               NextInst:
00D10E  2  E8                   INX                     ; Increment table index
00D10F  2  F0 10                BEQ OpNotFound          ; If wrapped past $FF, we did not find what we were looking for
00D111  2  18                   CLC
00D112  2  A5 30                LDA T1                  ; Increment pointer to table entry (T1) as 16-bit value
00D114  2  69 02                ADC #2                  ; Add two because each entry is 2 bytes
00D116  2  85 30                STA T1
00D118  2  A5 31                LDA T1+1                ; Add possible carry to high byte
00D11A  2  69 00                ADC #0
00D11C  2  85 31                STA T1+1
00D11E  2  4C F6 D0             JMP OpLoop
00D121  2               
00D121  2               OpNotFound:                     ; End of table reached
00D121  2  A9 00                LDA #0                  ; Set false return value
00D123  2  60                   RTS
00D124  2               
00D124  2               ; Return if a character is a valid hex digit (0-9, A-F, or a-f).
00D124  2               ; Pass character in A.
00D124  2               ; Returns 1 in A if valid, 0 if not valid.
00D124  2               ; Registers affected: A
00D124  2               IsHexDigit:
00D124  2  20 E3 C0             JSR ToUpper
00D127  2  C9 30                CMP #'0'
00D129  2  30 0C                BMI @Invalid
00D12B  2  C9 3A                CMP #'9'+1
00D12D  2  30 0B                BMI @Okay
00D12F  2  C9 41                CMP #'A'
00D131  2  30 04                BMI @Invalid
00D133  2  C9 47                CMP #'F'+1
00D135  2  30 03                BMI @Okay
00D137  2               @Invalid:
00D137  2  A9 00                LDA #0
00D139  2  60                   RTS
00D13A  2               @Okay:
00D13A  2  A9 01                LDA #1
00D13C  2  60                   RTS
00D13D  2               
00D13D  2               ; Convert two characters containing hex digits to binary
00D13D  2               ; Chars passed in X (first char) and Y (second char).
00D13D  2               ; Returns value in A.
00D13D  2               ; e.g. X='1' Y='A' Returns A = $1A
00D13D  2               ; Does not check that characters are valid hex digits
00D13D  2               TwoCharsToBin:
00D13D  2  8A                   TXA                     ; get first digit
00D13E  2  20 4F D1             JSR CharToBin           ; convert to binary
00D141  2  0A                   ASL A                   ; shift to upper nibble
00D142  2  0A                   ASL A
00D143  2  0A                   ASL A
00D144  2  0A                   ASL A
00D145  2  85 30                STA T1                  ; Save it
00D147  2  98                   TYA                     ; get second digit
00D148  2  20 4F D1             JSR CharToBin           ; convert to binary
00D14B  2  18                   CLC
00D14C  2  65 30                ADC T1                  ; Add the upper nibble
00D14E  2  60                   RTS
00D14F  2               
00D14F  2               ; Convert character containing a hex digit to binary.
00D14F  2               ; Char passed in A. Returns value in A.
00D14F  2               ; e.g. A='A' Returns A=$0A
00D14F  2               ; Does not check that character is valid hex digit.
00D14F  2               CharToBin:
00D14F  2  20 E3 C0             JSR ToUpper
00D152  2  C9 3A                CMP #'9'+1              ; Is it '0'-'9'?
00D154  2  30 04                BMI @Digit              ; Branch if so
00D156  2  38                   SEC                     ; Otherwise must be 'A'-'F'
00D157  2  E9 37                SBC #'A'-10             ; convert to value
00D159  2  60                   RTS
00D15A  2               @Digit:
00D15A  2  38                   SEC
00D15B  2  E9 30                SBC #'0'                ; convert to value
00D15D  2  60                   RTS
00D15E  2               
00D15E  1               .endif
00D15E  1                 .include "trace.s"
00D15E  2               ;
00D15E  2               ; 6502 Instruction Trace
00D15E  2               ;
00D15E  2               ; Copyright (C) 2012-2019 by Jeff Tranter <tranter@pobox.com>
00D15E  2               ;
00D15E  2               ; Licensed under the Apache License, Version 2.0 (the "License");
00D15E  2               ; you may not use this file except in compliance with the License.
00D15E  2               ; You may obtain a copy of the License at
00D15E  2               ;
00D15E  2               ;   http://www.apache.org/licenses/LICENSE-2.0
00D15E  2               ;
00D15E  2               ; Unless required by applicable law or agreed to in writing, software
00D15E  2               ; distributed under the License is distributed on an "AS IS" BASIS,
00D15E  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
00D15E  2               ; See the License for the specific language governing permissions and
00D15E  2               ; limitations under the License.
00D15E  2               
00D15E  2               ; Trace Feature
00D15E  2               ; --------------
00D15E  2               ;
00D15E  2               ; The "." command single steps one instruction at a time showing the
00D15E  2               ; CPU registers. Starts with the register values listed by the R
00D15E  2               ; command. Updates them after single stepping.
00D15E  2               ;
00D15E  2               ; The R(egister) command shows the current PC and disassembles the
00D15E  2               ; current instruction. It also allows the user to change the PC. Pressing
00D15E  2               ; <Enter> when prompted for a new register value will keep the current
00D15E  2               ; value and advance to the next register.
00D15E  2               ;
00D15E  2               ; The G(o) command will optionally use the PC value if the user
00D15E  2               ; hits <Enter> instead of an address.
00D15E  2               ;
00D15E  2               ; A breakpoint (BRK instruction) will display a message and update
00D15E  2               ; the current register values so that it can be traced. This works
00D15E  2               ; whether the breakpint address is set using the B command or not.
00D15E  2               ;
00D15E  2               ; The command supports tracing/stepping through ROM as well as RAM.
00D15E  2               ;
00D15E  2               ; e.g.
00D15E  2               ;
00D15E  2               ; ? R
00D15E  2               ; A-D2 X-00 Y-03 S-017B P-33 ..-BDIZC
00D15E  2               ; FF00   D8          CLD
00D15E  2               ; A-00 X-01 Y-02 S-01FF P-00 ........
00D15E  2               ; PC-FF00
00D15E  2               ; ? .
00D15E  2               ; A-D2 X-00 Y-03 S-017B P-33 ..-B.IZC
00D15E  2               ; FF01   58          CLI
00D15E  2               ; ? .
00D15E  2               ; A-D2 X-00 Y-03 S-017B P-33 ..-B..ZC
00D15E  2               ; FF02   A0 7F       LDY   #$7F
00D15E  2               ; ? .
00D15E  2               ; A-D2 X-00 Y-7F S-017B P-33 ..-B...C
00D15E  2               ; FF04   8C 12 D0    STY   $D012
00D15E  2               
00D15E  2               ; Variables used (defined in jmon.s):
00D15E  2               ;
00D15E  2               ; SAVE_A  - Holds saved values of registers
00D15E  2               ; SAVE_X  - "
00D15E  2               ; SAVE_Y  - "
00D15E  2               ; SAVE_S  - "
00D15E  2               ; SAVE_P  - "
00D15E  2               ; SAVE_PC - "
00D15E  2               ; NEXT_PC - Value of PC after next instruction
00D15E  2               ; ADDR - instruction address
00D15E  2               ; OPCODE - instruction op code
00D15E  2               ; OP - instruction type (OP_*)
00D15E  2               ; LEN -length of instruction
00D15E  2               ; IN - input buffer holding operands
00D15E  2               ; AM - addressing mode (AM_*)
00D15E  2               ; TRACEINST - buffer holding traced instruction
00D15E  2               
00D15E  2               
00D15E  2               ; Trace the next instruction using saved registers. Execute the
00D15E  2               ; instruction, display new registers values. disassemble new current
00D15E  2               ; instruction, and return.
00D15E  2               
00D15E  2               Trace:
00D15E  2               
00D15E  2               ; Get next instruction op code from saved PC location.
00D15E  2               
00D15E  2  A9 0D                LDA #CR                 ; Better handling with new command prompt W4JBM
00D160  2  20 8E BE             JSR PrintChar
00D163  2  AD 9D 17             LDA SAVE_PC             ; Get address of instruction to execute (low byte)
00D166  2  85 38                STA ADDR                ; Save in page zero so we can use indirect addressing
00D168  2  AD 9E 17             LDA SAVE_PC+1           ; Do the same for the high byte of address
00D16B  2  85 39                STA ADDR+1
00D16D  2  A0 00                LDY #0
00D16F  2  B1 38                LDA (ADDR),Y            ; Get the instruction opcode
00D171  2  8D 88 17             STA OPCODE              ; And save it
00D174  2  20 68 D3             JSR GetLength           ; Determine instruction length
00D177  2               
00D177  2               ; Copy next instruction and operands to RAM buffer (can be up to 3 bytes)
00D177  2               
00D177  2  A0 00                LDY #0
00D179  2               @Copy:
00D179  2  B1 38                LDA (ADDR),Y            ; Get the instruction / operand from memory
00D17B  2  99 AE 17             STA TRACEINST,Y         ; Write it to the buffer where we will execute it
00D17E  2  C8                   INY                     ; Increment index
00D17F  2  CC 8B 17             CPY LEN                 ; Did we reach the instruction length?
00D182  2  D0 F5                BNE @Copy               ; Continue for instruction length
00D184  2               
00D184  2               ; Now add a jump after the instruction to where we want to go after it is executed
00D184  2               
00D184  2  A9 4C                LDA #$4C                ; JMP ReturnFromTrace
00D186  2  99 AE 17             STA TRACEINST,Y
00D189  2  C8                   INY
00D18A  2  A9 F9                LDA #<ReturnFromTrace
00D18C  2  99 AE 17             STA TRACEINST,Y
00D18F  2  C8                   INY
00D190  2  A9 D2                LDA #>ReturnFromTrace
00D192  2  99 AE 17             STA TRACEINST,Y
00D195  2               
00D195  2               ; Calculate new PC value.
00D195  2               
00D195  2  AD 9D 17             LDA SAVE_PC             ; Existing PC (low byte)
00D198  2  18                   CLC
00D199  2  6D 8B 17             ADC LEN                 ; Add length to it
00D19C  2  8D 9F 17             STA NEXT_PC             ; Save as next PC (low byte)
00D19F  2  AD 9E 17             LDA SAVE_PC+1           ; High byte
00D1A2  2  69 00                ADC #0                  ; Add any carry
00D1A4  2  8D A0 17             STA NEXT_PC+1           ; Save as next PC (high byte)
00D1A7  2               
00D1A7  2  A9 00                LDA #0
00D1A9  2  8D B6 17             STA TAKEN               ; Clear branch taken flag.
00D1AC  2               
00D1AC  2               ; Special handling for instructions that change flow of control.
00D1AC  2               ; These are not actually executed, they are emulated.
00D1AC  2               ; TODO: Factor out common code for handling instructions which change flow of control.
00D1AC  2               
00D1AC  2               ; Bxx - branch instructions. These are executed but we change the
00D1AC  2               ; destination of the branch so we catch whether they are taken or not.
00D1AC  2               
00D1AC  2  AD 8A 17             LDA AM                  ; Get addressing mode
00D1AF  2  C9 07                CMP #AM_RELATIVE        ; Relative addressing means a branch instruction
00D1B1  2  D0 1D                BNE TryBRK
00D1B3  2               
00D1B3  2               ; The code in the TRACEINST buffer will look like this:
00D1B3  2               ;
00D1B3  2               ;       JMP TRACEINST
00D1B3  2               ;       ...
00D1B3  2               ;       Bxx $03 (Taken)         ; Instruction being traced
00D1B3  2               ;       JMP ReturnFromTrace
00D1B3  2               ;Taken: JMP BranchTaken
00D1B3  2               ;        ...
00D1B3  2               ;ReturnFromTrace:
00D1B3  2               
00D1B3  2  A0 01                LDY #1                  ; Points to branch destination
00D1B5  2  A9 03                LDA #$03                ; Want to set it to $03 (Taken)
00D1B7  2  99 AE 17             STA TRACEINST,Y
00D1BA  2  A0 05                LDY #5
00D1BC  2  A9 4C                LDA #$4C                ; JMP BranchTaken
00D1BE  2  99 AE 17             STA TRACEINST,Y
00D1C1  2  C8                   INY
00D1C2  2  A9 F4                LDA #<BranchTaken
00D1C4  2  99 AE 17             STA TRACEINST,Y
00D1C7  2  C8                   INY
00D1C8  2  A9 D2                LDA #>BranchTaken
00D1CA  2  99 AE 17             STA TRACEINST,Y
00D1CD  2               
00D1CD  2               ; Next PC in the case where the branch is not taken was already set earlier.
00D1CD  2               
00D1CD  2  4C DB D2             JMP Execute
00D1D0  2               
00D1D0  2               ; BRK - set B=1. Next PC is contents of IRQ vector at $FFFE,$FFFF. Push return address-1 (Current address + 1). Push P.
00D1D0  2               TryBRK:
00D1D0  2  AD 88 17             LDA OPCODE              ; Get the opcode
00D1D3  2  C9 00                CMP #$00                ; BRK ?
00D1D5  2  D0 3E                BNE TryJmp
00D1D7  2               
00D1D7  2  AD 9C 17             LDA SAVE_P              ; Get P
00D1DA  2  09 10                ORA #%00010000          ; Set B bit
00D1DC  2  8D 9C 17             STA SAVE_P
00D1DF  2               
00D1DF  2  AD FE FF             LDA $FFFE               ; IRQ vector low
00D1E2  2  8D 9F 17             STA NEXT_PC
00D1E5  2  AD FF FF             LDA $FFFF               ; IRQ vector high
00D1E8  2  8D A0 17             STA NEXT_PC+1
00D1EB  2               
00D1EB  2  A5 38                LDA ADDR                ; Add 1 to current address
00D1ED  2  18                   CLC
00D1EE  2  69 01                ADC #1
00D1F0  2  85 38                STA ADDR
00D1F2  2  A5 39                LDA ADDR+1
00D1F4  2  69 00                ADC #0                  ; Add any carry
00D1F6  2  85 39                STA ADDR+1
00D1F8  2               
00D1F8  2  BA                   TSX                     ; Save our stack pointer
00D1F9  2  8E A1 17             STX THIS_S
00D1FC  2  AE 9B 17             LDX SAVE_S              ; Get program's stack pointer
00D1FF  2  9A                   TXS
00D200  2               
00D200  2  A5 39                LDA ADDR+1              ; Push return address on program's stack (high byte first)
00D202  2  48                   PHA
00D203  2  A5 38                LDA ADDR
00D205  2  48                   PHA
00D206  2               
00D206  2  AD 9C 17             LDA SAVE_P              ; Push P
00D209  2  48                   PHA
00D20A  2               
00D20A  2  BA                   TSX                     ; Put program's stack pointer back
00D20B  2  8E 9B 17             STX SAVE_S
00D20E  2               
00D20E  2  AE A1 17             LDX THIS_S              ; Restore our stack pointer
00D211  2  9A                   TXS
00D212  2               
00D212  2  4C 10 D3             JMP AfterStep           ; We're done
00D215  2               
00D215  2               ; JMP (2) - Next PC is operand effective address (possibly indirect).
00D215  2               
00D215  2               TryJmp:
00D215  2  C9 4C                CMP #$4C                ; JMP nnnn ?
00D217  2  D0 10                BNE TryJmpI
00D219  2  A0 01                LDY #1
00D21B  2  B1 38                LDA (ADDR),Y            ; Destination address low byte
00D21D  2  8D 9F 17             STA NEXT_PC
00D220  2  C8                   INY
00D221  2  B1 38                LDA (ADDR),Y            ; Destination address high byte
00D223  2  8D A0 17             STA NEXT_PC+1
00D226  2  4C 10 D3             JMP AfterStep           ; We're done
00D229  2               
00D229  2               TryJmpI:
00D229  2  C9 6C                CMP #$6C                ; JMP (nnnn) ?
00D22B  2  D0 1B                BNE TryJSR
00D22D  2  A0 01                LDY #1
00D22F  2  B1 38                LDA (ADDR),Y            ; Indirect destination address low byte
00D231  2  85 30                STA T1
00D233  2  C8                   INY
00D234  2  B1 38                LDA (ADDR),Y            ; Indirect destination address high byte
00D236  2  85 31                STA T1+1
00D238  2  A0 00                LDY #0
00D23A  2  B1 30                LDA (T1),Y              ; Get actual address low byte
00D23C  2  8D 9F 17             STA NEXT_PC
00D23F  2  C8                   INY
00D240  2  B1 30                LDA (T1),Y              ; Get actual address high byte
00D242  2  8D A0 17             STA NEXT_PC+1
00D245  2  4C 10 D3             JMP AfterStep           ; We're done
00D248  2               
00D248  2               ; JSR - Next PC is operand effective address. Push return address-1 (Current address + 2) on stack.
00D248  2               
00D248  2               TryJSR:
00D248  2  C9 20                CMP #$20                ; JSR nnnn ?
00D24A  2  D0 33                BNE TryRTI
00D24C  2               
00D24C  2  A0 01                LDY #1
00D24E  2  B1 38                LDA (ADDR),Y            ; Destination address low byte
00D250  2  8D 9F 17             STA NEXT_PC
00D253  2  C8                   INY
00D254  2  B1 38                LDA (ADDR),Y            ; Destination address high byte
00D256  2  8D A0 17             STA NEXT_PC+1
00D259  2               
00D259  2  A5 38                LDA ADDR                ; Add 2 to current address
00D25B  2  18                   CLC
00D25C  2  69 02                ADC #2
00D25E  2  85 38                STA ADDR
00D260  2  A5 39                LDA ADDR+1
00D262  2  69 00                ADC #0                  ; Add any carry
00D264  2  85 39                STA ADDR+1
00D266  2               
00D266  2  BA                   TSX                     ; Save our stack pointer
00D267  2  8E A1 17             STX THIS_S
00D26A  2  AE 9B 17             LDX SAVE_S              ; Get program's stack pointer
00D26D  2  9A                   TXS
00D26E  2               
00D26E  2  A5 39                LDA ADDR+1              ; Push return address on program's stack
00D270  2  48                   PHA
00D271  2  A5 38                LDA ADDR
00D273  2  48                   PHA
00D274  2               
00D274  2  BA                   TSX                     ; Put program's stack pointer back
00D275  2  8E 9B 17             STX SAVE_S
00D278  2               
00D278  2  AE A1 17             LDX THIS_S              ; Restore our stack pointer
00D27B  2  9A                   TXS
00D27C  2               
00D27C  2  4C 10 D3             JMP AfterStep           ; We're done
00D27F  2               
00D27F  2               ; RTI - Pop P. Pop PC. Increment PC to get next PC.
00D27F  2               
00D27F  2               TryRTI:
00D27F  2  C9 40                CMP #$40                ; RTI
00D281  2  D0 2C                BNE TryRTS
00D283  2  BA                   TSX                     ; Save our stack pointer
00D284  2  8E A1 17             STX THIS_S
00D287  2  AE 9B 17             LDX SAVE_S              ; Get program's stack pointer
00D28A  2  9A                   TXS
00D28B  2  68                   PLA                     ; Pop P
00D28C  2  8D 9C 17             STA SAVE_P
00D28F  2  68                   PLA                     ; Pop return address low
00D290  2  85 38                STA ADDR
00D292  2  68                   PLA                     ; Pop return address high
00D293  2  85 39                STA ADDR+1
00D295  2  BA                   TSX                     ; Put program's stack pointer back
00D296  2  8E 9B 17             STX SAVE_S
00D299  2  AE A1 17             LDX THIS_S              ; Restore our stack pointer
00D29C  2  9A                   TXS
00D29D  2  A5 38                LDA ADDR
00D29F  2  18                   CLC
00D2A0  2  69 01                ADC #1                  ; Add 1 to get new PC
00D2A2  2  8D 9F 17             STA NEXT_PC
00D2A5  2  A5 39                LDA ADDR+1
00D2A7  2  69 00                ADC #0                  ; Add any carry
00D2A9  2  8D A0 17             STA NEXT_PC+1
00D2AC  2  4C 10 D3             JMP AfterStep           ; We're done
00D2AF  2               
00D2AF  2               ; RTS - Pop PC. Increment PC to get next PC.
00D2AF  2               
00D2AF  2               TryRTS:
00D2AF  2  C9 60                CMP #$60                ; RTS
00D2B1  2  D0 28                BNE Execute
00D2B3  2  BA                   TSX                     ; Save our stack pointer
00D2B4  2  8E A1 17             STX THIS_S
00D2B7  2  AE 9B 17             LDX SAVE_S              ; Get program's stack pointer
00D2BA  2  9A                   TXS
00D2BB  2  68                   PLA                     ; Pop return address low
00D2BC  2  85 38                STA ADDR
00D2BE  2  68                   PLA                     ; Pop return address high
00D2BF  2  85 39                STA ADDR+1
00D2C1  2  BA                   TSX                     ; Put program's stack pointer back
00D2C2  2  8E 9B 17             STX SAVE_S
00D2C5  2  AE A1 17             LDX THIS_S              ; Restore our stack pointer
00D2C8  2  9A                   TXS
00D2C9  2  A5 38                LDA ADDR
00D2CB  2  18                   CLC
00D2CC  2  69 01                ADC #1                  ; Add 1 to get new PC
00D2CE  2  8D 9F 17             STA NEXT_PC
00D2D1  2  A5 39                LDA ADDR+1
00D2D3  2  69 00                ADC #0                  ; Add any carry
00D2D5  2  8D A0 17             STA NEXT_PC+1
00D2D8  2  4C 10 D3             JMP AfterStep           ; We're done
00D2DB  2               
00D2DB  2               ; Not a special instruction. We execute it from the buffer.
00D2DB  2               
00D2DB  2               Execute:
00D2DB  2               ; Save this program's stack pointer so we can restore it later.
00D2DB  2               
00D2DB  2  BA                   TSX
00D2DC  2  8E A1 17             STX THIS_S
00D2DF  2               
00D2DF  2               ; Restore registers from saved values.
00D2DF  2               ; The order is critical here and P must be restored last.
00D2DF  2               
00D2DF  2  AE 9B 17             LDX SAVE_S              ; Restore stack pointer
00D2E2  2  9A                   TXS
00D2E3  2  AD 9C 17             LDA SAVE_P
00D2E6  2  48                   PHA                     ; Push P
00D2E7  2  AC 9A 17             LDY SAVE_Y              ; Restore Y
00D2EA  2  AE 99 17             LDX SAVE_X              ; Restore X
00D2ED  2  AD 98 17             LDA SAVE_A              ; Restore A
00D2F0  2  28                   PLP                     ; Restore P
00D2F1  2               
00D2F1  2               ; Call instruction in buffer.
00D2F1  2               ; It is followed by a JMP ReturnFromTrace so we get back
00D2F1  2               
00D2F1  2  4C AE 17             JMP TRACEINST
00D2F4  2               
00D2F4  2               ; We get here if a relative branch being traced was taken.
00D2F4  2               BranchTaken:
00D2F4  2  08                   PHP                     ; Save value of P because INC will change it
00D2F5  2  EE B6 17             INC TAKEN               ; Set flag that branch was taken
00D2F8  2  28                   PLP                     ; Restore P
00D2F9  2                                               ; Fall through to same code as normal return from trace
00D2F9  2               
00D2F9  2               ; We get here after the traced instruction was executed.
00D2F9  2               ReturnFromTrace:
00D2F9  2               
00D2F9  2               ; Save new register values. Opposite order as was restored above.
00D2F9  2               
00D2F9  2  08                   PHP
00D2FA  2  8D 98 17             STA SAVE_A
00D2FD  2  8E 99 17             STX SAVE_X
00D300  2  8C 9A 17             STY SAVE_Y
00D303  2  68                   PLA
00D304  2  8D 9C 17             STA SAVE_P
00D307  2  BA                   TSX
00D308  2  8E 9B 17             STX SAVE_S
00D30B  2               
00D30B  2               ; Clear D mode in case it is set, otherwise it would mess up our code.
00D30B  2               
00D30B  2  D8                   CLD
00D30C  2               
00D30C  2               ; Restore this program's stack pointer so RTS etc. will still work.
00D30C  2               
00D30C  2  AE A1 17             LDX THIS_S
00D30F  2  9A                   TXS
00D310  2               
00D310  2               AfterStep:
00D310  2               
00D310  2               ; Special case: If branch was taken (TAKEN=1), need to set next PC accordingly
00D310  2               
00D310  2  AD B6 17             LDA TAKEN
00D313  2  F0 37                BEQ NewPC
00D315  2               
00D315  2               ; Next PC is Current address (ADDR) + operand (branch offset) + 2
00D315  2               
00D315  2  A0 01                LDY #1
00D317  2  B1 38                LDA (ADDR),Y            ; Branch offset low
00D319  2  8D 8C 17             STA REL
00D31C  2  30 07                BMI Min                 ; If minus, high byte is sign extended to be $FF
00D31E  2  A9 00                LDA #0                  ; high byte is zero
00D320  2  8D 8D 17             STA REL+1
00D323  2  F0 05                BEQ Add
00D325  2               Min:
00D325  2  A9 FF                LDA #$FF                ; Negative offset, high byte is $FF
00D327  2  8D 8D 17             STA REL+1
00D32A  2               Add:
00D32A  2  A5 38                LDA ADDR                ; Get current address low byte
00D32C  2  18                   CLC
00D32D  2  6D 8C 17             ADC REL                 ; Add relative offset
00D330  2  8D 9F 17             STA NEXT_PC
00D333  2  A5 39                LDA ADDR+1              ; Get current address low byte
00D335  2  6D 8D 17             ADC REL+1               ; Add offset with any carry
00D338  2  8D A0 17             STA NEXT_PC+1
00D33B  2               
00D33B  2  AD 9F 17             LDA NEXT_PC             ; Get low byte of intermediate result
00D33E  2  18                   CLC
00D33F  2  69 02                ADC #2                  ; Add 2
00D341  2  8D 9F 17             STA NEXT_PC
00D344  2  AD A0 17             LDA NEXT_PC+1           ; Get low byte of intermediate result
00D347  2  69 00                ADC #0                  ; Add any carry
00D349  2  8D A0 17             STA NEXT_PC+1
00D34C  2                                               ; Now fall through to code below
00D34C  2               
00D34C  2               ; Set new PC to next PC
00D34C  2               NewPC:
00D34C  2  AD 9F 17             LDA NEXT_PC
00D34F  2  8D 9D 17             STA SAVE_PC
00D352  2  AD A0 17             LDA NEXT_PC+1
00D355  2  8D 9E 17             STA SAVE_PC+1
00D358  2               
00D358  2               ; Display register values
00D358  2               
00D358  2  20 09 BA             JSR PrintRegisters
00D35B  2               
00D35B  2               ; Disassemble next instruction (Set ADDR, call DISASM)
00D35B  2               
00D35B  2  AD 9D 17             LDA SAVE_PC
00D35E  2  85 38                STA ADDR
00D360  2  AD 9E 17             LDA SAVE_PC+1
00D363  2  85 39                STA ADDR+1
00D365  2  4C 80 C3             JMP DISASM              ; will return via caller
00D368  2               
00D368  2               ; Given an instruction opcode, return the instruction's length.
00D368  2               ; On entry opcode is in OPCODE. Length is returned in LEN.
00D368  2               ; Also sets opcode type in OP and addressing mode in AM.
00D368  2               ; Registers changed: A, X
00D368  2               GetLength:
00D368  2  AD 88 17             LDA OPCODE
00D36B  2  30 12                BMI @UPPER              ; If bit 7 set, in upper half of table
00D36D  2  0A                   ASL A                   ; double it since table is two bytes per entry
00D36E  2  AA                   TAX
00D36F  2  BD 76 C9             LDA OPCODES1,X          ; Get the instruction type (e.g. OP_LDA)
00D372  2  8D 89 17             STA OP                  ; Store it
00D375  2  E8                   INX
00D376  2  BD 76 C9             LDA OPCODES1,X          ; Get addressing mode
00D379  2  8D 8A 17             STA AM                  ; Store it
00D37C  2  4C 8E D3             JMP @AROUND
00D37F  2               @UPPER:
00D37F  2  0A                   ASL A                   ; Double it since table is two bytes per entry
00D380  2  AA                   TAX
00D381  2  BD 76 CA             LDA OPCODES2,X          ; Get the instruction type (e.g. OP_LDA)
00D384  2  8D 89 17             STA OP                  ; Store it
00D387  2  E8                   INX
00D388  2  BD 76 CA             LDA OPCODES2,X          ; Get addressing mode
00D38B  2  8D 8A 17             STA AM                  ; Store it
00D38E  2               @AROUND:
00D38E  2  AA                   TAX                     ; Put addressing mode in X
00D38F  2  BD 5D C9             LDA LENGTHS,X           ; Get instruction length given addressing mode
00D392  2  8D 8B 17             STA LEN                 ; Store it
00D395  2  60                   RTS                     ; Return
00D396  2               
00D396  1                 .include "info.s"
00D396  2               ; Information Routines
00D396  2               ;
00D396  2               ; Copyright (C) 2012-2020 by Jeff Tranter <tranter@pobox.com>
00D396  2               ;
00D396  2               ; Licensed under the Apache License, Version 2.0 (the "License");
00D396  2               ; you may not use this file except in compliance with the License.
00D396  2               ; You may obtain a copy of the License at
00D396  2               ;
00D396  2               ;   http://www.apache.org/licenses/LICENSE-2.0
00D396  2               ;
00D396  2               ; Unless required by applicable law or agreed to in writing, software
00D396  2               ; distributed under the License is distributed on an "AS IS" BASIS,
00D396  2               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
00D396  2               ; See the License for the specific language governing permissions and
00D396  2               ; limitations under the License.
00D396  2               ;
00D396  2               
00D396  2               ; iNfo command
00D396  2               ;
00D396  2               ; Displays information such as: detected CPU type, clock speed,
00D396  2               ;   range of RAM and ROM, detected peripheral cards. etc.
00D396  2               ;
00D396  2               ; Sample Output:
00D396  2               ;
00D396  2               ;         Computer: Apple //c
00D396  2               ;         CPU type: 65C02
00D396  2               ;        CPU speed: 2.0 MHZ
00D396  2               ;RAM detected from: $0000 TO $7FFF
00D396  2               ;       NMI vector: $0F00
00D396  2               ;     RESET vector: $FF00
00D396  2               ;   IRQ/BRK vector: $0100
00D396  2               ;         ACI card: NOT PRESENT
00D396  2               ;       CFFA1 card: NOT PRESENT
00D396  2               ;   MULTI I/O card: PRESENT
00D396  2               ;        BASIC ROM: PRESENT
00D396  2               ;     KRUSADER ROM: PRESENT
00D396  2               ;       WOZMON ROM: PRESENT
00D396  2               ;Slot ID Type
00D396  2               ; 1   31 serial or parallel
00D396  2               ; 2   31 serial or parallel
00D396  2               ; 3   88 80 column card
00D396  2               ; 4   20 joystick or mouse
00D396  2               ; 5   -- empty or unknown
00D396  2               ; 6   -- empty or unknown
00D396  2               ; 7   9B Network or bus interface
00D396  2               
00D396  2               Info:
00D396  2  20 8E BE             JSR PrintChar           ; Echo command
00D399  2  20 13 BE             JSR PrintCR
00D39C  2               
00D39C  2  20 4A BE             JSR Imprint             ; Display computer type
00D39F  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00D39F  2  20 20 20 20          .asciiz "         Computer: "
00D3A3  2  20 20 20 20  
00D3A7  2  20 43 6F 6D  
00D3B3  2               .elseif .defined(OSI)
00D3B3  2                       .asciiz "      Computer: "
00D3B3  2               .endif
00D3B3  2               
00D3B3  2               .if .defined(APPLE1)
00D3B3  2                       LDX #<TypeApple1String
00D3B3  2                       LDY #>TypeApple1String
00D3B3  2               
00D3B3  2               .elseif .defined(APPLE2)
00D3B3  2               
00D3B3  2               ; Identify model of Apple computer. Algorithm is from Apple //c
00D3B3  2               ; Reference Manual.
00D3B3  2               ; ID1 = FBB3
00D3B3  2               ; ID2 = FBC0
00D3B3  2               ; if (ID1) = 38
00D3B3  2               ;   then id = Apple II
00D3B3  2               ; else if (ID1) = EA
00D3B3  2               ;   then id = Apple II+
00D3B3  2               ; else if (ID1) = 06
00D3B3  2               ;   if (ID2) = EA
00D3B3  2               ;     then id = Apple //e
00D3B3  2               ;   else if (ID2) = 00
00D3B3  2               ;     then id = Apple //c
00D3B3  2               ; else
00D3B3  2               ;   id = Unknown
00D3B3  2               
00D3B3  2                       ID1 = $FBB3
00D3B3  2                       ID2 = $FBC0
00D3B3  2                       LDA ID1
00D3B3  2                       CMP #$38
00D3B3  2                       BNE Next1
00D3B3  2                       LDX #<TypeAppleIIString
00D3B3  2                       LDY #>TypeAppleIIString
00D3B3  2                       JMP PrintType
00D3B3  2               Next1:
00D3B3  2                       CMP #$EA
00D3B3  2                       BNE Next2
00D3B3  2                       LDX #<TypeAppleIIplusString
00D3B3  2                       LDY #>TypeAppleIIplusString
00D3B3  2                       JMP PrintType
00D3B3  2               Next2:
00D3B3  2                       CMP #$06
00D3B3  2                       BNE Unknown
00D3B3  2                       LDA ID2
00D3B3  2                       CMP #$EA
00D3B3  2                       BNE Next3
00D3B3  2                       LDX #<TypeAppleIIeString
00D3B3  2                       LDY #>TypeAppleIIeString
00D3B3  2                       JMP PrintType
00D3B3  2               Next3:
00D3B3  2                       CMP #$00
00D3B3  2                       BNE Unknown
00D3B3  2                       LDX #<TypeAppleIIcString
00D3B3  2                       LDY #>TypeAppleIIcString
00D3B3  2                       JMP PrintType
00D3B3  2               Unknown:
00D3B3  2                       LDX #<TypeAppleUnknown
00D3B3  2                       LDY #>TypeAppleUnknown
00D3B3  2               
00D3B3  2               .elseif .defined(KIM1)
00D3B3  2  A2 3E                LDX #<TypeKim1String
00D3B5  2  A0 C3                LDY #>TypeKim1String
00D3B7  2               .elseif .defined(OSI)
00D3B7  2                       LDX #<TypeOSIString
00D3B7  2                       LDY #>TypeOSIString
00D3B7  2               .elseif .defined(SBC)
00D3B7  2                       LDX #<TypeSBCString
00D3B7  2                       LDY #>TypeSBCString
00D3B7  2                .endif
00D3B7  2               
00D3B7  2               PrintType:
00D3B7  2  20 28 BE             JSR PrintString
00D3BA  2  20 13 BE             JSR PrintCR
00D3BD  2               
00D3BD  2  20 4A BE             JSR Imprint             ; Display CPU type
00D3C0  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00D3C0  2  20 20 20 20          .asciiz "         CPU type: "
00D3C4  2  20 20 20 20  
00D3C8  2  20 43 50 55  
00D3D4  2               .elseif .defined(OSI)
00D3D4  2                       .asciiz "      CPU type: "
00D3D4  2               .endif
00D3D4  2  20 8A D5             JSR CPUType
00D3D7  2  C9 01                CMP #1
00D3D9  2  D0 07                BNE @Try2
00D3DB  2  A2 2D                LDX #<Type6502String
00D3DD  2  A0 C3                LDY #>Type6502String
00D3DF  2  4C F5 D3             JMP @PrintCPU
00D3E2  2               @Try2:
00D3E2  2  C9 02                CMP #2
00D3E4  2  D0 07                BNE @Try3
00D3E6  2  A2 32                LDX #<Type65C02String
00D3E8  2  A0 C3                LDY #>Type65C02String
00D3EA  2  4C F5 D3             JMP @PrintCPU
00D3ED  2               @Try3:
00D3ED  2  C9 03                CMP #3
00D3EF  2  D0 0A                BNE @Invalid
00D3F1  2  A2 38                LDX #<Type65816String
00D3F3  2  A0 C3                LDY #>Type65816String
00D3F5  2               
00D3F5  2               @PrintCPU:
00D3F5  2  20 28 BE             JSR PrintString
00D3F8  2  20 13 BE             JSR PrintCR
00D3FB  2               
00D3FB  2               @Invalid:
00D3FB  2               
00D3FB  2               ; Speed test works on Apple 1 with Multi I/O card or Apple II with
00D3FB  2               ; Super Serial Card or Apple //c with on-board serial.
00D3FB  2               
00D3FB  2               .if .defined(APPLE1) .or .defined (APPLE2)
00D3FB  2               
00D3FB  2               .ifdef APPLE1
00D3FB  2                       JSR MultiIOPresent      ; Can only measure clock speed if we have a Multi I/O card
00D3FB  2               .endif
00D3FB  2               .ifdef APPLE2
00D3FB  2                       JSR SerialPresent       ; Can only measure clock speed if we have a serial port
00D3FB  2               .endif
00D3FB  2                       BEQ @SkipSpeed
00D3FB  2                       JSR Imprint
00D3FB  2                       .asciiz "        CPU speed: "
00D3FB  2                       JSR MeasureCPUSpeed
00D3FB  2                       STA BIN+0
00D3FB  2                       LDA #0
00D3FB  2                       STA BIN+1
00D3FB  2                       JSR BINBCD16
00D3FB  2                       LDA BCD+0               ; Will contain BCD number like $20 for 2.0 MHz
00D3FB  2                       TAX
00D3FB  2                       LSR A
00D3FB  2                       LSR A
00D3FB  2                       LSR A
00D3FB  2                       LSR A
00D3FB  2                       JSR PRHEX
00D3FB  2                       LDA #'.'
00D3FB  2                       JSR PrintChar
00D3FB  2                       TXA
00D3FB  2                       JSR PRHEX
00D3FB  2                       JSR Imprint
00D3FB  2                       .asciiz " MHz"
00D3FB  2                       JSR PrintCR
00D3FB  2               .endif
00D3FB  2               
00D3FB  2               @SkipSpeed:
00D3FB  2  20 4A BE             JSR Imprint           ; Print range of RAM
00D3FE  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00D3FE  2  52 41 4D 20          .asciiz "RAM detected from: $0000 to $"
00D402  2  64 65 74 65  
00D406  2  63 74 65 64  
00D41C  2               .elseif .defined(OSI)
00D41C  2                       .byte "RAM found from: $0000", CR, "            to: ", 0
00D41C  2               .endif
00D41C  2  20 C6 D5             JSR FindTopOfRAM
00D41F  2  20 AF BD             JSR PrintAddress
00D422  2  20 13 BE             JSR PrintCR
00D425  2               ;
00D425  2               ; Look for upper block of RAM on PAL-1
00D425  2               ;
00D425  2  AD 80 17             LDA $1780   ; Load whatever is at $1780 and save
00D428  2  48                   PHA
00D429  2  A9 00                LDA #$00
00D42B  2  8D 80 17             STA $1780
00D42E  2  AD 80 17             LDA $1780
00D431  2  C9 00                CMP #$00
00D433  2  D0 59                BNE @NORIOT
00D435  2  A9 FF                LDA #$FF
00D437  2  8D 80 17             STA $1780
00D43A  2  AD 80 17             LDA $1780
00D43D  2  C9 FF                CMP #$FF
00D43F  2  D0 4D                BNE @NORIOT
00D441  2  68                   PLA
00D442  2  8D 80 17             STA $1780
00D445  2               
00D445  2  AD FF 17             LDA $17FF   ; Load whatever is at $17FF and save
00D448  2  48                   PHA
00D449  2  A9 00                LDA #$00
00D44B  2  8D FF 17             STA $17FF
00D44E  2  AD FF 17             LDA $17FF
00D451  2  C9 00                CMP #$00
00D453  2  D0 39                BNE @NORIOT
00D455  2  A9 FF                LDA #$FF
00D457  2  8D FF 17             STA $17FF
00D45A  2  AD FF 17             LDA $17FF
00D45D  2  C9 FF                CMP #$FF
00D45F  2  D0 2D                BNE @NORIOT
00D461  2  68                   PLA
00D462  2  8D FF 17             STA $17FF
00D465  2               
00D465  2  20 4A BE             JSR Imprint           ; Print range of RAM
00D468  2  52 41 4D 20          .asciiz "RAM detected from: $1780 to $17FF"
00D46C  2  64 65 74 65  
00D470  2  63 74 65 64  
00D48A  2  20 13 BE             JSR PrintCR
00D48D  2               ; This is just a dummy push because we need to pop the
00D48D  2               ; top of stack in case no RAM was found.
00D48D  2  48                   PHA
00D48E  2               
00D48E  2               @NORIOT:
00D48E  2  68                   PLA
00D48F  2  AD 00 20             LDA $2000   ; Load whatever is at $1780 and save
00D492  2  48                   PHA
00D493  2  A9 00                LDA #$00
00D495  2  8D 00 20             STA $2000
00D498  2  AD 00 20             LDA $2000
00D49B  2  C9 00                CMP #$00
00D49D  2  D0 3B                BNE @NOERAM
00D49F  2  A9 FF                LDA #$FF
00D4A1  2  8D 00 20             STA $2000
00D4A4  2  AD 00 20             LDA $2000
00D4A7  2  C9 FF                CMP #$FF
00D4A9  2  D0 2F                BNE @NOERAM
00D4AB  2  68                   PLA
00D4AC  2  8D 00 20             STA $2000
00D4AF  2               
00D4AF  2  20 4A BE             JSR Imprint           ; Print range of RAM
00D4B2  2  52 41 4D 20          .asciiz "RAM detected from: $2000 to $"
00D4B6  2  64 65 74 65  
00D4BA  2  63 74 65 64  
00D4D0  2  20 BB D5             JSR FTOPRAM2
00D4D3  2  20 AF BD             JSR PrintAddress
00D4D6  2  20 13 BE             JSR PrintCR
00D4D9  2  48                   PHA     ; another dummy push
00D4DA  2               
00D4DA  2               @NOERAM:
00D4DA  2  68                   PLA
00D4DB  2               
00D4DB  2               ;
00D4DB  2               ; This needs to be improved, but basically it looks to
00D4DB  2               ; see if the timer seems to be running on a second RIOT
00D4DB  2               ; to determine if the RIOT expansion board is present
00D4DB  2               ; or not. --w4jbm
00D4DB  2               ;
00D4DB  2               
00D4DB  2  20 4A BE             JSR Imprint
00D4DE  2  20 20 32 6E          .asciiz "  2nd RIOT Board : "
00D4E2  2  64 20 52 49  
00D4E6  2  4F 54 20 42  
00D4F2  2               
00D4F2  2  AD 04 17             LDA $1704
00D4F5  2               
00D4F5  2  A2 FF                LDX #$FF
00D4F7  2               @DELAY1:
00D4F7  2  CA                   DEX
00D4F8  2  D0 FD                BNE @DELAY1
00D4FA  2               
00D4FA  2  CD 04 17             CMP $1704
00D4FD  2  D0 12                BNE @YESRIOT2
00D4FF  2               
00D4FF  2  A2 7F                LDX #$7F
00D501  2               @DELAY2:
00D501  2  CA                   DEX
00D502  2  D0 FD                BNE @DELAY2
00D504  2               
00D504  2  CD 04 17             CMP $1704
00D507  2  D0 08                BNE @YESRIOT2
00D509  2               
00D509  2               ; If $1704 seems to never change, we probably don't have
00D509  2               ; a second RIOT installed.
00D509  2               
00D509  2  20 4A BE             JSR Imprint
00D50C  2  4E 6F 74 20          .asciiz "Not "
00D510  2  00           
00D511  2               
00D511  2               @YESRIOT2:
00D511  2  20 4A BE             JSR Imprint
00D514  2  46 6F 75 6E          .asciiz "Found"
00D518  2  64 00        
00D51A  2  20 13 BE             JSR PrintCR
00D51D  2               
00D51D  2               
00D51D  2  20 4A BE            JSR Imprint           ; Print NMI vector address
00D520  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00D520  2  20 20 20 20          .asciiz "       NMI vector: $"
00D524  2  20 20 20 4E  
00D528  2  4D 49 20 76  
00D535  2               .elseif .defined(OSI)
00D535  2                       .asciiz "    NMI vector: $"
00D535  2               .endif
00D535  2  AE FA FF             LDX $FFFA
00D538  2  AC FB FF             LDY $FFFB
00D53B  2  20 AF BD             JSR PrintAddress
00D53E  2  20 13 BE             JSR PrintCR
00D541  2               
00D541  2  20 4A BE             JSR Imprint ; Print reset vector address
00D544  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00D544  2  20 20 20 20          .asciiz "     RESET vector: $"
00D548  2  20 52 45 53  
00D54C  2  45 54 20 76  
00D559  2               .elseif .defined(OSI)
00D559  2                       .asciiz "  RESET vector: $"
00D559  2               .endif
00D559  2  AE FC FF             LDX $FFFC
00D55C  2  AC FD FF             LDY $FFFD
00D55F  2  20 AF BD             JSR PrintAddress
00D562  2  20 13 BE             JSR PrintCR
00D565  2               
00D565  2  20 4A BE             JSR Imprint   ; Print IRQ/BRK vector address
00D568  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(KIM1) .or .defined(SBC)
00D568  2  20 20 20 49          .asciiz "   IRQ/BRK vector: $"
00D56C  2  52 51 2F 42  
00D570  2  52 4B 20 76  
00D57D  2               .elseif .defined(OSI)
00D57D  2                       .asciiz "IRQ/BRK vector: $"
00D57D  2               .endif
00D57D  2  AE FE FF             LDX $FFFE
00D580  2  AC FF FF             LDY $FFFF
00D583  2  20 AF BD             JSR PrintAddress
00D586  2  20 13 BE             JSR PrintCR
00D589  2               
00D589  2               .ifdef APPLE1
00D589  2                       JSR Imprint
00D589  2                       .asciiz "         ACI card: "
00D589  2                       JSR ACIPresent
00D589  2                       JSR PrintPresent
00D589  2                       JSR PrintCR
00D589  2               
00D589  2                       JSR Imprint
00D589  2                       .asciiz "       CFFA1 card: "
00D589  2                       JSR CFFA1Present
00D589  2                       JSR PrintPresent
00D589  2                       JSR PrintCR
00D589  2               
00D589  2                       JSR Imprint
00D589  2                       .asciiz "   Multi I/O Card: "
00D589  2                       JSR MultiIOPresent
00D589  2                       JSR PrintPresent
00D589  2                       JSR PrintCR
00D589  2               .endif
00D589  2               
00D589  2               .if .defined(APPLE) .or .defined(OSI)
00D589  2                       JSR Imprint
00D589  2               .if .defined(APPLE1) .or .defined(APPLE2) .or .defined(SBC)
00D589  2                       .asciiz "        BASIC ROM: "
00D589  2               .elseif .defined(OSI)
00D589  2                       .asciiz "     BASIC ROM: "
00D589  2               .endif
00D589  2                       JSR BASICPresent
00D589  2                       JSR PrintPresent
00D589  2                       JSR PrintCR
00D589  2               .endif
00D589  2               
00D589  2               .ifdef APPLE1
00D589  2                       JSR Imprint
00D589  2                       .asciiz "     Krusader ROM: "
00D589  2                       JSR KrusaderPresent
00D589  2                       JSR PrintPresent
00D589  2                       JSR PrintCR
00D589  2               .endif
00D589  2               
00D589  2               .ifdef APPLE1
00D589  2                       JSR Imprint
00D589  2                       .asciiz "       WozMon ROM: "
00D589  2                       JSR WozMonPresent
00D589  2                       JSR PrintPresent
00D589  2                       JSR PrintCR
00D589  2               .endif
00D589  2               
00D589  2               .ifdef APPLE2
00D589  2               ; Display IDs of cards in slots. Uses Pascal 1.1 firmware protocol.
00D589  2               ; Pseudodode:
00D589  2               ; print "Slot ID  Type\n"
00D589  2               ; for s in 1..7
00D589  2               ;   print " s   "
00D589  2               ;   if $Cs05 == $38 and $Cs07 == $18 and $Cn0B == $01
00D589  2               ;     id = $Cs0C
00D589  2               ;     print "id  "
00D589  2               ;     class = ( ID && $F0 ) >> 4
00D589  2               ;      switch class:
00D589  2               ;        case 0: print "reserved"
00D589  2               ;        case 1: print "printer"
00D589  2               ;        case 2: print "joystick or mouse"
00D589  2               ;        case 3: print "serial or parallel"
00D589  2               ;        case 4: print "modem"
00D589  2               ;        case 5: print "sound or speech device"
00D589  2               ;        case 6: print "clock"
00D589  2               ;        case 7: print "mass storage device"
00D589  2               ;        case 8: print "80 column card"
00D589  2               ;        case 9: print "Network or bus interface"
00D589  2               ;        case 10: print "special purpose"
00D589  2               ;        default: print "reserved"
00D589  2               ;   else
00D589  2               ;     print "--  empty or unknown\n"
00D589  2               
00D589  2                       JSR Imprint             ; Print table header
00D589  2                       .asciiz "Slot ID Type"
00D589  2                       JSR PrintCR             ; And newline
00D589  2               
00D589  2                       LDA #1                  ; Initialize slot number
00D589  2                       STA SLOT
00D589  2               Slots:
00D589  2                       JSR PrintSpace          ; Print a space
00D589  2                       LDA SLOT                ; Print slot number
00D589  2                       JSR PRHEX
00D589  2                       LDX #3                  ; Print three spaces
00D589  2                       JSR PrintSpaces
00D589  2               
00D589  2                       LDA SLOT                ; Get slot number
00D589  2                       CLC
00D589  2                       ADC #$C0                ; Calculate $Cs
00D589  2                       STA ADDR+1              ; High byte of address to read
00D589  2               
00D589  2                       LDA #$05                ; Want to read $Cs05
00D589  2                       STA ADDR                ; Low byte of address to read
00D589  2                       LDX #0                  ; Read $Cs05
00D589  2                       LDA (ADDR,X)
00D589  2                       CMP #$38                ; Should be $38 for peripheral card
00D589  2                       BEQ OK1
00D589  2                       JMP EmptySlot
00D589  2               OK1:
00D589  2                       LDA #$07                ; Want to read $Cs07
00D589  2                       STA ADDR                ; Low byte of address to read
00D589  2                       LDX #0                  ; Read $Cs07
00D589  2                       LDA (ADDR,X)
00D589  2                       CMP #$18                ; Should be $18 for peripheral card
00D589  2                       BEQ OK2
00D589  2                       JMP EmptySlot
00D589  2               OK2:
00D589  2                       LDA #$0B                ; Want to read $Cs0B
00D589  2                       STA ADDR                ; Low byte of address to read
00D589  2                       LDX #0                  ; Read $Cs0B
00D589  2                       LDA (ADDR,X)
00D589  2                       CMP #$01                ; Should be $01 for peripheral card
00D589  2                       BEQ OK3
00D589  2                       JMP EmptySlot
00D589  2               OK3:
00D589  2                       LDA #$0C                ; Want to read $Cs0C
00D589  2                       STA ADDR                ; Low byte of address to read
00D589  2                       LDX #0                  ; Read $Cs0C
00D589  2                       LDA (ADDR,X)            ; This is the card ID
00D589  2                       PHA                     ; Save A
00D589  2                       JSR PrintByte           ; Print card ID
00D589  2                       JSR PrintSpace          ; Then a space
00D589  2                       PLA                     ; Restore A (Card ID)
00D589  2                       AND #$F0                ; Mask off class portion of ID (upper nybble)
00D589  2                       LSR                     ; Shift into lower nybble
00D589  2                       LSR
00D589  2                       LSR
00D589  2                       LSR
00D589  2                       CMP #$00                ; Is it class 0?
00D589  2                       BNE Try1                ; If not, try next class.
00D589  2                       JSR Imprint             ; Display class
00D589  2                       .asciiz "reserved"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try1:
00D589  2                       CMP #$01
00D589  2                       BNE Try2
00D589  2                       JSR Imprint
00D589  2                       .asciiz "printer"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try2:
00D589  2                       CMP #$02
00D589  2                       BNE Try3
00D589  2                       JSR Imprint
00D589  2                       .asciiz "joystick or mouse"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try3:
00D589  2                       CMP #$03
00D589  2                       BNE Try4
00D589  2                       JSR Imprint
00D589  2                       .asciiz "serial or parallel"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try4:
00D589  2                       CMP #$04
00D589  2                       BNE Try5
00D589  2                       JSR Imprint
00D589  2                       .asciiz "modem"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try5:
00D589  2                       CMP #$05
00D589  2                       BNE Try6
00D589  2                       JSR Imprint
00D589  2                       .asciiz "sound or speech device"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try6:
00D589  2                       CMP #$06
00D589  2                       BNE Try7
00D589  2                       JSR Imprint
00D589  2                       .asciiz "clock"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try7:
00D589  2                       CMP #$07
00D589  2                       BNE Try8
00D589  2                       JSR Imprint
00D589  2                       .asciiz "mass storage device"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try8:
00D589  2                       CMP #$08
00D589  2                       BNE Try9
00D589  2                       JSR Imprint
00D589  2                       .asciiz "80 column card"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try9:
00D589  2                       CMP #$09
00D589  2                       BNE Try10
00D589  2                       JSR Imprint
00D589  2                       .asciiz "network or bus interface"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Try10:
00D589  2                       CMP #$0A
00D589  2                       BNE Default
00D589  2                       JSR Imprint
00D589  2                       .asciiz "special purpose"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               Default:
00D589  2                       JSR Imprint
00D589  2                       .asciiz "future expansion"
00D589  2                       JSR PrintCR
00D589  2                       JMP NextSlot
00D589  2               EmptySlot:
00D589  2                       JSR Imprint
00D589  2                       .asciiz "-- empty or unknown"
00D589  2                       JSR PrintCR
00D589  2               NextSlot:
00D589  2                       LDA SLOT                ; Get current slot
00D589  2                       CLC                     ; Add one
00D589  2                       ADC #1
00D589  2                       STA SLOT
00D589  2                       CMP #8                  ; Are we done?
00D589  2                       BEQ Done                ; Yes, done.
00D589  2                       JMP Slots               ; No, do next slot.
00D589  2               Done:
00D589  2               .endif
00D589  2  60                   RTS
00D58A  2               
00D58A  2               ; Determine type of CPU. Returns result in A.
00D58A  2               ; 1 - 6502, 2 - 65C02, 3 - 65816.
00D58A  2               ; Algorithm taken from Western Design Center programming manual.
00D58A  2               
00D58A  2               CPUType:
00D58A  2  F8                   SED           ; Trick with decimal mode used
00D58B  2  A9 99                LDA #$99      ; Set negative flag
00D58D  2  18                   CLC
00D58E  2  69 01                ADC #$01      ; Add 1 to get new accumulator value of 0
00D590  2  30 0D                BMI O2        ; 6502 does not clear negative flag so branch taken.
00D592  2               
00D592  2               ; 65C02 and 65816 clear negative flag in decimal mode
00D592  2               
00D592  2  18                   CLC
00D593  2                       .p816         ; Following Instruction is 65816
00D593  2  FB                   XCE           ; Valid on 65816, unimplemented NOP on 65C02
00D594  2  90 05                BCC C02       ; On 65C02 carry will still be clear and branch will be taken.
00D596  2  FB                   XCE           ; Switch back to emulation mode
00D597  2                       .p02          ; Go back to 6502 assembler mode
00D597  2  D8                   CLD
00D598  2  A9 03                LDA #3        ; 65816
00D59A  2  60                   RTS
00D59B  2               C02:
00D59B  2  D8                   CLD
00D59C  2  A9 02                LDA #2        ; 65C02
00D59E  2  60                   RTS
00D59F  2               O2:
00D59F  2  D8                   CLD
00D5A0  2  A9 01                LDA #1        ; 6502
00D5A2  2  60                   RTS
00D5A3  2               
00D5A3  2               ; Based on the value in A, displays "present" (1) or "not present" (0).
00D5A3  2               
00D5A3  2               PrintPresent:
00D5A3  2  C9 00                CMP #0
00D5A5  2  D0 08                BNE @Present
00D5A7  2  20 4A BE             JSR Imprint
00D5AA  2  6E 6F 74 20          .asciiz "not "
00D5AE  2  00           
00D5AF  2               @Present:
00D5AF  2  20 4A BE             JSR Imprint
00D5B2  2  70 72 65 73          .asciiz "present"
00D5B6  2  65 6E 74 00  
00D5BA  2  60                   RTS
00D5BB  2               
00D5BB  2               ; Determines top of installed RAM while trying not to corrupt any other
00D5BB  2               ; program including this one. We assume RAM starts at 0. Returns top
00D5BB  2               ; RAM address in X (low), Y (high).
00D5BB  2               
00D5BB  2                LIMIT = $FFFF        ; Highest address we want to test
00D5BB  2                TOP   = $00          ; Holds current highest address of RAM (two bytes)
00D5BB  2               
00D5BB  2               FTOPRAM2:
00D5BB  2  A9 00                LDA #<$2000
00D5BD  2  85 00                STA TOP
00D5BF  2  A9 20                LDA #>$2000
00D5C1  2  85 01                STA TOP+1
00D5C3  2  4C CE D5             JMP TORAMP2   ; Pass 2 at top of RAM starting from $2000
00D5C6  2               
00D5C6  2               FindTopOfRAM:
00D5C6  2               
00D5C6  2  A9 02                LDA #<$0002         ; Store $0002 in TOP (don't want to change TOP)
00D5C8  2  85 00                STA TOP
00D5CA  2  A9 00                LDA #>$0002
00D5CC  2  85 01                STA TOP+1
00D5CE  2               
00D5CE  2               TORAMP2:
00D5CE  2               @Loop:
00D5CE  2  A0 00                LDY #0
00D5D0  2  B1 00                LDA (TOP),Y         ; Read current contents of (TOP)
00D5D2  2               
00D5D2  2  AA                   TAX                 ; Save in register so we can later restore it
00D5D3  2               ;        LDA #0              ; Write all zeroes to (TOP)
00D5D3  2               ;        STA (TOP),Y
00D5D3  2               ;        CMP (TOP),Y         ; Does it read back?
00D5D3  2               ;        BNE @TopFound       ; If not, top of memory found
00D5D3  2               ;        LDA #$FF            ; Write all ones to (TOP)
00D5D3  2               ;        STA (TOP),Y
00D5D3  2               ;        CMP (TOP),Y         ; Does it read back?
00D5D3  2               ;        BNE @TopFound       ; If not, top of memory found
00D5D3  2  A9 AA                LDA #$AA            ; Write alternating bits to (TOP)
00D5D5  2  91 00                STA (TOP),Y
00D5D7  2  D1 00                CMP (TOP),Y         ; Does it read back?
00D5D9  2  D0 30                BNE @TopFound       ; If not, top of memory found
00D5DB  2  A9 55                LDA #$55            ; Write alternating bits to (TOP)
00D5DD  2  91 00                STA (TOP),Y
00D5DF  2  D1 00                CMP (TOP),Y         ; Does it read back?
00D5E1  2  D0 28                BNE @TopFound       ; If not, top of memory found
00D5E3  2               
00D5E3  2  8A                   TXA                 ; Write original data back to (TOP)
00D5E4  2  91 00                STA (TOP),Y
00D5E6  2               
00D5E6  2  A5 00                LDA TOP             ; Increment TOP (low,high)
00D5E8  2  18                   CLC
00D5E9  2  69 01                ADC #1
00D5EB  2  85 00                STA TOP
00D5ED  2  A5 01                LDA TOP+1
00D5EF  2  69 00                ADC #0              ; Add any carry
00D5F1  2  85 01                STA TOP+1
00D5F3  2               
00D5F3  2               ;  Are we testing in the range of this code (i.e. the same 256 byte
00D5F3  2               ;  page)? If so, need to skip over it because otherwise the memory
00D5F3  2               ;  test will collide with the code being executed when writing to it.
00D5F3  2               
00D5F3  2               
00D5F3  2  A5 01                LDA TOP+1           ; High byte of page
00D5F5  2  C9 D5                CMP #(>FindTopOfRAMEnd - 1)      ; Was FindTopOfRAM  ; Same page as this code?
00D5F7  2  F0 02                BEQ @Skip
00D5F9  2               ;        CMP #>FindTopOfRAMEnd ; Same page as this code (code could cross two pages)
00D5F9  2               ;        BEQ @Skip
00D5F9  2  D0 04                BNE @NotUs
00D5FB  2               @Skip:
00D5FB  2  E6 01                INC TOP+1           ; Skip over this page when testing
00D5FD  2  E6 01                INC TOP+1
00D5FF  2               
00D5FF  2               @NotUs:
00D5FF  2               
00D5FF  2  A5 01                LDA TOP+1           ; Did we reach LIMIT? (high byte)
00D601  2  C9 FF                CMP #>LIMIT
00D603  2  D0 C9                BNE @Loop           ; If not, keep looping
00D605  2  A5 00                LDA TOP             ; Did we reach LIMIT? (low byte)
00D607  2  C9 FF                CMP #<LIMIT
00D609  2  D0 C3                BNE @Loop           ; If not, keep looping
00D60B  2               
00D60B  2               @TopFound:
00D60B  2  8A                   TXA                 ; Write original data back to (TOP) just in case it is important
00D60C  2  91 00                STA (TOP),Y
00D60E  2               
00D60E  2               FindTopOfRAMEnd:            ; End of critical section we don't want to write to during testing
00D60E  2               
00D60E  2  A5 00                LDA TOP             ; Decrement TOP by 1 to get last RAM address
00D610  2  38                   SEC
00D611  2  E9 01                SBC #1
00D613  2  85 00                STA TOP
00D615  2  A5 01                LDA TOP+1
00D617  2  E9 00                SBC #0              ; Subtract any borrow
00D619  2  85 01                STA TOP+1
00D61B  2               
00D61B  2  A6 00                LDX TOP             ; Set top of RAM as TOP (X-low Y-high)
00D61D  2  A4 01                LDY TOP+1
00D61F  2               
00D61F  2  60                   RTS                 ; Return
00D620  2               
00D620  2               ; Measure CPU clock speed by sending characters out the serial port of
00D620  2               ; a Multi I/O board and counting how many CPU cycles it takes. Returns
00D620  2               ; value in A that is approximately CPU speed in MHz * 10.
00D620  2               
00D620  2               .if .defined(APPLE1) .or .defined(APPLE2)
00D620  2               
00D620  2               MeasureCPUSpeed:
00D620  2               
00D620  2               .ifdef APPLE1
00D620  2               ; 6551 Chip registers
00D620  2                       TXDATA = $C300
00D620  2                       RXDATA = $C300
00D620  2                       STATUSREG = $C301
00D620  2                       CMDREG = $C302
00D620  2                       CTLREG = $C303
00D620  2               .endif
00D620  2               
00D620  2               .ifdef APPLE2
00D620  2               ; 6551 Chip registers
00D620  2                       TXDATA = $C098
00D620  2                       RXDATA = $C098
00D620  2                       STATUSREG = $C099
00D620  2                       CMDREG = $C09A
00D620  2                       CTLREG = $C09B
00D620  2               .endif
00D620  2               
00D620  2               ; Set 1 stop bit, 8 bit data, internal clock, 19200bps
00D620  2                       LDA #%00011111
00D620  2                       STA CTLREG
00D620  2               
00D620  2               ; Set no parity, no echo, no TX interrupts, RTS low, no RX interrupts, DTR low
00D620  2                      LDA #%00001011
00D620  2                      STA CMDREG
00D620  2               
00D620  2                       LDA #'A'  ; Character to send
00D620  2                       LDX #0    ; Counter
00D620  2                       JSR Echo
00D620  2                       JSR Echo
00D620  2                       JSR Echo
00D620  2                       TXA
00D620  2                       RTS
00D620  2               
00D620  2               ; Send character in A out serial port
00D620  2               Echo:
00D620  2                       PHA
00D620  2                       LDA #$10
00D620  2               TXFULL: INX
00D620  2                       LDY #8          ; Add additional delay
00D620  2               @Delay: DEY
00D620  2                       BNE @Delay
00D620  2                       NOP
00D620  2                       NOP
00D620  2                       BIT STATUSREG ; wait for TDRE bit = 1
00D620  2                       BEQ TXFULL
00D620  2                       PLA
00D620  2                       STA TXDATA
00D620  2                       RTS
00D620  2               .endif
00D620  2               
00D620  1               ; .include "memtest4.s"
00D620  1               ; .include "delay.s"
00D620  1               
00D620  1               ; Non-Page Zero Variables. Note: These must be in RAM. Use a .org
00D620  1               ; below corresponding to RAM if the program is linked into ROM.
00D620  1               ; This is in the RAM typically found on the RIOT chip for the PAL-1
00D620  1               
00D620  1               .org $1780
001780  1               
001780  1  xx           RETOK:    .res 1                ; Sets whether <Return> key is accepted in some input routines
001781  1  xx           BIN:      .res 1                ; Holds binary value low byte
001782  1  xx           BINH:     .res 1                ; Holds binary value high byte
001783  1  xx xx xx     BCD:      .res 3                ; Holds BCD decimal number (3 bytes)
001786  1  xx           LZ:       .res 1                ; Boolean for leading zero suppression
001787  1  xx           LAST:     .res 1                ; Boolean for leading zero suppression / indicates last byte
001788  1  xx           OPCODE:   .res 1                ; Instruction opcode
001789  1  xx           OP:       .res 1                ; Instruction type OP_*
00178A  1  xx           AM:       .res 1                ; Addressing mode AM_*
00178B  1  xx           LEN:      .res 1                ; Instruction length
00178C  1  xx xx        REL:      .res 2                ; Relative addressing branch offset (2 bytes)
00178E  1  xx xx        DEZT:     .res 2                ; Relative address destination address (2 bytes)
001790  1  xx xx        START:    .res 2                ; Memory test - user entered start of memory range. Min is 8 (2 bytes)
001792  1  xx xx        END:      .res 2                ; Memory test - user entered end of memory range (2 bytes)
001794  1  xx xx xx xx  BPD:      .res 4                ; Instruction at breakpoint (1 byte * 4 breakpoints)
001798  1  xx           SAVE_A:   .res 1                ; Holds saved values of registers
001799  1  xx           SAVE_X:   .res 1                ; "
00179A  1  xx           SAVE_Y:   .res 1                ; "
00179B  1  xx           SAVE_S:   .res 1                ; "
00179C  1  xx           SAVE_P:   .res 1                ; "
00179D  1  xx xx        SAVE_PC:  .res 2                ; "
00179F  1  xx xx        NEXT_PC:  .res 2                ; Value of PC after next instruction
0017A1  1  xx           THIS_S:   .res 1                ; Saved value of JMON's stack pointer
0017A2  1  xx           CHAROK:   .res 1                ; Set to 1 if okay to enter characters prefixed by '
0017A3  1  xx           CHARMODE: .res 1                ; Set if currently entering in character (ASCII) mode
0017A4  1               ;OWDELAY:   .res 1               ; Delay value when writing (defaults to zero)
0017A4  1  xx           OUPPER:   .res 1                ; Set to $FF when only uppercase output is is desired.
0017A5  1  xx           OHIGHASCII: .res 1              ; Set to $FF when characters should have high bit set
0017A6  1  xx           OCPU:      .res 1               ; CPU type for disassembly
0017A7  1  xx           MBIT:      .res 1               ; For 65816 disassembly, tracks state of M bit in P
0017A8  1  xx           XBIT:      .res 1               ; For 65816 disassembly, tracks state of X bit in P
0017A9  1               .ifdef MINIASM
0017A9  1  xx xx xx     MNEM:      .res 3               ; Hold three letter mnemonic string used by assembler
0017AC  1  xx xx        OPERAND:   .res 2               ; Holds any operands for assembled instruction
0017AE  1               .endif
0017AE  1  xx xx xx xx  TRACEINST: .res 8               ; buffer holding traced instruction followed by a JMP and optionally another jump (Up to 8 bytes)
0017B2  1  xx xx xx xx  
0017B6  1  xx           TAKEN:     .res 1               ; Flag indicating if a traced branch instruction was taken
0017B7  1  xx           XSAV2:     .res 1               ; Saved registers
0017B8  1  xx           YSAV2:     .res 1
0017B9  1  xx           ASAV2:     .res 1
0017BA  1               
0017BA  1  xx           temp1:     .res 1               ; Temporary value
0017BB  1  xx           checksum:  .res 1               ; Calculated checksum
0017BC  1  xx           bytesRead: .res 1               ; Number of record bytes read
0017BD  1  xx           recordType: .res 1              ; S record type field, e.g '9'
0017BE  1  xx           byteCount: .res 1               ; S record byte count field
0017BF  1  xx           bytesWritten: .res 1            ; Number of record bytes written
0017BF  1               
